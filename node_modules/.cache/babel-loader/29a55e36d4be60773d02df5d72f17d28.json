{"ast":null,"code":"(function () {\n  /*\n  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n  Code distributed by Google as part of the polymer project is also\n  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n  */\n  'use strict';\n\n  var aa = \"function\" == typeof Object.defineProperties ? Object.defineProperty : function (a, b, c) {\n    a != Array.prototype && a != Object.prototype && (a[b] = c.value);\n  },\n      n = \"undefined\" != typeof window && window === this ? this : \"undefined\" != typeof global && null != global ? global : this;\n\n  function ba() {\n    ba = function () {};\n\n    n.Symbol || (n.Symbol = ca);\n  }\n\n  var ca = function () {\n    var a = 0;\n    return function (b) {\n      return \"jscomp_symbol_\" + (b || \"\") + a++;\n    };\n  }();\n\n  function p() {\n    ba();\n    var a = n.Symbol.iterator;\n    a || (a = n.Symbol.iterator = n.Symbol(\"iterator\"));\n    \"function\" != typeof Array.prototype[a] && aa(Array.prototype, a, {\n      configurable: !0,\n      writable: !0,\n      value: function () {\n        return da(this);\n      }\n    });\n\n    p = function () {};\n  }\n\n  function da(a) {\n    var b = 0;\n    return ea(function () {\n      return b < a.length ? {\n        done: !1,\n        value: a[b++]\n      } : {\n        done: !0\n      };\n    });\n  }\n\n  function ea(a) {\n    p();\n    a = {\n      next: a\n    };\n\n    a[n.Symbol.iterator] = function () {\n      return this;\n    };\n\n    return a;\n  }\n\n  function fa(a) {\n    p();\n    var b = a[Symbol.iterator];\n    return b ? b.call(a) : da(a);\n  }\n\n  function ha(a) {\n    for (var b, c = []; !(b = a.next()).done;) c.push(b.value);\n\n    return c;\n  }\n\n  function r(a, b) {\n    return {\n      index: a,\n      j: [],\n      m: b\n    };\n  }\n\n  function ia(a, b, c, d) {\n    var e = 0,\n        f = 0,\n        h = 0,\n        g = 0,\n        k = Math.min(b - e, d - f);\n    if (0 == e && 0 == f) a: {\n      for (h = 0; h < k; h++) if (a[h] !== c[h]) break a;\n\n      h = k;\n    }\n\n    if (b == a.length && d == c.length) {\n      g = a.length;\n\n      for (var l = c.length, m = 0; m < k - h && ja(a[--g], c[--l]);) m++;\n\n      g = m;\n    }\n\n    e += h;\n    f += h;\n    b -= g;\n    d -= g;\n    if (0 == b - e && 0 == d - f) return [];\n\n    if (e == b) {\n      for (b = r(e, 0); f < d;) b.j.push(c[f++]);\n\n      return [b];\n    }\n\n    if (f == d) return [r(e, b - e)];\n    k = e;\n    h = f;\n    d = d - h + 1;\n    g = b - k + 1;\n    b = Array(d);\n\n    for (l = 0; l < d; l++) b[l] = Array(g), b[l][0] = l;\n\n    for (l = 0; l < g; l++) b[0][l] = l;\n\n    for (l = 1; l < d; l++) for (m = 1; m < g; m++) if (a[k + m - 1] === c[h + l - 1]) b[l][m] = b[l - 1][m - 1];else {\n      var q = b[l - 1][m] + 1,\n          z = b[l][m - 1] + 1;\n      b[l][m] = q < z ? q : z;\n    }\n\n    k = b.length - 1;\n    h = b[0].length - 1;\n    d = b[k][h];\n\n    for (a = []; 0 < k || 0 < h;) 0 == k ? (a.push(2), h--) : 0 == h ? (a.push(3), k--) : (g = b[k - 1][h - 1], l = b[k - 1][h], m = b[k][h - 1], q = l < m ? l < g ? l : g : m < g ? m : g, q == g ? (g == d ? a.push(0) : (a.push(1), d = g), k--, h--) : q == l ? (a.push(3), k--, d = l) : (a.push(2), h--, d = m));\n\n    a.reverse();\n    b = void 0;\n    k = [];\n\n    for (h = 0; h < a.length; h++) switch (a[h]) {\n      case 0:\n        b && (k.push(b), b = void 0);\n        e++;\n        f++;\n        break;\n\n      case 1:\n        b || (b = r(e, 0));\n        b.m++;\n        e++;\n        b.j.push(c[f]);\n        f++;\n        break;\n\n      case 2:\n        b || (b = r(e, 0));\n        b.m++;\n        e++;\n        break;\n\n      case 3:\n        b || (b = r(e, 0)), b.j.push(c[f]), f++;\n    }\n\n    b && k.push(b);\n    return k;\n  }\n\n  function ja(a, b) {\n    return a === b;\n  }\n\n  ;\n  var t = window.ShadyDOM || {};\n  t.R = !(!Element.prototype.attachShadow || !Node.prototype.getRootNode);\n  var u = Object.getOwnPropertyDescriptor(Node.prototype, \"firstChild\");\n  t.h = !!(u && u.configurable && u.get);\n  t.H = t.force || !t.R;\n\n  function v(a) {\n    return a.__shady && void 0 !== a.__shady.firstChild;\n  }\n\n  function w(a) {\n    return \"ShadyRoot\" === a.K;\n  }\n\n  function x(a) {\n    a = a.getRootNode();\n    if (w(a)) return a;\n  }\n\n  var y = Element.prototype,\n      ka = y.matches || y.matchesSelector || y.mozMatchesSelector || y.msMatchesSelector || y.oMatchesSelector || y.webkitMatchesSelector;\n\n  function A(a, b) {\n    if (a && b) for (var c = Object.getOwnPropertyNames(b), d = 0, e; d < c.length && (e = c[d]); d++) {\n      var f = Object.getOwnPropertyDescriptor(b, e);\n      f && Object.defineProperty(a, e, f);\n    }\n  }\n\n  function B(a, b) {\n    for (var c = [], d = 1; d < arguments.length; ++d) c[d - 1] = arguments[d];\n\n    for (d = 0; d < c.length; d++) A(a, c[d]);\n\n    return a;\n  }\n\n  function la(a, b) {\n    for (var c in b) a[c] = b[c];\n  }\n\n  var C = document.createTextNode(\"\"),\n      ma = 0,\n      D = [];\n  new MutationObserver(function () {\n    for (; D.length;) try {\n      D.shift()();\n    } catch (a) {\n      throw C.textContent = ma++, a;\n    }\n  }).observe(C, {\n    characterData: !0\n  });\n\n  function na(a) {\n    D.push(a);\n    C.textContent = ma++;\n  }\n\n  var oa = !!document.contains;\n\n  function pa(a, b) {\n    for (; b;) {\n      if (b == a) return !0;\n      b = b.parentNode;\n    }\n\n    return !1;\n  }\n\n  ;\n  var qa = /[&\\u00A0\"]/g,\n      sa = /[&\\u00A0<>]/g;\n\n  function ta(a) {\n    switch (a) {\n      case \"&\":\n        return \"&amp;\";\n\n      case \"<\":\n        return \"&lt;\";\n\n      case \">\":\n        return \"&gt;\";\n\n      case '\"':\n        return \"&quot;\";\n\n      case \"\\u00a0\":\n        return \"&nbsp;\";\n    }\n  }\n\n  function ua(a) {\n    for (var b = {}, c = 0; c < a.length; c++) b[a[c]] = !0;\n\n    return b;\n  }\n\n  var va = ua(\"area base br col command embed hr img input keygen link meta param source track wbr\".split(\" \")),\n      wa = ua(\"style script xmp iframe noembed noframes plaintext noscript\".split(\" \"));\n\n  function E(a, b) {\n    \"template\" === a.localName && (a = a.content);\n\n    for (var c = \"\", d = b ? b(a) : a.childNodes, e = 0, f = d.length, h; e < f && (h = d[e]); e++) {\n      a: {\n        var g = h;\n        var k = a;\n        var l = b;\n\n        switch (g.nodeType) {\n          case Node.ELEMENT_NODE:\n            for (var m = g.localName, q = \"<\" + m, z = g.attributes, ra = 0; k = z[ra]; ra++) q += \" \" + k.name + '=\"' + k.value.replace(qa, ta) + '\"';\n\n            q += \">\";\n            g = va[m] ? q : q + E(g, l) + \"</\" + m + \">\";\n            break a;\n\n          case Node.TEXT_NODE:\n            g = g.data;\n            g = k && wa[k.localName] ? g : g.replace(sa, ta);\n            break a;\n\n          case Node.COMMENT_NODE:\n            g = \"\\x3c!--\" + g.data + \"--\\x3e\";\n            break a;\n\n          default:\n            throw window.console.error(g), Error(\"not implemented\");\n        }\n      }\n\n      c += g;\n    }\n\n    return c;\n  }\n\n  ;\n  var F = {},\n      G = document.createTreeWalker(document, NodeFilter.SHOW_ALL, null, !1),\n      H = document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT, null, !1);\n\n  function xa(a) {\n    var b = [];\n    G.currentNode = a;\n\n    for (a = G.firstChild(); a;) b.push(a), a = G.nextSibling();\n\n    return b;\n  }\n\n  F.parentNode = function (a) {\n    G.currentNode = a;\n    return G.parentNode();\n  };\n\n  F.firstChild = function (a) {\n    G.currentNode = a;\n    return G.firstChild();\n  };\n\n  F.lastChild = function (a) {\n    G.currentNode = a;\n    return G.lastChild();\n  };\n\n  F.previousSibling = function (a) {\n    G.currentNode = a;\n    return G.previousSibling();\n  };\n\n  F.nextSibling = function (a) {\n    G.currentNode = a;\n    return G.nextSibling();\n  };\n\n  F.childNodes = xa;\n\n  F.parentElement = function (a) {\n    H.currentNode = a;\n    return H.parentNode();\n  };\n\n  F.firstElementChild = function (a) {\n    H.currentNode = a;\n    return H.firstChild();\n  };\n\n  F.lastElementChild = function (a) {\n    H.currentNode = a;\n    return H.lastChild();\n  };\n\n  F.previousElementSibling = function (a) {\n    H.currentNode = a;\n    return H.previousSibling();\n  };\n\n  F.nextElementSibling = function (a) {\n    H.currentNode = a;\n    return H.nextSibling();\n  };\n\n  F.children = function (a) {\n    var b = [];\n    H.currentNode = a;\n\n    for (a = H.firstChild(); a;) b.push(a), a = H.nextSibling();\n\n    return b;\n  };\n\n  F.innerHTML = function (a) {\n    return E(a, function (a) {\n      return xa(a);\n    });\n  };\n\n  F.textContent = function (a) {\n    switch (a.nodeType) {\n      case Node.ELEMENT_NODE:\n      case Node.DOCUMENT_FRAGMENT_NODE:\n        a = document.createTreeWalker(a, NodeFilter.SHOW_TEXT, null, !1);\n\n        for (var b = \"\", c; c = a.nextNode();) b += c.nodeValue;\n\n        return b;\n\n      default:\n        return a.nodeValue;\n    }\n  };\n\n  var I = {},\n      ya = Element.prototype.insertBefore,\n      za = Element.prototype.removeChild,\n      Aa = Element.prototype.setAttribute,\n      Ba = Element.prototype.removeAttribute,\n      Ca = Element.prototype.cloneNode,\n      Da = Document.prototype.importNode,\n      Ea = Element.prototype.addEventListener,\n      Fa = Element.prototype.removeEventListener,\n      Ga = Window.prototype.addEventListener,\n      Ha = Window.prototype.removeEventListener,\n      Ia = Element.prototype.dispatchEvent,\n      Ja = Element.prototype.querySelector,\n      Ka = Element.prototype.querySelectorAll,\n      La = Node.prototype.contains || HTMLElement.prototype.contains;\n  I.appendChild = Element.prototype.appendChild;\n  I.insertBefore = ya;\n  I.removeChild = za;\n  I.setAttribute = Aa;\n  I.removeAttribute = Ba;\n  I.cloneNode = Ca;\n  I.importNode = Da;\n  I.addEventListener = Ea;\n  I.removeEventListener = Fa;\n  I.T = Ga;\n  I.U = Ha;\n  I.dispatchEvent = Ia;\n  I.querySelector = Ja;\n  I.querySelectorAll = Ka;\n  I.contains = La;\n  var J = Object.getOwnPropertyDescriptor(Element.prototype, \"innerHTML\") || Object.getOwnPropertyDescriptor(HTMLElement.prototype, \"innerHTML\"),\n      Ma = document.implementation.createHTMLDocument(\"inert\"),\n      K = Object.getOwnPropertyDescriptor(Document.prototype, \"activeElement\"),\n      Na = {\n    parentElement: {\n      get: function () {\n        var a = this.__shady && this.__shady.parentNode;\n        a && a.nodeType !== Node.ELEMENT_NODE && (a = null);\n        return void 0 !== a ? a : F.parentElement(this);\n      },\n      configurable: !0\n    },\n    parentNode: {\n      get: function () {\n        var a = this.__shady && this.__shady.parentNode;\n        return void 0 !== a ? a : F.parentNode(this);\n      },\n      configurable: !0\n    },\n    nextSibling: {\n      get: function () {\n        var a = this.__shady && this.__shady.nextSibling;\n        return void 0 !== a ? a : F.nextSibling(this);\n      },\n      configurable: !0\n    },\n    previousSibling: {\n      get: function () {\n        var a = this.__shady && this.__shady.previousSibling;\n        return void 0 !== a ? a : F.previousSibling(this);\n      },\n      configurable: !0\n    },\n    className: {\n      get: function () {\n        return this.getAttribute(\"class\") || \"\";\n      },\n      set: function (a) {\n        this.setAttribute(\"class\", a);\n      },\n      configurable: !0\n    },\n    nextElementSibling: {\n      get: function () {\n        if (this.__shady && void 0 !== this.__shady.nextSibling) {\n          for (var a = this.nextSibling; a && a.nodeType !== Node.ELEMENT_NODE;) a = a.nextSibling;\n\n          return a;\n        }\n\n        return F.nextElementSibling(this);\n      },\n      configurable: !0\n    },\n    previousElementSibling: {\n      get: function () {\n        if (this.__shady && void 0 !== this.__shady.previousSibling) {\n          for (var a = this.previousSibling; a && a.nodeType !== Node.ELEMENT_NODE;) a = a.previousSibling;\n\n          return a;\n        }\n\n        return F.previousElementSibling(this);\n      },\n      configurable: !0\n    }\n  },\n      L = {\n    childNodes: {\n      get: function () {\n        if (v(this)) {\n          if (!this.__shady.childNodes) {\n            this.__shady.childNodes = [];\n\n            for (var a = this.firstChild; a; a = a.nextSibling) this.__shady.childNodes.push(a);\n          }\n\n          var b = this.__shady.childNodes;\n        } else b = F.childNodes(this);\n\n        b.item = function (a) {\n          return b[a];\n        };\n\n        return b;\n      },\n      configurable: !0\n    },\n    childElementCount: {\n      get: function () {\n        return this.children.length;\n      },\n      configurable: !0\n    },\n    firstChild: {\n      get: function () {\n        var a = this.__shady && this.__shady.firstChild;\n        return void 0 !== a ? a : F.firstChild(this);\n      },\n      configurable: !0\n    },\n    lastChild: {\n      get: function () {\n        var a = this.__shady && this.__shady.lastChild;\n        return void 0 !== a ? a : F.lastChild(this);\n      },\n      configurable: !0\n    },\n    textContent: {\n      get: function () {\n        if (v(this)) {\n          for (var a = [], b = 0, c = this.childNodes, d; d = c[b]; b++) d.nodeType !== Node.COMMENT_NODE && a.push(d.textContent);\n\n          return a.join(\"\");\n        }\n\n        return F.textContent(this);\n      },\n      set: function (a) {\n        if (\"undefined\" === typeof a || null === a) a = \"\";\n\n        switch (this.nodeType) {\n          case Node.ELEMENT_NODE:\n          case Node.DOCUMENT_FRAGMENT_NODE:\n            for (; this.firstChild;) this.removeChild(this.firstChild);\n\n            (0 < a.length || this.nodeType === Node.ELEMENT_NODE) && this.appendChild(document.createTextNode(a));\n            break;\n\n          default:\n            this.nodeValue = a;\n        }\n      },\n      configurable: !0\n    },\n    firstElementChild: {\n      get: function () {\n        if (this.__shady && void 0 !== this.__shady.firstChild) {\n          for (var a = this.firstChild; a && a.nodeType !== Node.ELEMENT_NODE;) a = a.nextSibling;\n\n          return a;\n        }\n\n        return F.firstElementChild(this);\n      },\n      configurable: !0\n    },\n    lastElementChild: {\n      get: function () {\n        if (this.__shady && void 0 !== this.__shady.lastChild) {\n          for (var a = this.lastChild; a && a.nodeType !== Node.ELEMENT_NODE;) a = a.previousSibling;\n\n          return a;\n        }\n\n        return F.lastElementChild(this);\n      },\n      configurable: !0\n    },\n    children: {\n      get: function () {\n        var a;\n        v(this) ? a = Array.prototype.filter.call(this.childNodes, function (a) {\n          return a.nodeType === Node.ELEMENT_NODE;\n        }) : a = F.children(this);\n\n        a.item = function (b) {\n          return a[b];\n        };\n\n        return a;\n      },\n      configurable: !0\n    },\n    innerHTML: {\n      get: function () {\n        var a = \"template\" === this.localName ? this.content : this;\n        return v(this) ? E(a) : F.innerHTML(a);\n      },\n      set: function (a) {\n        for (var b = \"template\" === this.localName ? this.content : this; b.firstChild;) b.removeChild(b.firstChild);\n\n        var c = this.localName;\n        c && \"template\" !== c || (c = \"div\");\n        c = Ma.createElement(c);\n\n        for (J && J.set ? J.set.call(c, a) : c.innerHTML = a; c.firstChild;) b.appendChild(c.firstChild);\n      },\n      configurable: !0\n    }\n  },\n      Oa = {\n    shadowRoot: {\n      get: function () {\n        return this.__shady && this.__shady.S || null;\n      },\n      configurable: !0\n    }\n  },\n      M = {\n    activeElement: {\n      get: function () {\n        var a = K && K.get ? K.get.call(document) : t.h ? void 0 : document.activeElement;\n\n        if (a && a.nodeType) {\n          var b = !!w(this);\n\n          if (this === document || b && this.host !== a && I.contains.call(this.host, a)) {\n            for (b = x(a); b && b !== this;) a = b.host, b = x(a);\n\n            a = this === document ? b ? null : a : b === this ? a : null;\n          } else a = null;\n        } else a = null;\n\n        return a;\n      },\n      set: function () {},\n      configurable: !0\n    }\n  };\n\n  function N(a, b, c) {\n    for (var d in b) {\n      var e = Object.getOwnPropertyDescriptor(a, d);\n      e && e.configurable || !e && c ? Object.defineProperty(a, d, b[d]) : c && console.warn(\"Could not define\", d, \"on\", a);\n    }\n  }\n\n  function O(a) {\n    N(a, Na);\n    N(a, L);\n    N(a, M);\n  }\n\n  var Pa = t.h ? function () {} : function (a) {\n    a.__shady && a.__shady.L || (a.__shady = a.__shady || {}, a.__shady.L = !0, N(a, Na, !0));\n  },\n      Qa = t.h ? function () {} : function (a) {\n    a.__shady && a.__shady.J || (a.__shady = a.__shady || {}, a.__shady.J = !0, N(a, L, !0), N(a, Oa, !0));\n  };\n\n  function Ra(a, b, c) {\n    Pa(a);\n    c = c || null;\n    a.__shady = a.__shady || {};\n    b.__shady = b.__shady || {};\n    c && (c.__shady = c.__shady || {});\n    a.__shady.previousSibling = c ? c.__shady.previousSibling : b.lastChild;\n    var d = a.__shady.previousSibling;\n    d && d.__shady && (d.__shady.nextSibling = a);\n    (d = a.__shady.nextSibling = c) && d.__shady && (d.__shady.previousSibling = a);\n    a.__shady.parentNode = b;\n    c ? c === b.__shady.firstChild && (b.__shady.firstChild = a) : (b.__shady.lastChild = a, b.__shady.firstChild || (b.__shady.firstChild = a));\n    b.__shady.childNodes = null;\n  }\n\n  function P(a) {\n    if (!a.__shady || void 0 === a.__shady.firstChild) {\n      a.__shady = a.__shady || {};\n      a.__shady.firstChild = F.firstChild(a);\n      a.__shady.lastChild = F.lastChild(a);\n      Qa(a);\n\n      for (var b = a.__shady.childNodes = F.childNodes(a), c = 0, d; c < b.length && (d = b[c]); c++) d.__shady = d.__shady || {}, d.__shady.parentNode = a, d.__shady.nextSibling = b[c + 1] || null, d.__shady.previousSibling = b[c - 1] || null, Pa(d);\n    }\n  }\n\n  ;\n\n  function Q(a, b, c) {\n    if (b === a) throw Error(\"Failed to execute 'appendChild' on 'Node': The new child element contains the parent.\");\n\n    if (c) {\n      var d = c.__shady && c.__shady.parentNode;\n      if (void 0 !== d && d !== a || void 0 === d && F.parentNode(c) !== a) throw Error(\"Failed to execute 'insertBefore' on 'Node': The node before which the new node is to be inserted is not a child of this node.\");\n    }\n\n    if (c === b) return b;\n    b.parentNode && R(b.parentNode, b);\n    d = x(a);\n    var e;\n    if (e = d) a: {\n      if (!b.__noInsertionPoint) {\n        var f;\n        \"slot\" === b.localName ? f = [b] : b.querySelectorAll && (f = b.querySelectorAll(\"slot\"));\n\n        if (f && f.length) {\n          e = f;\n          break a;\n        }\n      }\n\n      e = void 0;\n    }\n    (f = e) && d.f.push.apply(d.f, [].concat(f instanceof Array ? f : ha(fa(f))));\n    d && (\"slot\" === a.localName || f) && S(d);\n\n    if (v(a)) {\n      d = c;\n      Qa(a);\n      a.__shady = a.__shady || {};\n      void 0 !== a.__shady.firstChild && (a.__shady.childNodes = null);\n\n      if (b.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n        f = b.childNodes;\n\n        for (e = 0; e < f.length; e++) Ra(f[e], a, d);\n\n        b.__shady = b.__shady || {};\n        d = void 0 !== b.__shady.firstChild ? null : void 0;\n        b.__shady.firstChild = b.__shady.lastChild = d;\n        b.__shady.childNodes = d;\n      } else Ra(b, a, d);\n\n      if (Sa(a)) {\n        S(a.__shady.root);\n        var h = !0;\n      } else a.__shady.root && (h = !0);\n    }\n\n    h || (h = w(a) ? a.host : a, c ? (c = Ta(c), I.insertBefore.call(h, b, c)) : I.appendChild.call(h, b));\n    Ua(a, b);\n    return b;\n  }\n\n  function R(a, b) {\n    if (b.parentNode !== a) throw Error(\"The node to be removed is not a child of this node: \" + b);\n    var c = x(b);\n\n    if (v(a)) {\n      b.__shady = b.__shady || {};\n      a.__shady = a.__shady || {};\n      b === a.__shady.firstChild && (a.__shady.firstChild = b.__shady.nextSibling);\n      b === a.__shady.lastChild && (a.__shady.lastChild = b.__shady.previousSibling);\n      var d = b.__shady.previousSibling,\n          e = b.__shady.nextSibling;\n      d && (d.__shady = d.__shady || {}, d.__shady.nextSibling = e);\n      e && (e.__shady = e.__shady || {}, e.__shady.previousSibling = d);\n      b.__shady.parentNode = b.__shady.previousSibling = b.__shady.nextSibling = void 0;\n      void 0 !== a.__shady.childNodes && (a.__shady.childNodes = null);\n\n      if (Sa(a)) {\n        S(a.__shady.root);\n        var f = !0;\n      }\n    }\n\n    Va(b);\n\n    if (c) {\n      (d = a && \"slot\" === a.localName) && (f = !0);\n      Wa(c);\n      e = c.a;\n\n      for (var h in e) for (var g = e[h], k = 0; k < g.length; k++) {\n        var l = g[k];\n\n        if (pa(b, l)) {\n          g.splice(k, 1);\n          var m = c.b.indexOf(l);\n          0 <= m && c.b.splice(m, 1);\n          k--;\n          if (m = l.__shady.g) for (l = 0; l < m.length; l++) {\n            var q = m[l],\n                z = F.parentNode(q);\n            z && I.removeChild.call(z, q);\n          }\n          m = !0;\n        }\n      }\n\n      (m || d) && S(c);\n    }\n\n    f || (f = w(a) ? a.host : a, (!a.__shady.root && \"slot\" !== b.localName || f === F.parentNode(b)) && I.removeChild.call(f, b));\n    Ua(a, null, b);\n    return b;\n  }\n\n  function Va(a) {\n    if (a.__shady && void 0 !== a.__shady.C) for (var b = a.childNodes, c = 0, d = b.length, e; c < d && (e = b[c]); c++) Va(e);\n    a.__shady && (a.__shady.C = void 0);\n  }\n\n  function Ta(a) {\n    var b = a;\n    a && \"slot\" === a.localName && (b = (b = a.__shady && a.__shady.g) && b.length ? b[0] : Ta(a.nextSibling));\n    return b;\n  }\n\n  function Sa(a) {\n    return (a = a && a.__shady && a.__shady.root) && Xa(a);\n  }\n\n  function Ya(a, b) {\n    if (\"slot\" === b) a = a.parentNode, Sa(a) && S(a.__shady.root);else if (\"slot\" === a.localName && \"name\" === b && (b = x(a))) {\n      var c = a.M,\n          d = Za(a);\n\n      if (d !== c) {\n        c = b.a[c];\n        var e = c.indexOf(a);\n        0 <= e && c.splice(e, 1);\n        c = b.a[d] || (b.a[d] = []);\n        c.push(a);\n        1 < c.length && (b.a[d] = $a(c));\n      }\n\n      S(b);\n    }\n  }\n\n  function Ua(a, b, c) {\n    if (a = a.__shady && a.__shady.i) b && a.addedNodes.push(b), c && a.removedNodes.push(c), ab(a);\n  }\n\n  function bb(a) {\n    if (a && a.nodeType) {\n      a.__shady = a.__shady || {};\n      var b = a.__shady.C;\n      void 0 === b && (w(a) ? b = a : b = (b = a.parentNode) ? bb(b) : a, I.contains.call(document.documentElement, a) && (a.__shady.C = b));\n      return b;\n    }\n  }\n\n  function T(a, b, c) {\n    var d = [];\n    cb(a.childNodes, b, c, d);\n    return d;\n  }\n\n  function cb(a, b, c, d) {\n    for (var e = 0, f = a.length, h; e < f && (h = a[e]); e++) {\n      var g;\n\n      if (g = h.nodeType === Node.ELEMENT_NODE) {\n        g = h;\n        var k = b,\n            l = c,\n            m = d,\n            q = k(g);\n        q && m.push(g);\n        l && l(q) ? g = q : (cb(g.childNodes, k, l, m), g = void 0);\n      }\n\n      if (g) break;\n    }\n  }\n\n  var U = null;\n\n  function db(a, b, c) {\n    U || (U = window.ShadyCSS && window.ShadyCSS.ScopingShim);\n    U && \"class\" === b ? U.setElementClass(a, c) : (I.setAttribute.call(a, b, c), Ya(a, b));\n  }\n\n  function eb(a, b) {\n    if (a.ownerDocument !== document) return I.importNode.call(document, a, b);\n    var c = I.importNode.call(document, a, !1);\n\n    if (b) {\n      a = a.childNodes;\n      b = 0;\n\n      for (var d; b < a.length; b++) d = eb(a[b], !0), c.appendChild(d);\n    }\n\n    return c;\n  }\n\n  ;\n  var V = [],\n      fb;\n\n  function gb(a) {\n    fb || (fb = !0, na(W));\n    V.push(a);\n  }\n\n  function W() {\n    fb = !1;\n\n    for (var a = !!V.length; V.length;) V.shift()();\n\n    return a;\n  }\n\n  W.list = V;\n  var hb = {};\n\n  function X(a, b, c) {\n    if (a !== hb) throw new TypeError(\"Illegal constructor\");\n    a = document.createDocumentFragment();\n    a.__proto__ = X.prototype;\n    a.K = \"ShadyRoot\";\n    P(b);\n    P(a);\n    a.host = b;\n    a.c = c && c.mode;\n    b.__shady = b.__shady || {};\n    b.__shady.root = a;\n    b.__shady.S = \"closed\" !== a.c ? a : null;\n    a.l = !1;\n    a.b = [];\n    a.a = {};\n    a.f = [];\n    c = F.childNodes(b);\n\n    for (var d = 0, e = c.length; d < e; d++) I.removeChild.call(b, c[d]);\n\n    return a;\n  }\n\n  X.prototype = Object.create(DocumentFragment.prototype);\n\n  function S(a) {\n    a.l || (a.l = !0, gb(function () {\n      return ib(a);\n    }));\n  }\n\n  function ib(a) {\n    for (var b; a;) {\n      a.l && (b = a);\n\n      a: {\n        var c = a;\n        a = c.host.getRootNode();\n        if (w(a)) for (var d = c.host.childNodes, e = 0; e < d.length; e++) if (c = d[e], \"slot\" == c.localName) break a;\n        a = void 0;\n      }\n    }\n\n    b && b._renderRoot();\n  }\n\n  X.prototype._renderRoot = function () {\n    this.l = !1;\n    Wa(this);\n\n    for (var a = 0, b; a < this.b.length; a++) {\n      b = this.b[a];\n      var c = b.__shady.assignedNodes;\n      b.__shady.assignedNodes = [];\n      b.__shady.g = [];\n      if (b.__shady.G = c) for (var d = 0; d < c.length; d++) {\n        var e = c[d];\n        e.__shady.A = e.__shady.assignedSlot;\n        e.__shady.assignedSlot === b && (e.__shady.assignedSlot = null);\n      }\n    }\n\n    for (b = this.host.firstChild; b; b = b.nextSibling) jb(this, b);\n\n    for (a = 0; a < this.b.length; a++) {\n      b = this.b[a];\n      if (!b.__shady.assignedNodes.length) for (c = b.firstChild; c; c = c.nextSibling) jb(this, c, b);\n      c = b.parentNode;\n      (c = c.__shady && c.__shady.root) && Xa(c) && c._renderRoot();\n      kb(this, b.__shady.g, b.__shady.assignedNodes);\n\n      if (c = b.__shady.G) {\n        for (d = 0; d < c.length; d++) c[d].__shady.A = null;\n\n        b.__shady.G = null;\n        c.length > b.__shady.assignedNodes.length && (b.__shady.B = !0);\n      }\n\n      b.__shady.B && (b.__shady.B = !1, lb(this, b));\n    }\n\n    a = this.b;\n    b = [];\n\n    for (c = 0; c < a.length; c++) d = a[c].parentNode, d.__shady && d.__shady.root || !(0 > b.indexOf(d)) || b.push(d);\n\n    for (a = 0; a < b.length; a++) {\n      c = b[a];\n      d = c === this ? this.host : c;\n      e = [];\n      c = c.childNodes;\n\n      for (var f = 0; f < c.length; f++) {\n        var h = c[f];\n\n        if (\"slot\" == h.localName) {\n          h = h.__shady.g;\n\n          for (var g = 0; g < h.length; g++) e.push(h[g]);\n        } else e.push(h);\n      }\n\n      c = void 0;\n      f = F.childNodes(d);\n      h = ia(e, e.length, f, f.length);\n\n      for (var k = g = 0; g < h.length && (c = h[g]); g++) {\n        for (var l = 0, m; l < c.j.length && (m = c.j[l]); l++) F.parentNode(m) === d && I.removeChild.call(d, m), f.splice(c.index + k, 1);\n\n        k -= c.m;\n      }\n\n      for (k = 0; k < h.length && (c = h[k]); k++) for (g = f[c.index], l = c.index; l < c.index + c.m; l++) m = e[l], I.insertBefore.call(d, m, g), f.splice(l, 0, m);\n    }\n  };\n\n  function jb(a, b, c) {\n    b.__shady = b.__shady || {};\n    var d = b.__shady.A;\n    b.__shady.A = null;\n    c || (c = (a = a.a[b.slot || \"__catchall\"]) && a[0]);\n    c ? (c.__shady.assignedNodes.push(b), b.__shady.assignedSlot = c) : b.__shady.assignedSlot = void 0;\n    d !== b.__shady.assignedSlot && b.__shady.assignedSlot && (b.__shady.assignedSlot.__shady.B = !0);\n  }\n\n  function kb(a, b, c) {\n    for (var d = 0, e; d < c.length && (e = c[d]); d++) if (\"slot\" == e.localName) {\n      var f = e.__shady.assignedNodes;\n      f && f.length && kb(a, b, f);\n    } else b.push(c[d]);\n  }\n\n  function lb(a, b) {\n    I.dispatchEvent.call(b, new Event(\"slotchange\"));\n    b.__shady.assignedSlot && lb(a, b.__shady.assignedSlot);\n  }\n\n  function Wa(a) {\n    if (a.f.length) {\n      for (var b = a.f, c, d = 0; d < b.length; d++) {\n        var e = b[d];\n        e.__shady = e.__shady || {};\n        P(e);\n        P(e.parentNode);\n        var f = Za(e);\n        a.a[f] ? (c = c || {}, c[f] = !0, a.a[f].push(e)) : a.a[f] = [e];\n        a.b.push(e);\n      }\n\n      if (c) for (var h in c) a.a[h] = $a(a.a[h]);\n      a.f = [];\n    }\n  }\n\n  function Za(a) {\n    var b = a.name || a.getAttribute(\"name\") || \"__catchall\";\n    return a.M = b;\n  }\n\n  function $a(a) {\n    return a.sort(function (a, c) {\n      a = mb(a);\n\n      for (var b = mb(c), e = 0; e < a.length; e++) {\n        c = a[e];\n        var f = b[e];\n        if (c !== f) return a = Array.from(c.parentNode.childNodes), a.indexOf(c) - a.indexOf(f);\n      }\n    });\n  }\n\n  function mb(a) {\n    var b = [];\n\n    do b.unshift(a); while (a = a.parentNode);\n\n    return b;\n  }\n\n  function Xa(a) {\n    Wa(a);\n    return !!a.b.length;\n  }\n\n  X.prototype.addEventListener = function (a, b, c) {\n    \"object\" !== typeof c && (c = {\n      capture: !!c\n    });\n    c.w = this;\n    this.host.addEventListener(a, b, c);\n  };\n\n  X.prototype.removeEventListener = function (a, b, c) {\n    \"object\" !== typeof c && (c = {\n      capture: !!c\n    });\n    c.w = this;\n    this.host.removeEventListener(a, b, c);\n  };\n\n  X.prototype.getElementById = function (a) {\n    return T(this, function (b) {\n      return b.id == a;\n    }, function (a) {\n      return !!a;\n    })[0] || null;\n  };\n\n  var nb = X.prototype;\n  N(nb, L, !0);\n  N(nb, M, !0);\n\n  function ob() {\n    this.c = !1;\n    this.addedNodes = [];\n    this.removedNodes = [];\n    this.o = new Set();\n  }\n\n  function ab(a) {\n    a.c || (a.c = !0, na(function () {\n      pb(a);\n    }));\n  }\n\n  function pb(a) {\n    if (a.c) {\n      a.c = !1;\n      var b = a.takeRecords();\n      b.length && a.o.forEach(function (a) {\n        a(b);\n      });\n    }\n  }\n\n  ob.prototype.takeRecords = function () {\n    if (this.addedNodes.length || this.removedNodes.length) {\n      var a = [{\n        addedNodes: this.addedNodes,\n        removedNodes: this.removedNodes\n      }];\n      this.addedNodes = [];\n      this.removedNodes = [];\n      return a;\n    }\n\n    return [];\n  };\n\n  function qb(a, b) {\n    a.__shady = a.__shady || {};\n    a.__shady.i || (a.__shady.i = new ob());\n\n    a.__shady.i.o.add(b);\n\n    var c = a.__shady.i;\n    return {\n      N: b,\n      P: c,\n      O: a,\n      takeRecords: function () {\n        return c.takeRecords();\n      }\n    };\n  }\n\n  function rb(a) {\n    var b = a && a.P;\n    b && (b.o.delete(a.N), b.o.size || (a.O.__shady.i = null));\n  }\n\n  function sb(a, b) {\n    var c = b.getRootNode();\n    return a.map(function (a) {\n      var b = c === a.target.getRootNode();\n\n      if (b && a.addedNodes) {\n        if (b = Array.from(a.addedNodes).filter(function (a) {\n          return c === a.getRootNode();\n        }), b.length) return a = Object.create(a), Object.defineProperty(a, \"addedNodes\", {\n          value: b,\n          configurable: !0\n        }), a;\n      } else if (b) return a;\n    }).filter(function (a) {\n      return a;\n    });\n  }\n\n  ;\n  var Y = \"__eventWrappers\" + Date.now(),\n      tb = {\n    blur: !0,\n    focus: !0,\n    focusin: !0,\n    focusout: !0,\n    click: !0,\n    dblclick: !0,\n    mousedown: !0,\n    mouseenter: !0,\n    mouseleave: !0,\n    mousemove: !0,\n    mouseout: !0,\n    mouseover: !0,\n    mouseup: !0,\n    wheel: !0,\n    beforeinput: !0,\n    input: !0,\n    keydown: !0,\n    keyup: !0,\n    compositionstart: !0,\n    compositionupdate: !0,\n    compositionend: !0,\n    touchstart: !0,\n    touchend: !0,\n    touchmove: !0,\n    touchcancel: !0,\n    pointerover: !0,\n    pointerenter: !0,\n    pointerdown: !0,\n    pointermove: !0,\n    pointerup: !0,\n    pointercancel: !0,\n    pointerout: !0,\n    pointerleave: !0,\n    gotpointercapture: !0,\n    lostpointercapture: !0,\n    dragstart: !0,\n    drag: !0,\n    dragenter: !0,\n    dragleave: !0,\n    dragover: !0,\n    drop: !0,\n    dragend: !0,\n    DOMActivate: !0,\n    DOMFocusIn: !0,\n    DOMFocusOut: !0,\n    keypress: !0\n  };\n\n  function ub(a, b) {\n    var c = [],\n        d = a;\n\n    for (a = a === window ? window : a.getRootNode(); d;) c.push(d), d = d.assignedSlot ? d.assignedSlot : d.nodeType === Node.DOCUMENT_FRAGMENT_NODE && d.host && (b || d !== a) ? d.host : d.parentNode;\n\n    c[c.length - 1] === document && c.push(window);\n    return c;\n  }\n\n  function vb(a, b) {\n    if (!w) return a;\n    a = ub(a, !0);\n\n    for (var c = 0, d, e, f, h; c < b.length; c++) if (d = b[c], f = d === window ? window : d.getRootNode(), f !== e && (h = a.indexOf(f), e = f), !w(f) || -1 < h) return d;\n  }\n\n  var wb = {\n    get composed() {\n      !1 !== this.isTrusted && void 0 === this.s && (this.s = tb[this.type]);\n      return this.s || !1;\n    },\n\n    composedPath: function () {\n      this.D || (this.D = ub(this.__target, this.composed));\n      return this.D;\n    },\n\n    get target() {\n      return vb(this.currentTarget, this.composedPath());\n    },\n\n    get relatedTarget() {\n      if (!this.v) return null;\n      this.F || (this.F = ub(this.v, !0));\n      return vb(this.currentTarget, this.F);\n    },\n\n    stopPropagation: function () {\n      Event.prototype.stopPropagation.call(this);\n      this.u = !0;\n    },\n    stopImmediatePropagation: function () {\n      Event.prototype.stopImmediatePropagation.call(this);\n      this.u = this.I = !0;\n    }\n  };\n\n  function xb(a) {\n    function b(b, d) {\n      b = new a(b, d);\n      b.s = d && !!d.composed;\n      return b;\n    }\n\n    la(b, a);\n    b.prototype = a.prototype;\n    return b;\n  }\n\n  var yb = {\n    focus: !0,\n    blur: !0\n  };\n\n  function zb(a) {\n    return a.__target !== a.target || a.v !== a.relatedTarget;\n  }\n\n  function Ab(a, b, c) {\n    if (c = b.__handlers && b.__handlers[a.type] && b.__handlers[a.type][c]) for (var d = 0, e; (e = c[d]) && (!zb(a) || a.target !== a.relatedTarget) && (e.call(b, a), !a.I); d++);\n  }\n\n  function Bb(a) {\n    var b = a.composedPath();\n    Object.defineProperty(a, \"currentTarget\", {\n      get: function () {\n        return d;\n      },\n      configurable: !0\n    });\n\n    for (var c = b.length - 1; 0 <= c; c--) {\n      var d = b[c];\n      Ab(a, d, \"capture\");\n      if (a.u) return;\n    }\n\n    Object.defineProperty(a, \"eventPhase\", {\n      get: function () {\n        return Event.AT_TARGET;\n      }\n    });\n    var e;\n\n    for (c = 0; c < b.length; c++) {\n      d = b[c];\n      var f = d.__shady && d.__shady.root;\n      if (0 === c || f && f === e) if (Ab(a, d, \"bubble\"), d !== window && (e = d.getRootNode()), a.u) break;\n    }\n  }\n\n  function Cb(a, b, c, d, e, f) {\n    for (var h = 0; h < a.length; h++) {\n      var g = a[h],\n          k = g.type,\n          l = g.capture,\n          m = g.once,\n          q = g.passive;\n      if (b === g.node && c === k && d === l && e === m && f === q) return h;\n    }\n\n    return -1;\n  }\n\n  function Db(a, b, c) {\n    if (b) {\n      var d = typeof b;\n      if (\"function\" === d || \"object\" === d) if (\"object\" !== d || b.handleEvent && \"function\" === typeof b.handleEvent) {\n        if (c && \"object\" === typeof c) {\n          var e = !!c.capture;\n          var f = !!c.once;\n          var h = !!c.passive;\n        } else e = !!c, h = f = !1;\n\n        var g = c && c.w || this,\n            k = b[Y];\n\n        if (k) {\n          if (-1 < Cb(k, g, a, e, f, h)) return;\n        } else b[Y] = [];\n\n        k = function (e) {\n          f && this.removeEventListener(a, b, c);\n          e.__target || Eb(e);\n\n          if (g !== this) {\n            var h = Object.getOwnPropertyDescriptor(e, \"currentTarget\");\n            Object.defineProperty(e, \"currentTarget\", {\n              get: function () {\n                return g;\n              },\n              configurable: !0\n            });\n          }\n\n          if (e.composed || -1 < e.composedPath().indexOf(g)) if (zb(e) && e.target === e.relatedTarget) e.eventPhase === Event.BUBBLING_PHASE && e.stopImmediatePropagation();else if (e.eventPhase === Event.CAPTURING_PHASE || e.bubbles || e.target === g || g instanceof Window) {\n            var k = \"function\" === d ? b.call(g, e) : b.handleEvent && b.handleEvent(e);\n            g !== this && (h ? (Object.defineProperty(e, \"currentTarget\", h), h = null) : delete e.currentTarget);\n            return k;\n          }\n        };\n\n        b[Y].push({\n          node: this,\n          type: a,\n          capture: e,\n          once: f,\n          passive: h,\n          V: k\n        });\n        yb[a] ? (this.__handlers = this.__handlers || {}, this.__handlers[a] = this.__handlers[a] || {\n          capture: [],\n          bubble: []\n        }, this.__handlers[a][e ? \"capture\" : \"bubble\"].push(k)) : (this instanceof Window ? I.T : I.addEventListener).call(this, a, k, c);\n      }\n    }\n  }\n\n  function Fb(a, b, c) {\n    if (b) {\n      if (c && \"object\" === typeof c) {\n        var d = !!c.capture;\n        var e = !!c.once;\n        var f = !!c.passive;\n      } else d = !!c, f = e = !1;\n\n      var h = c && c.w || this,\n          g = void 0;\n      var k = null;\n\n      try {\n        k = b[Y];\n      } catch (l) {}\n\n      k && (e = Cb(k, h, a, d, e, f), -1 < e && (g = k.splice(e, 1)[0].V, k.length || (b[Y] = void 0)));\n      (this instanceof Window ? I.U : I.removeEventListener).call(this, a, g || b, c);\n      g && yb[a] && this.__handlers && this.__handlers[a] && (a = this.__handlers[a][d ? \"capture\" : \"bubble\"], g = a.indexOf(g), -1 < g && a.splice(g, 1));\n    }\n  }\n\n  function Gb() {\n    for (var a in yb) window.addEventListener(a, function (a) {\n      a.__target || (Eb(a), Bb(a));\n    }, !0);\n  }\n\n  function Eb(a) {\n    a.__target = a.target;\n    a.v = a.relatedTarget;\n\n    if (t.h) {\n      var b = Object.getPrototypeOf(a);\n\n      if (!b.hasOwnProperty(\"__patchProto\")) {\n        var c = Object.create(b);\n        c.W = b;\n        A(c, wb);\n        b.__patchProto = c;\n      }\n\n      a.__proto__ = b.__patchProto;\n    } else A(a, wb);\n  }\n\n  var Hb = xb(window.Event),\n      Ib = xb(window.CustomEvent),\n      Jb = xb(window.MouseEvent);\n\n  function Kb(a) {\n    var b = a.getRootNode();\n    w(b) && ib(b);\n    return a.__shady && a.__shady.assignedSlot || null;\n  }\n\n  var Lb = {\n    addEventListener: Db.bind(window),\n    removeEventListener: Fb.bind(window)\n  },\n      Mb = {\n    addEventListener: Db,\n    removeEventListener: Fb,\n    appendChild: function (a) {\n      return Q(this, a);\n    },\n    insertBefore: function (a, b) {\n      return Q(this, a, b);\n    },\n    removeChild: function (a) {\n      return R(this, a);\n    },\n    replaceChild: function (a, b) {\n      Q(this, a, b);\n      R(this, b);\n      return a;\n    },\n    cloneNode: function (a) {\n      if (\"template\" == this.localName) var b = I.cloneNode.call(this, a);else if (b = I.cloneNode.call(this, !1), a) {\n        a = this.childNodes;\n\n        for (var c = 0, d; c < a.length; c++) d = a[c].cloneNode(!0), b.appendChild(d);\n      }\n      return b;\n    },\n    getRootNode: function () {\n      return bb(this);\n    },\n    contains: function (a) {\n      return pa(this, a);\n    },\n\n    get isConnected() {\n      var a = this.ownerDocument;\n      if (oa && I.contains.call(a, this) || a.documentElement && I.contains.call(a.documentElement, this)) return !0;\n\n      for (a = this; a && !(a instanceof Document);) a = a.parentNode || (a instanceof X ? a.host : void 0);\n\n      return !!(a && a instanceof Document);\n    },\n\n    dispatchEvent: function (a) {\n      W();\n      return I.dispatchEvent.call(this, a);\n    }\n  },\n      Nb = {\n    get assignedSlot() {\n      return Kb(this);\n    }\n\n  },\n      Ob = {\n    querySelector: function (a) {\n      return T(this, function (b) {\n        return ka.call(b, a);\n      }, function (a) {\n        return !!a;\n      })[0] || null;\n    },\n    querySelectorAll: function (a) {\n      return T(this, function (b) {\n        return ka.call(b, a);\n      });\n    }\n  },\n      Pb = {\n    assignedNodes: function (a) {\n      if (\"slot\" === this.localName) {\n        var b = this.getRootNode();\n        w(b) && ib(b);\n        return this.__shady ? (a && a.flatten ? this.__shady.g : this.__shady.assignedNodes) || [] : [];\n      }\n    }\n  },\n      Qb = B({\n    setAttribute: function (a, b) {\n      db(this, a, b);\n    },\n    removeAttribute: function (a) {\n      I.removeAttribute.call(this, a);\n      Ya(this, a);\n    },\n    attachShadow: function (a) {\n      if (!this) throw \"Must provide a host.\";\n      if (!a) throw \"Not enough arguments.\";\n      return new X(hb, this, a);\n    },\n\n    get slot() {\n      return this.getAttribute(\"slot\");\n    },\n\n    set slot(a) {\n      db(this, \"slot\", a);\n    },\n\n    get assignedSlot() {\n      return Kb(this);\n    }\n\n  }, Ob, Pb);\n  Object.defineProperties(Qb, Oa);\n  var Rb = B({\n    importNode: function (a, b) {\n      return eb(a, b);\n    },\n    getElementById: function (a) {\n      return T(this, function (b) {\n        return b.id == a;\n      }, function (a) {\n        return !!a;\n      })[0] || null;\n    }\n  }, Ob);\n  Object.defineProperties(Rb, {\n    _activeElement: M.activeElement\n  });\n  var Sb = HTMLElement.prototype.blur,\n      Tb = B({\n    blur: function () {\n      var a = this.__shady && this.__shady.root;\n      (a = a && a.activeElement) ? a.blur() : Sb.call(this);\n    }\n  });\n\n  function Z(a, b) {\n    for (var c = Object.getOwnPropertyNames(b), d = 0; d < c.length; d++) {\n      var e = c[d],\n          f = Object.getOwnPropertyDescriptor(b, e);\n      f.value ? a[e] = f.value : Object.defineProperty(a, e, f);\n    }\n  }\n\n  ;\n\n  if (t.H) {\n    window.ShadyDOM = {\n      inUse: t.H,\n      patch: function (a) {\n        return a;\n      },\n      isShadyRoot: w,\n      enqueue: gb,\n      flush: W,\n      settings: t,\n      filterMutations: sb,\n      observeChildren: qb,\n      unobserveChildren: rb,\n      nativeMethods: I,\n      nativeTree: F\n    };\n    window.Event = Hb;\n    window.CustomEvent = Ib;\n    window.MouseEvent = Jb;\n    Gb();\n    var Ub = window.customElements && window.customElements.nativeHTMLElement || HTMLElement;\n    Z(window.Node.prototype, Mb);\n    Z(window.Window.prototype, Lb);\n    Z(window.Text.prototype, Nb);\n    Z(window.DocumentFragment.prototype, Ob);\n    Z(window.Element.prototype, Qb);\n    Z(window.Document.prototype, Rb);\n    window.HTMLSlotElement && Z(window.HTMLSlotElement.prototype, Pb);\n    Z(Ub.prototype, Tb);\n    t.h && (O(window.Node.prototype), O(window.Text.prototype), O(window.DocumentFragment.prototype), O(window.Element.prototype), O(Ub.prototype), O(window.Document.prototype), window.HTMLSlotElement && O(window.HTMLSlotElement.prototype));\n    window.ShadowRoot = X;\n  }\n\n  ;\n}).call(this);","map":{"version":3,"sources":[" [synthetic:util/defineproperty] "," [synthetic:util/global] "," [synthetic:es6/symbol] "," [synthetic:es6/util/makeiterator] "," [synthetic:es6/util/arrayfromiterator] ","src/array-splice.js","src/utils.js","src/innerHTML.js","src/native-tree.js","src/native-methods.js","src/patch-accessors.js","src/logical-tree.js","src/logical-mutation.js","src/attach-shadow.js"," [synthetic:es6/util/arrayfromiterable] ","src/flush.js","src/observe-changes.js","src/patch-events.js","src/patch-builtins.js","src/shadydom.js"],"names":["$jscomp.global","$jscomp.SYMBOL_PREFIX","$jscomp.initSymbol","$jscomp.defineProperty","$jscomp.arrayIterator","$jscomp.initSymbolIterator","$jscomp.iteratorPrototype","newSplice","index","removed","addedCount","EDIT_LEAVE","EDIT_UPDATE","EDIT_ADD","EDIT_DELETE","rowCount","columnCount","distances","Array","i","j","currentValue","currentStart","previousValue","oldStart","north","west","length","current","edits","northWest","min","calcSplices","prefixCount","suffixCount","minLength","Math","currentEnd","oldEnd","old","splice","undefined","splices","oldIndex","index1","index2","count","equals","settings","window","attachShadow","getRootNode","desc","Object","Node","isTrackingLogicalChildNodes","node","isShadyRoot","obj","ownerShadyRootForNode","root","p","Element","matches","pd","extend","target","n$","n","extendAll","mixin","source","proto","patchProto","__proto__","twiddle","document","content","queue","observe","characterData","microtask","hasDocumentContains","contains","escapeAttrRegExp","escapeDataRegExp","escapeReplace","replace","makeSet","set","arr","voidElements","plaintextParents","tagName","s","attrs","attr","getInnerHTML","data","parentNode","Error","c$","callback","l","child","nodeWalker","NodeFilter","elementWalker","firstChild","lastChild","previousSibling","nextSibling","childNodes","nodes","parentElement","firstElementChild","lastElementChild","previousElementSibling","nextElementSibling","children","innerHTML","textContent","textWalker","appendChild","insertBefore","removeChild","setAttribute","removeAttribute","cloneNode","importNode","Document","addEventListener","removeEventListener","windowAddEventListener","Window","windowRemoveEventListener","dispatchEvent","querySelector","querySelectorAll","HTMLElement","nativeInnerHTMLDesc","inertDoc","nativeActiveElementDescriptor","hasDescriptors","active","host","nativeContains","activeRoot","OutsideAccessors","nativeTree","configurable","className","InsideAccessors","childNodes.item","childElementCount","tc","cn","c","text","children.item","containerName","htmlContainer","ShadowRootAccessor","shadowRoot","ActiveElementAccessor","activeElement","patchAccessorGroup","objDesc","descriptors","force","console","patchAccessors","patchOutsideElementAccessors","element","patchInsideElementAccessors","__shady","nodeType","linkNode","resetTo","ref_node","container","ps","ns","recordChildNodes","ownerRoot","slotsAdded","parent","_asyncRender","hasShadowRootWithSlot","preventNativeInsert","firstComposedNode","nativeMethods","scheduleObserver","slots","localName","removeOwnerShadyRoot","changeSlotContent","preventNativeRemove","composed","flattened","_hasInsertionPoint","distributeAttributeChange","observer","addedNode","removedNode","query","list","queryElements","elements","result","matcher","halter","_render","scopingShim","nc","ShadyRootConstructionToken","CATCHALL_NAME","ShadyRoot","token","options","DocumentFragment","__localName","_mode","mode","_renderPending","_slotList","_slotMap","__pendingSlots","ShadyRoot.prototype._asyncRender","renderRoot","ShadyRoot.prototype._render","_distribute","_compose","_validateSlots","slot","_distributeNodeToSlot","slotParent","slotParentRoot","_addAssignedToFlattenedNodes","prevAssignedNodes","oldSlot","ShadyRoot.prototype._addAssignedToFlattenedNodes","assigned","nestedAssigned","ShadyRoot.prototype._fireSlotChange","_fireSlotChange","composeList","targetNode","flattenedNodes","d","next","ShadyRoot.prototype._validateSlots","_mapSlots","name","_nameForSlot","slotNamesToSort","_sortSlots","ShadyRoot.prototype._nameForSlot","ShadyRoot.prototype._sortSlots","listA","ancestorList","listB","nA","nB","ancestors","map","x","didRemove","oldName","__slotName","ShadyRoot.prototype._hasInsertionPoint","ShadyRoot.prototype.addEventListener","optionsOrCapture","capture","prototype","ShadyRoot.prototype.removeEventListener","ShadyRoot.prototype.getElementById","$jscomp.arrayFromIterator","$jscomp.makeIterator","flushList","scheduled","enqueue","flush","didFlush","AsyncObserver","schedule","mutations","cb","addedNodes","removedNodes","observeChildren","_callback","_observer","_node","unobserveChildren","handle","filterMutations","targetRootNode","mutationInScope","mutation","value","eventWrappersName","Date","alwaysComposed","pathComposer","composedPath","startNode","startRoot","retarget","refNode","refNodePath","path","ancestor","lastRoot","rootIdx","eventMixin","relatedTarget","Event","__propagationStopped","mixinComposedFlag","klazz","event","Base","nonBubblingEventsToRetarget","hasRetargeted","fireHandlers","hs","fn","__immediatePropagationStopped","retargetNonBubblingEvent","e","get","lastFiredRoot","savedNode","savedType","savedCapture","savedOnce","savedPassive","savedListener","findListener","wrappers","type","once","passive","handlerType","fnOrObj","wrapperFn","patchEvent","ret","lastCurrentTargetDesc","call","idx","activateFocusEventOverrides","ev","PatchedEvent","PatchedCustomEvent","PatchedMouseEvent","getAssignedSlot","windowMixin","bind","nodeMixin","deep","isConnected","ownerDocument","textMixin","assignedSlot","fragmentMixin","slotMixin","elementMixin","documentMixin","nativeBlur","htmlElementMixin","shadowActive","patchBuiltin","nativeHTMLElement","inUse","ShadyDOM","patch"],"mappings":";;;;;;;;;;;AAoCA,MAAA,EAAA,GACI,cAAsB,OAAO,MAAA,CAA7B,gBAAA,GACA,MAAA,CADA,cAAA,GAEA,UAAQ,CAAR,EAAQ,CAAR,EAAQ,CAAR,EAAuC;AAOjC,IAAA,CAAJ,IAAc,KAAA,CAAd,SAAI,IAA6B,CAAjC,IAA2C,MAAA,CAA3C,SAAI,KACJ,CAAA,CADA,CACA,CAAA,GAAmB,CAAA,CARkB,KAOjC;AAVV,GAAA;AAAA,MCOAA,CAAAA,GAbS,eAAC,OAAD,MAAA,IAAiC,MAAjC,KAAA,IAAA,GAAA,IAAA,GAEH,eAAC,OAAD,MAAA,IAAA,QAAA,MAAA,GAAA,MAAA,GAW6B,IDPnC;;AETqB,WAAA,EAAA,GAAW;AAE9BE,IAAAA,EAAAA,GAAqB,YAAW,CAE3BF,CAFLE;;AAEKF,IAAAA,CAAAA,CAAL,MAAKA,KACHA,CAAAA,CADF,MACEA,GAL4B,EAIzBA;AAWP;;AAAA,MAAA,EAAA,GAAuD,YAAW;AAChE,QAAI,CAAA,GAAU,CAAd;AAMA,WAAA,UAAe,CAAf,EAAiC;AAC/B,aA9BoBC,oBA+BS,CAD7B,IAAA,EA9BoBA,IA+BmC,CAFxB,EAC/B;AAR8D,KAOhE;AAPoD,GAAC,EAAvD;;AAoB6B,WAAA,CAAA,GAAW;AACtCC,IAAAA,EAAAA;AACA,QAAI,CAAA,GAAiBF,CAAAA,CAAAA,MAAAA,CAAAA,QAArB;AACK,IAAA,CAAL,KACE,CADF,GACmBA,CAAAA,CAAAA,MAAAA,CADnB,QACmBA,GACbA,CAAAA,CAAAA,MAAAA,CAFN,UAEMA,CAFN,CAAK;AAKL,kBAAI,OAAO,KAAA,CAAA,SAAA,CAAX,CAAW,CAAX,IACEG,EAAAA,CACI,KAAA,CADJA,SAAAA,EAAAA,CAAAA,EACqC;AAC/B,MAAA,YAAA,EAAc,CADiB,CAAA;AAE/B,MAAA,QAAA,EAAU,CAFqB,CAAA;AAO/B,MAAA,KAAA,EAAO,YAAW;AAChB,eAAOC,EAAAA,CADS,IACTA,CAAP;AATRD;AACqC,KADrCA,CADF;;AAgBAE,IAAAA,CAAAA,GAA6B,YAAW,CAxBF,CAwBtCA;AAUsB;;AAAA,WAAA,EAAA,CAAQ,CAAR,EAAgB;AACtC,QAAI,CAAA,GAAQ,CAAZ;AACA,WAAOC,EAAAA,CAA0B,YAAW;AAC1C,aAAI,CAAJ,GAAY,CAAA,CAAZ,MAAI,GACK;AACL,QAAA,IAAA,EAAM,CADD,CAAA;AAEL,QAAA,KAAA,EAAO,CAAA,CAAM,CAHjB,EAGW;AAFF,OADL,GAMK;AAAC,QAAA,IAAA,EAAM,CAP0B;AAOjC,OANT;AAHoC,KAE/BA,CAAP;AAwB0B;;AAAA,WAAA,EAAA,CAAQ,CAAR,EAAe;AACzCD,IAAAA,CAAAA;AAEI,IAAA,CAAA,GAAW;AAAC,MAAA,IAAA,EAAD;AAAA,KAAX;;AAKJ,IAAA,CAAA,CAASL,CAAAA,CAAAA,MAAAA,CAAT,QAAA,CAAA,GAA8C,YAAW;AAAE,aAAF,IAAE;AAC3D,KADA;;AACA,WATyC,CASzC;ACrGqB;;AAAA,WAAA,EAAA,CAAQ,CAAR,EAAmB;AACxCK,IAAAA,CAAAA;AAGA,QAAI,CAAA,GAAqC,CAAD,CAAW,MAAA,CAAX,QAAA,CAAxC;AACA,WAAO,CAAA,GAAmB,CAAA,CAAA,IAAA,CAAnB,CAAmB,CAAnB,GACHD,EAAAA,CANoC,CAMpCA,CADJ;AALwC;;ACEd,WAAA,EAAA,CAAQ,CAAR,EAAmB;AAG7C,SAFA,IAAA,CAAA,EACI,CAAA,GAAM,EACV,EAAO,CAAC,CAAC,CAAD,GAAK,CAAA,CAAL,IAAK,EAAL,EAAR,IAAA,GACE,CAAA,CAAA,IAAA,CAAS,CAAA,CAAT,KAAA;;AAEF,WAN6C,CAM7C;AC5BFG;;AAAAA,WAASA,CAATA,CAAkB,CAAlBA,EAAkB,CAAlBA,EAA+C;AAC7C,WAAO;AACLC,MAAAA,KAAAA,EADK,CAAA;AAELC,MAAAA,CAAAA,EAFK,EAAA;AAGLC,MAAAA,CAAAA,EAJ2C;AACtC,KAAP;AAD6C;;AAqI/CsB,WAASA,EAATA,CAAoB,CAApBA,EAAoB,CAApBA,EAAoB,CAApBA,EAAoB,CAApBA,EAC6C;AAuGf,QAAA,CAAA,GAAA,CAAA;AAAA,QAA6B,CAAA,GAA7B,CAAA;AAAA,QAtGxBC,CAAAA,GAAc,CAsGU;AAAA,QArGxBC,CAAAA,GAAc,CAqGU;AAAA,QAlGxBC,CAAAA,GAAYC,IAAAA,CAAAA,GAAAA,CAASC,CAATD,GAAAA,CAAAA,EAAoCE,CAApCF,GAAAA,CAAAA,CAkGY;AAjG5B,QAAA,KAAA,CAAA,IAAA,KAAA,CAAA,EA2EgD,CAAA,EAAA;AAChD,WAASjB,CAAT,GAAA,CAAA,EAAgBA,CAAhB,GA3E2CgB,CA2E3C,EAAkChB,CAAlC,EAAA,EACE,IA5E2BS,CA4EfP,CAAZ,CAAYA,CA5EeO,KAASW,CA4EZhB,CAAxB,CAAwBA,CAAxB,EACE,MAAA,CAAA;;AACJ,MAAA,CAAA,GA9E2CY,CA8E3C;AA5EA;;AAAA,QAAIE,CAAJ,IAAkBT,CAAAA,CAAlB,MAAIS,IAAgCC,CAApC,IAA8CC,CAAAA,CAA9C,MAAA,EAAA;AAgFIK,MAAAA,CAAAA,GA/EyBhB,CA+EhBD,CAAAA,MAATiB;;AAGJ,WAFA,IAAIC,CAAAA,GAhFkCN,CAgFzBZ,CAAb,MAAA,EACImB,CAAAA,GAAQ,CACZ,EAAOA,CAAP,GAlF2CX,CAkF3C,GAlFuDF,CAkFhDa,IAAwBC,EAAAA,CAlFFnB,CAkFS,CAAQ,EAAfmB,CAAO,CAAPA,EAlFOR,CAkFmB,CAAI,EAA7D,CAAyD,CAA1BQ,CAA/B,GACED,CAAAA;;AAEF,MAAA,CAAA,GAtFA,CAsFA;AAnFAxB;;AAAAA,IAAAA,CAAAA,IAAgBW,CAAhBX;AACAE,IAAAA,CAAAA,IAAYS,CAAZT;AACAa,IAAAA,CAAAA,IAAcH,CAAdG;AACAC,IAAAA,CAAAA,IAAUJ,CAAVI;AAEA,QAAA,KAAID,CAAJ,GAAA,CAAA,IAAA,KAAsCC,CAAtC,GAAA,CAAA,EACE,OAAO,EAAP;;AAEF,QAAIhB,CAAJ,IAAA,CAAA,EAAgC;AAE9B,WADAkB,CACA,GADSjC,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CACT,EAAOiB,CAAP,GAAA,CAAA,GACEgB,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAoBD,CAAAA,CAAIf,CAAxBgB,EAAoBD,CAApBC;;AAEF,aAAO,CALuB,CAKvB,CAAP;AACK;;AAAA,QAAIhB,CAAJ,IAAA,CAAA,EACL,OAAO,CAAEjB,CAAAA,CAAAA,CAAAA,EAA4B8B,CAA5B9B,GAAF,CAAEA,CAAF,CAAP;AAG6Be,IAAAA,CAAAA,GAAAA,CAAAA;AACCE,IAAAA,CAAAA,GA1I5BT,CA0I4BS;AA1I5BT,IAAAA,CAAAA,GA0IsCuB,CA1ItCvB,GAAAA,CA0IsCuB,GA1IP,CAA/BvB;AACAC,IAAAA,CAAAA,GAwIyCqB,CAxIzCrB,GAAAA,CAwIyCqB,GAxIC,CAA1CrB;AACAC,IAAAA,CAAAA,GAAgBC,KAAJ,CAAA,CAAA,CAAZD;;AAGJ,SAASE,CAAT,GAAA,CAAA,EAAgBA,CAAhB,GAAA,CAAA,EAA8BA,CAA9B,EAAA,EACEF,CAAAA,CAAAA,CAAAA,CAAAA,GAAmBC,KAAJ,CAAA,CAAA,CAAfD,EACA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,IAAkBE,CADlBF;;AAKF,SAASG,CAAT,GAAA,CAAA,EAAgBA,CAAhB,GAAA,CAAA,EAAiCA,CAAjC,EAAA,EACEH,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAkBG,CAAlBH;;AAEF,SAASE,CAAT,GAAA,CAAA,EAAgBA,CAAhB,GAAA,CAAA,EAA8BA,CAA9B,EAAA,EACE,KAASC,CAAT,GAAA,CAAA,EAAgBA,CAAhB,GAAA,CAAA,EAAiCA,CAAjC,EAAA,EACE,IAyHkBQ,CAzHPP,CAAQC,CAARD,GAAAA,CAAQC,GAAnB,CAAWD,CAyHOO,KACKW,CA1HmBhB,CAAIC,CAAJD,GAAAA,CAAIC,GAA9C,CAA0CD,CAA1C,EACEN,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAkBA,CAAAA,CAAUE,CAAVF,GAAAA,CAAAA,CAAAA,CAAiBG,CAAjBH,GADpB,CACoBA,CAAlBA,CADF,KAEK;AACH,UAAIQ,CAAAA,GAAQR,CAAAA,CAAUE,CAAVF,GAAAA,CAAAA,CAAAA,CAARQ,CAAQR,IAAZ,CAAA;AAAA,UACIS,CAAAA,GAAOT,CAAAA,CAAAA,CAAAA,CAAAA,CAAaG,CAAbH,GAAPS,CAAOT,IAAsB,CADjC;AAEAA,MAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAkBQ,CAAAA,GAAAA,CAAAA,GAAAA,CAAAA,GAHf,CAGHR;AAYFE;;AAAAA,IAAAA,CAAAA,GAPGF,CAOCU,CAAJR,MAPGF,GAOoB,CAAvBE;AACAC,IAAAA,CAAAA,GARGH,CAQC,CAAA,CAAA,CARDA,CAQHG,MARGH,GAQuB,CAA1BG;AACAQ,IAAAA,CAAAA,GATGX,CASO,CAAA,CAAA,CATPA,CASO,CATPA,CASHW;;AAEJ,SADIC,CACJ,GADY,EACZ,EAAA,IAAA,CAAA,IAAA,IAAA,CAAA,GACE,KAAA,CAAA,IACEA,CAAAA,CAAAA,IAAAA,CAxDWhB,CAwDXgB,GACA,CAFF,EAAA,IAKA,KAAA,CAAA,IACEA,CAAAA,CAAAA,IAAAA,CA5Dcf,CA4Dde,GACA,CAFF,EAAA,KAKIC,CAUJ,GAhCKb,CAsBW,CAAUE,CAAV,GAAA,CAAA,CAtBXF,CAsB4BG,CAAjB,GAAA,CAtBXH,CAsBDa,EACAJ,CASJ,GAhCKT,CAuBM,CAAUE,CAAV,GAAA,CAAA,CAvBNF,CAuBM,CAvBNA,CAsBDa,EAEAL,CAQJ,GAhCKR,CAwBO,CAAA,CAAA,CAxBPA,CAwBoBG,CAAb,GAAA,CAxBPH,CAsBDa,EAMFC,CAIF,GALIL,CAAJ,GAAA,CAAIA,GACIA,CAAAA,GAAAA,CAAAA,GAAAA,CAAAA,GADR,CAAIA,GAGID,CAAAA,GAAAA,CAAAA,GAAAA,CAAAA,GAA4BK,CARhCA,EAUAC,CAAJ,IAAA,CAAIA,IACED,CAAJ,IAAA,CAAIA,GACFD,CAAAA,CAAAA,IAAAA,CA/EWlB,CA+EXkB,CADEC,IAGFD,CAAAA,CAAAA,IAAAA,CAhFYjB,CAgFZiB,GACA,CAAA,GAJF,CAAIC,GAMJX,CAAAA,EANIW,EAOJ,CARF,EAAIC,IASOA,CAAJ,IAAA,CAAIA,IACTF,CAAAA,CAAAA,IAAAA,CApFcf,CAoFde,GACAV,CAAAA,EADAU,EAEA,CAAA,GAHK,CAAIE,KAKTF,CAAAA,CAAAA,IAAAA,CAzFWhB,CAyFXgB,GACAT,CAAAA,EADAS,EAEA,CAAA,GA/BF,CAwBWE,CAxBX,CALA;;AAwCFF,IAAAA,CAAAA,CAAAA,OAAAA;AA8DAW,IAAAA,CAAAA,GAASC,KAAAA,CAATD;AACIE,IAAAA,CAAAA,GAAU,EAAVA;;AAGJ,SAASvB,CAAT,GAAA,CAAA,EAAgBA,CAAhB,GAjEOU,CAiEaF,CAApB,MAAA,EAAgCR,CAAhC,EAAA,EACE,QAlEKU,CAkEE,CAAP,CAAO,CAAP;AACE,WArKalB,CAqKb;AACM6B,QAAAA,CAAJ,KACEE,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,GACA,CAAA,GAASD,KAFX,CAAA,CAAID;AAKJhC,QAAAA,CAAAA;AACAmC,QAAAA,CAAAA;AACA;;AACF,WA7Kc/B,CA6Kd;AACO4B,QAAAA,CAAL,KACEA,CADF,GACWjC,CAAAA,CAAAA,CAAAA,EADX,CACWA,CADX,CAAKiC;AAGLA,QAAAA,CAAAA,CAAAA,CAAAA;AACAhC,QAAAA,CAAAA;AAEAgC,QAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAoBD,CAAAA,CAApBC,CAAoBD,CAApBC;AACAG,QAAAA,CAAAA;AACA;;AACF,WAtLW9B,CAsLX;AACO2B,QAAAA,CAAL,KACEA,CADF,GACWjC,CAAAA,CAAAA,CAAAA,EADX,CACWA,CADX,CAAKiC;SAGL9B,CAAAA,C;AACAF,QAAAA,CAAAA;AACA;;AACF,WA5LcM,CA4Ld;AACO0B,QAAAA,CAIL,KAHEA,CAGF,GAHWjC,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAGX,CAJKiC,EAGLA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAoBD,CAAAA,CAApBC,CAAoBD,CAApBC,CAHKA,EAIL,CAhCJ,EA4BSA;AA5BT;;AAqCEA,IAAAA,CAAJ,IACEE,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CADEF;AAGJ,WA9E2C,CA8E3C;AAoBFO;;AAAAA,WAASA,EAATA,CAAe,CAAfA,EAAe,CAAfA,EAA6C;AAC3C,WAAO1B,CAAP,KAD2C,CAC3C;;;;ACzOK,MAAI2B,CAAAA,GAAWC,MAAAA,CAAXD,QAAWC,IAAsB,EAArC;AAEPD,EAAAA,CAAAA,CAAAA,CAAAA,GAA8B,EAAQE,CAAAA,OAAAA,CAAAA,SAAAA,CAAR,YAAQA,IAAkCC,CAAAA,IAAAA,CAAAA,SAAAA,CAA1C,WAAA,CAA9BH;AAEA,MAAII,CAAAA,GAAOC,MAAAA,CAAAA,wBAAAA,CAAgCC,IAAAA,CAAhCD,SAAAA,EAAAA,YAAAA,CAAX;AAEAL,EAAAA,CAAAA,CAAAA,CAAAA,GAA0B,CAAA,EAAQI,CAAR,IAAgBA,CAAAA,CAAhB,YAAQA,IAA6BA,CAAAA,CAArC,GAAA,CAA1BJ;AACAA,EAAAA,CAAAA,CAAAA,CAAAA,GAAiBA,CAAAA,CAAjBA,KAAiBA,IAAqB,CAACA,CAAAA,CAAAA,CAAvCA;;AAEOO,WAASA,CAATA,CAAoC,CAApCA,EAA2C;AAChD,WAAQC,CAAAA,CAAR,OAAQA,IAA4Cf,KAApD,CAAoDA,KAA5Be,CAAAA,CAAAA,OAAAA,CADwB,UAChD;AAGKC;;AAAAA,WAASA,CAATA,CAAoB,CAApBA,EAA0B;AAC/B,WAAA,gBAAeC,CAAAA,CADgB,CAC/B;AAGKC;;AAAAA,WAASA,CAATA,CAA8B,CAA9BA,EAAqC;AACtCC,IAAAA,CAAAA,GAAOJ,CAAAA,CAAAA,WAAAA,EAAPI;AACJ,QAAIH,CAAAA,CAAJ,CAAIA,CAAJ,EACE,OAHwC,CAGxC;AAIJ;;AAAA,MAAII,CAAAA,GAAIC,OAAAA,CAAR,SAAA;AAAA,MACIC,EAAAA,GAAUF,CAAAA,CAAVE,OAAUF,IAAaA,CAAAA,CAAvBE,eAAUF,IACZA,CAAAA,CADEE,kBAAUF,IACYA,CAAAA,CADtBE,iBAAUF,IAEZA,CAAAA,CAFEE,gBAAUF,IAEUA,CAAAA,CAAAA,qBAHxB;;AAgBgBI,WAAAA,CAAAA,CAAM,CAANA,EAAM,CAANA,EAAuB;AACrC,QAAIC,CAAJ,IAAA,CAAA,EAEE,KADA,IAAIC,CAAAA,GAAKd,MAAAA,CAAAA,mBAAAA,CAAT,CAASA,CAAT,EACSlC,CAAAA,GADT,CAAA,EACA,CAAA,EAAkBA,CAAlB,GAAoBgD,CAAAA,CAApB,MAAkBhD,KAAiBiD,CAAnC,GAAqCD,CAAAA,CAArC,CAAqCA,CAAnBhD,CAAlB,EAA6CA,CAA7C,EAAA,EAAkD;AATpD,UAAI6C,CAAAA,GAAKX,MAAAA,CAAAA,wBAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAT;AACIW,MAAAA,CAAJ,IACEX,MAAAA,CAAAA,cAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,CADEW;AAKiC;AAUhCK;;AAAAA,WAASA,CAATA,CAAkB,CAAlBA,EAAkB,CAAlBA,EAAuC;AAAZ,SAAA,IAAA,CAAA,GAAA,EAAA,EAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,MAAA,EAAA,EAAA,CAAA,EAAA,CAAA,CAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA,CAAA,CAAA,CAAA;;AAChC,SAASlD,CAAT,GAAA,CAAA,EAAcA,CAAd,GAD4C,CAC1BQ,CAAlB,MAAA,EAAkCR,CAAlC,EAAA,EACE8C,CAAAA,CAAAA,CAAAA,EAF0C,CAE3B,CAAfA,CAAe,CAAfA,CAAAA;;AAEF,WAJ4C,CAI5C;AAGKK;;AAAAA,WAASA,EAATA,CAAc,CAAdA,EAAc,CAAdA,EAA+B;AACpC,SAAKnD,IAAL,CAAA,IAAA,CAAA,EACE+C,CAAAA,CAAAA,CAAAA,CAAAA,GAAYK,CAAAA,CAFsB,CAEtBA,CAAZL;AAkBJ;;AAAA,MAAIS,CAAAA,GAAUC,QAAAA,CAAAA,cAAAA,CAAd,EAAcA,CAAd;AAAA,MACIC,EAAAA,GADJ,CAAA;AAAA,MAEIC,CAAAA,GAAQ,EAFZ;AAGAC,MAAAA,gBAAAA,CAAqB,YAAM;AACzB,WAAOD,CAAAA,CAAP,MAAA,GAEE,IAAI;AACFA,MAAAA,CAAAA,CADE,KACFA;AACA,KAFF,CAEE,OAAA,CAAA,EAAS;AAETH,YAAAA,CAAAA,CAAAA,WAAAA,GAAsBE,EAAAA,EAAtBF,EAFS,CAETA;AAPqB;AAA3BI,GAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,EAWoB;AAACC,IAAAA,aAAAA,EAAe,CAXpCD;AAWoB,GAXpBA;;AAcgBE,WAAAA,EAAAA,CAAS,CAATA,EAAoB;AAClCH,IAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA;AACAH,IAAAA,CAAAA,CAAAA,WAAAA,GAAsBE,EAFY,EAElCF;AAGK;;AAAA,MAAMO,EAAAA,GAAsB,CAAA,CAAQN,QAAAA,CAAAA,QAApC;;AAEAO,WAASA,EAATA,CAAiB,CAAjBA,EAAiB,CAAjBA,EAAmC;AACxC,WAAA,CAAA,GAAa;AACX,UAAI3B,CAAJ,IAAA,CAAA,EACE,OAAO,CAAA,CAAP;AAEFA,MAAAA,CAAAA,GAAOA,CAAAA,CAJI,UAIXA;AAEF;;AAAA,WAAO,CAPiC,CAOxC;;;;ACtGF,MAAI4B,EAAAA,GAAJ,aAAA;AAAA,MACIC,EAAAA,GAAmB,cADvB;;AAGAC,WAASA,EAATA,CAAsB,CAAtBA,EAA0B;AACxB,YAAA,CAAA;AACE,WAAA,GAAA;AACE,eAAO,OAAP;;AACF,WAAA,GAAA;AACE,eAAO,MAAP;;AACF,WAAA,GAAA;AACE,eAAO,MAAP;;AACF,WAAA,GAAA;AACE,eAAO,QAAP;;AACF,WAAA,QAAA;AACE,eAXoB,QAWpB;AAVJ;AAsBFE;;AAAAA,WAASA,EAATA,CAAgB,CAAhBA,EAAsB;AAEpB,SADA,IAAIC,CAAAA,GAAJ,EAAA,EACStE,CAAAA,GAAT,CAAA,EAAgBA,CAAhB,GAAoBuE,CAAAA,CAApB,MAAA,EAAgCvE,CAAhC,EAAA,EACEsE,CAAAA,CAAIC,CAAAA,CAAJD,CAAIC,CAAJD,CAAAA,GAAc,CAAA,CAAdA;;AAEF,WALoB,CAKpB;AAIF;;AAAA,MAAIE,EAAAA,GAAeH,EAAAA,CAAQ,sFAAA,KAAA,CAA3B,GAA2B,CAARA,CAAnB;AAAA,MAmBII,EAAAA,GAAmBJ,EAAAA,CAAQ,8DAAA,KAAA,CAARA,GAAQ,CAARA,CAnBvB;;AAuEgBS,WAAAA,CAAAA,CAAY,CAAZA,EAAY,CAAZA,EAA6B;AAC3C,mBAAIzC,CAAAA,CAAJ,SAAA,KACEA,CADF,GAC8CA,CAADqB,CAD7C,OAAA;;AAKA,SAFA,IAAIiB,CAAAA,GAAJ,EAAA,EACIO,CAAAA,GAAKC,CAAAA,GAAWA,CAAAA,CAAXA,CAAWA,CAAXA,GAA4B9C,CAAAA,CADrC,UAAA,EAESrC,CAAAA,GAFT,CAAA,EAEcoF,CAAAA,GAAEF,CAAAA,CAFhB,MAAA,EAEA,CAAA,EAAmClF,CAAnC,GAAA,CAAmCA,KAASqF,CAA5C,GAAkDH,CAAAA,CAAlD,CAAkDA,CAAflF,CAAnC,EAA0DA,CAA1D,EAAA,EAA+D;AA1CR,MAAA,CAAA,EAAA;AA2CnCqF,YAAAA,CAAAA,GAAAA,CAAAA;AAAOhD,YAAAA,CAAAA,GAAAA,CAAAA;AAAM8C,YAAAA,CAAAA,GA1CjC,CA0CiCA;;AA1CjC,gBAAQ9C,CAAAA,CAAR,QAAA;AACE,eAAKF,IAAAA,CAAL,YAAA;AAIE,iBAHA,IAAIuC,CAAAA,GAAUrC,CAAAA,CAAd,SAAA,EACIsC,CAAAA,GAAAA,MADJ,CAAA,EAEIC,CAAAA,GAAQvC,CAAAA,CAFZ,UAAA,EAGSrC,EAAAA,GAAT,CAAA,EAAuB6E,CAAvB,GAA8BD,CAAAA,CAA9B,EAA8BA,CAA9B,EAAyC5E,EAAzC,EAAA,EACE2E,CAAAA,IAAAA,MAAWE,CAAAA,CAAXF,IAAAA,GAAAA,IAAAA,GAAyCE,CAAAA,CA1DxCT,KA0DwCS,CA1DxCT,OA0DwCS,CA1DxCT,EA0DwCS,EA1DxCT,EA0DwCS,CAAzCF,GAAuD,GAAvDA;;AAEFA,YAAAA,CAAAA,IAAK,GAALA;AACA,YAAA,CAAA,GAAIH,EAAAA,CAAJ,CAAIA,CAAAA,GAAJ,CAAIA,GAGGG,CAHP,GAGWG,CAAAA,CAAAA,CAAAA,EAHX,CAGWA,CAAJH,GAHP,IAGOA,GAHP,CAGOA,GAHP,GAAA;AAAA,kBAAA,CAAA;;AAKF,eAAKxC,IAAAA,CAAL,SAAA;AACM4C,YAAAA,CAAAA,GAA4B1C,CAAD0C,CAAAA,IAA3BA;AACJ,YAAA,CAAA,GAAIC,CAAJ,IAAkBP,EAAAA,CAAiBO,CAAAA,CAAnC,SAAkBP,CAAdO,GAAJ,CAAIA,GAGcD,CAnEfX,CAAAA,OAmEeW,CAnEfX,EAmEeW,EAnEfX,EAmEeW,CAHlB;AAAA,kBAAA,CAAA;;AAKF,eAAK5C,IAAAA,CAAL,YAAA;AACE,YAAA,CAAA,GAAA,YAAwCE,CAAD0C,CAAvC,IAAA,GAAA,QAAA;AAAA,kBAAA,CAAA;;AAEF;AACEjD,kBAAAA,MAAAA,CAAAA,OAAAA,CAAAA,KAAAA,CAAAA,CAAAA,GACUmD,KAAJ,CA3B6C,iBA2B7C,CADNnD;AAzBJ;AA0CE6C;;AAAAA,MAAAA,CAAAA,IAD6D,CAC7DA;AAEF;;AAAA,WAT2C,CAS3C;;;;ACzHD,MAAA,CAAA,GAAA,EAAA;AAAA,MAEGW,CAAAA,GAAa7B,QAAAA,CAAAA,gBAAAA,CAAAA,QAAAA,EAAoC8B,UAAAA,CAApC9B,QAAAA,EAAAA,IAAAA,EACT,CAHP,CAEgBA,CAFhB;AAAA,MAKG+B,CAAAA,GAAgB/B,QAAAA,CAAAA,gBAAAA,CAAAA,QAAAA,EAAoC8B,UAAAA,CAApC9B,YAAAA,EAAAA,IAAAA,EACZ,CADYA,CAAAA,CALnB;;AAiCMoC,WAASA,EAATA,CAAmB,CAAnBA,EAA0B;AAC/B,QAAIC,CAAAA,GAAQ,EAAZ;AACAR,IAAAA,CAAAA,CAAAA,WAAAA,GAAyBjD,CAAzBiD;;AAEA,SADIrC,CACJ,GADQqC,CAAAA,CAAAA,UAAAA,EACR,EAAA,CAAA,GACEQ,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,GACA,CAAA,GAAIR,CAAAA,CAAAA,WAAAA,EADJQ;;AAGF,WAR+B,CAQ/B;AAjCcd;;AAAAA,EAAAA,CAAAA,CAAAA,UAAAA,GAATA,UAAmB,CAAnBA,EAA0B;AAC/BM,IAAAA,CAAAA,CAAAA,WAAAA,GAAyBjD,CAAzBiD;AACA,WAAOA,CAAAA,CAFwB,UAExBA,EAAP;AAGcG,GALAT;;AAKAS,EAAAA,CAAAA,CAAAA,UAAAA,GAATA,UAAmB,CAAnBA,EAA0B;AAC/BH,IAAAA,CAAAA,CAAAA,WAAAA,GAAyBjD,CAAzBiD;AACA,WAAOA,CAAAA,CAFwB,UAExBA,EAAP;AAGcI,GALAD;;AAKAC,EAAAA,CAAAA,CAAAA,SAAAA,GAATA,UAAkB,CAAlBA,EAAyB;AAC9BJ,IAAAA,CAAAA,CAAAA,WAAAA,GAAyBjD,CAAzBiD;AACA,WAAOA,CAAAA,CAFuB,SAEvBA,EAAP;AAGcK,GALAD;;AAKAC,EAAAA,CAAAA,CAAAA,eAAAA,GAATA,UAAwB,CAAxBA,EAA+B;AACpCL,IAAAA,CAAAA,CAAAA,WAAAA,GAAyBjD,CAAzBiD;AACA,WAAOA,CAAAA,CAF6B,eAE7BA,EAAP;AAGcM,GALAD;;GAKAC,CAAAA,W,GAATA,UAAoB,CAApBA,EAA2B;AAChCN,IAAAA,CAAAA,CAAAA,WAAAA,GAAyBjD,CAAzBiD;AACA,WAAOA,CAAAA,CAFyB,WAEzBA,EAAP;AAGcO,G;;AAAAA,EAAAA,CAAAA,CAAAA,UAAAA,GAAAA,EAAAA;;AAWAE,EAAAA,CAAAA,CAAAA,aAAAA,GAATA,UAAsB,CAAtBA,EAA6B;AAClCP,IAAAA,CAAAA,CAAAA,WAAAA,GAA4BnD,CAA5BmD;AACA,WAAOA,CAAAA,CAF2B,UAE3BA,EAAP;AAGcQ,GALAD;;AAKAC,EAAAA,CAAAA,CAAAA,iBAAAA,GAATA,UAA0B,CAA1BA,EAAiC;AACtCR,IAAAA,CAAAA,CAAAA,WAAAA,GAA4BnD,CAA5BmD;AACA,WAAOA,CAAAA,CAF+B,UAE/BA,EAAP;AAGcS,GALAD;;AAKAC,EAAAA,CAAAA,CAAAA,gBAAAA,GAATA,UAAyB,CAAzBA,EAAgC;AACrCT,IAAAA,CAAAA,CAAAA,WAAAA,GAA4BnD,CAA5BmD;AACA,WAAOA,CAAAA,CAF8B,SAE9BA,EAAP;AAGcU,GALAD;;AAKAC,EAAAA,CAAAA,CAAAA,sBAAAA,GAATA,UAA+B,CAA/BA,EAAsC;AAC3CV,IAAAA,CAAAA,CAAAA,WAAAA,GAA4BnD,CAA5BmD;AACA,WAAOA,CAAAA,CAFoC,eAEpCA,EAAP;AAGcW,GALAD;;AAKAC,EAAAA,CAAAA,CAAAA,kBAAAA,GAATA,UAA2B,CAA3BA,EAAkC;AACvCX,IAAAA,CAAAA,CAAAA,WAAAA,GAA4BnD,CAA5BmD;AACA,WAAOA,CAAAA,CAFgC,WAEhCA,EAAP;AAGcY,GALAD;;GAKAC,CAAAA,Q,GAATA,UAAiB,CAAjBA,EAAwB;AAC7B,QAAIN,CAAAA,GAAQ,EAAZ;AACAN,IAAAA,CAAAA,CAAAA,WAAAA,GAA4BnD,CAA5BmD;;AAEA,SADIvC,CACJ,GADQuC,CAAAA,CAAAA,UAAAA,EACR,EAAA,CAAA,GACEM,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,GACA,CAAA,GAAIN,CAAAA,CAAAA,WAAAA,EADJM;;AAGF,WAR6B,CAQ7B;AAGcO,G;;AAAAA,EAAAA,CAAAA,CAAAA,SAAAA,GAATA,UAAkB,CAAlBA,EAAyB;ADgChBvB,WAAAA,CC/BP,CAAA,CAAA,EAAmB,UAAA,CAAA,EAAO;AAAA,aAAA,EAAA,CAAA,CAAA,CAAA;AADH,KACvB,CD+BOA;AC5BAwB,GAJAD;;AAIAC,EAAAA,CAAAA,CAAAA,WAAAA,GAATA,UAAoB,CAApBA,EAA2B;AAChC,YAAQjE,CAAAA,CAAR,QAAA;AACE,WAAKF,IAAAA,CAAL,YAAA;AACA,WAAKA,IAAAA,CAAL,sBAAA;AACMoE,QAAAA,CAAAA,GAAa9C,QAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,EAAgC8B,UAAAA,CAAhC9B,SAAAA,EAAAA,IAAAA,EACT,CADSA,CAAAA,CAAb8C;;AAGJ,aAJF,IAGM7C,CAAAA,GAHN,EAAA,EAGoBT,CAClB,EAASA,CAAT,GAAasD,CAAAA,CAAb,QAAaA,EAAb,GAGE7C,CAAAA,IAAWT,CAAAA,CAAAA,SAAXS;;AAEF,eAAOA,CAAP;;AACF;AACE,eAAOrB,CAAAA,CAdqB,SAc5B;AAbJ;GADciE;;ACpFf,MAAA,CAAA,GAAA,EAAA;AAAA,MACUG,EAAAA,GAAe9D,OAAAA,CAAAA,SAAAA,CADzB,YAAA;AAAA,MAEU+D,EAAAA,GAAc/D,OAAAA,CAAAA,SAAAA,CAFxB,WAAA;AAAA,MAGUgE,EAAAA,GAAehE,OAAAA,CAAAA,SAAAA,CAHzB,YAAA;AAAA,MAIUiE,EAAAA,GAAkBjE,OAAAA,CAAAA,SAAAA,CAJ5B,eAAA;AAAA,MAKUkE,EAAAA,GAAYlE,OAAAA,CAAAA,SAAAA,CALtB,SAAA;AAAA,MAMUmE,EAAAA,GAAaC,QAAAA,CAAAA,SAAAA,CANvB,UAAA;AAAA,MAOUC,EAAAA,GAAmBrE,OAAAA,CAAAA,SAAAA,CAP7B,gBAAA;AAAA,MAQUsE,EAAAA,GAAsBtE,OAAAA,CAAAA,SAAAA,CARhC,mBAAA;AAAA,MASUuE,EAAAA,GAAyBC,MAAAA,CAAAA,SAAAA,CATnC,gBAAA;AAAA,MAUUC,EAAAA,GAA4BD,MAAAA,CAAAA,SAAAA,CAVtC,mBAAA;AAAA,MAWUE,EAAAA,GAAgB1E,OAAAA,CAAAA,SAAAA,CAX1B,aAAA;AAAA,MAYU2E,EAAAA,GAAgB3E,OAAAA,CAAAA,SAAAA,CAZ1B,aAAA;AAAA,MAaU4E,EAAAA,GAAmB5E,OAAAA,CAAAA,SAAAA,CAb7B,gBAAA;AAAA,MAcUqB,EAAAA,GAAW7B,IAAAA,CAAAA,SAAAA,CAAX6B,QAAW7B,IAA2BqF,WAAAA,CAAAA,SAAAA,CAdtChB,QAAV;AAAUA,EAAAA,CAAAA,CAAAA,WAAAA,GAAc7D,OAAAA,CAAAA,SAAAA,CAAAA,WAAd6D;AACAC,EAAAA,CAAAA,CAAAA,YAAAA,GAAAA,EAAAA;AACAC,EAAAA,CAAAA,CAAAA,WAAAA,GAAAA,EAAAA;AACAC,EAAAA,CAAAA,CAAAA,YAAAA,GAAAA,EAAAA;AACAC,EAAAA,CAAAA,CAAAA,eAAAA,GAAAA,EAAAA;AACAC,EAAAA,CAAAA,CAAAA,SAAAA,GAAAA,EAAAA;AACAC,EAAAA,CAAAA,CAAAA,UAAAA,GAAAA,EAAAA;AACAE,EAAAA,CAAAA,CAAAA,gBAAAA,GAAAA,EAAAA;AACAC,EAAAA,CAAAA,CAAAA,mBAAAA,GAAAA,EAAAA;AACAC,EAAAA,CAAAA,CAAAA,CAAAA,GAAAA,EAAAA;AACAE,EAAAA,CAAAA,CAAAA,CAAAA,GAAAA,EAAAA;AACAC,EAAAA,CAAAA,CAAAA,aAAAA,GAAAA,EAAAA;AACAC,EAAAA,CAAAA,CAAAA,aAAAA,GAAAA,EAAAA;AACAC,EAAAA,CAAAA,CAAAA,gBAAAA,GAAAA,EAAAA;AACAvD,EAAAA,CAAAA,CAAAA,QAAAA,GAAAA,EAAAA;ACHX,MAAMyD,CAAAA,GACJvF,MAAAA,CAAAA,wBAAAA,CAAgCS,OAAAA,CAAhCT,SAAAA,EADIuF,WACJvF,KACAA,MAAAA,CAAAA,wBAAAA,CAAgCsF,WAAAA,CAAhCtF,SAAAA,EAFF,WAEEA,CAFF;AAAA,MAIMwF,EAAAA,GAAWjE,QAAAA,CAAAA,cAAAA,CAAAA,kBAAAA,CAJjB,OAIiBA,CAJjB;AAAA,MAMMkE,CAAAA,GAEFzF,MAAAA,CAAAA,wBAAAA,CAAgC6E,QAAAA,CAAhC7E,SAAAA,EARJ,eAQIA,CARJ;AAAA,MA2DI+F,EAAAA,GAAmB;AAErBlC,IAAAA,aAAAA,EAAe;AAEb,MAAA,GAAA,EAAA,YAAM;AACJ,YAAIX,CAAAA,GAAI,KAAJA,OAAI,IAAgB,KAAA,OAAA,CAAA,UAAxB;AACIA,QAAAA,CAAJ,IAASA,CAAAA,CAAT,QAASA,KAAejD,IAAAA,CAAxB,YAAIiD,KACFA,CADF,GAAA,IAAIA;AAGJ,eAAa9D,KAAN,CAAMA,KAAN,CAAMA,GAAN,CAAMA,GAAgB4G,CAAAA,CAAAA,aAAAA,CALzB,IAKyBA,CAA7B;AAPW,OAAA;AASbC,MAAAA,YAAAA,EAAc,CAXK;AAEN,KAFM;AAcrBnD,IAAAA,UAAAA,EAAY;AAEV,MAAA,GAAA,EAAA,YAAM;AACJ,YAAII,CAAAA,GAAI,KAAJA,OAAI,IAAgB,KAAA,OAAA,CAAA,UAAxB;AACa9D,eAAAA,KAAN,CAAMA,KAAN,CAAMA,GAAN,CAAMA,GAAgB4G,CAAAA,CAAAA,UAAAA,CAFzB,IAEyBA,CAAhB5G;AAJL,OAAA;AAMV6G,MAAAA,YAAAA,EAAc,CApBK;AAcT,KAdS;AAuBrBvC,IAAAA,WAAAA,EAAa;AAEX,MAAA,GAAA,EAAA,YAAM;AACJ,YAAIR,CAAAA,GAAI,KAAJA,OAAI,IAAgB,KAAA,OAAA,CAAA,WAAxB;AACA,eAAa9D,KAAN,CAAMA,KAAN,CAAMA,GAAN,CAAMA,GAAgB4G,CAAAA,CAAAA,WAAAA,CAFzB,IAEyBA,CAA7B;AAJS,OAAA;AAMXC,MAAAA,YAAAA,EAAc,CA7BK;AAuBR,KAvBQ;AAgCrBxC,IAAAA,eAAAA,EAAiB;AAEf,MAAA,GAAA,EAAA,YAAM;AACJ,YAAIP,CAAAA,GAAI,KAAJA,OAAI,IAAgB,KAAA,OAAA,CAAA,eAAxB;AACA,eAAa9D,KAAN,CAAMA,KAAN,CAAMA,GAAN,CAAMA,GAAgB4G,CAAAA,CAAAA,eAAAA,CAFzB,IAEyBA,CAA7B;AAJa,OAAA;AAMfC,MAAAA,YAAAA,EAAc,CAtCK;AAgCJ,KAhCI;AAyCrBC,IAAAA,SAAAA,EAAW;AAIT,MAAA,GAAA,EAAA,YAAM;AACJ,eAAO,KAAA,YAAA,CAAP,OAAO,KADH,EACJ;AALO,OAAA;AAUT,MAAA,GAAA,EAAA,UAAG,CAAH,EAAW;AACT,aAAA,YAAA,CAAA,OAAA,EADS,CACT;AAXO,OAAA;AAaTD,MAAAA,YAAAA,EAAc,CAtDK;AAyCV,KAzCU;AA0DrBhC,IAAAA,kBAAAA,EAAoB;AAIlB,MAAA,GAAA,EAAA,YAAM;AACJ,YAAI,KAAJ,OAAI,IAA6C7E,KAAjD,CAAiDA,KAA7B,KAAA,OAAA,CAApB,WAAA,EAA4D;AAE1D,eADA,IAAI2B,CAAAA,GAAI,KAAA,WACR,EAAOA,CAAP,IAAYA,CAAAA,CAAZ,QAAYA,KAAed,IAAAA,CAA3B,YAAA,GACEc,CAAAA,GAAIA,CAAAA,CAAAA,WAAJA;;AAEF,iBAL0D,CAK1D;AAEA;;AAAA,eAAOiF,CAAAA,CAAAA,kBAAAA,CARL,IAQKA,CAAP;AAZc,OAAA;AAelBC,MAAAA,YAAAA,EAAc,CAzEK;AA0DD,KA1DC;AA4ErBjC,IAAAA,sBAAAA,EAAwB;AAItB,MAAA,GAAA,EAAA,YAAM;AACJ,YAAI,KAAJ,OAAI,IAAiD5E,KAArD,CAAqDA,KAAjC,KAAA,OAAA,CAApB,eAAA,EAAgE;AAE9D,eADA,IAAI2B,CAAAA,GAAI,KAAA,eACR,EAAOA,CAAP,IAAYA,CAAAA,CAAZ,QAAYA,KAAed,IAAAA,CAA3B,YAAA,GACEc,CAAAA,GAAIA,CAAAA,CAAAA,eAAJA;;AAEF,iBAL8D,CAK9D;AAEA;;AAAA,eAAOiF,CAAAA,CAAAA,sBAAAA,CARL,IAQKA,CAAP;AAZkB,OAAA;AAetBC,MAAAA,YAAAA,EAAc,CAtJlB;AAuI0B;AA5EH,GA3DvB;AAAA,MA2JIE,CAAAA,GAAkB;AAEpBxC,IAAAA,UAAAA,EAAY;AAIV,MAAA,GAAA,EAAA,YAAM;AAEJ,YJrKUzD,CIqKN,CAAJ,IAAI,CAAJ,EAA6C;AAC3C,cAAI,CAAC,KAAA,OAAA,CAAL,UAAA,EAA8B;AAC5B,iBAAA,OAAA,CAAA,UAAA,GAA0B,EAA1B;;AACA,iBAAK,IAAIa,CAAAA,GAAE,KAAX,UAAA,EAAA,CAAA,EAA+BA,CAA/B,GAAiCA,CAAAA,CAAjC,WAAA,EACE,KAAA,OAAA,CAAA,UAAA,CAAA,IAAA,CAH0B,CAG1B;AAGJ;;AAAA,cAAA,CAAA,GAAa,KAAA,OAAA,CAP8B,UAO3C;AAPF,SAAA,MASE4C,CAAAA,GAAaqC,CAAAA,CAAAA,UAAAA,CAAAA,IAAAA,CAAbrC;;AAEFA,QAAAA,CAAAA,CAAAA,IAAAA,GAAkByC,UAAQ,CAARA,EAAgB;AAChC,iBAAOzC,CAAAA,CADyB,CACzBA,CAAP;AAEF,SAHAA;;AAGA,eAhBI,CAgBJ;AApBQ,OAAA;AAsBVsC,MAAAA,YAAAA,EAAc,CAxBI;AAER,KAFQ;AA2BpBI,IAAAA,iBAAAA,EAAmB;AAEjB,MAAA,GAAA,EAAA,YAAM;AACJ,eAAO,KAAA,QAAA,CADH,MACJ;AAHe,OAAA;AAKjBJ,MAAAA,YAAAA,EAAc,CAhCI;AA2BD,KA3BC;AAmCpB1C,IAAAA,UAAAA,EAAY;AAEV,MAAA,GAAA,EAAA,YAAM;AACJ,YAAIL,CAAAA,GAAI,KAAJA,OAAI,IAAgB,KAAA,OAAA,CAAA,UAAxB;AACA,eAAa9D,KAAN,CAAMA,KAAN,CAAMA,GAAN,CAAMA,GAAgB4G,CAAAA,CAAAA,UAAAA,CAFzB,IAEyBA,CAA7B;AAJQ,OAAA;AAMVC,MAAAA,YAAAA,EAAc,CAzCI;AAmCR,KAnCQ;AA4CpBzC,IAAAA,SAAAA,EAAW;AAET,MAAA,GAAA,EAAA,YAAM;AACJ,YAAIN,CAAAA,GAAI,KAAJA,OAAI,IAAgB,KAAA,OAAA,CAAA,SAAxB;AACA,eAAa9D,KAAN,CAAMA,KAAN,CAAMA,GAAN,CAAMA,GAAgB4G,CAAAA,CAAAA,SAAAA,CAFzB,IAEyBA,CAA7B;AAJO,OAAA;AAMTC,MAAAA,YAAAA,EAAc,CAlDI;AA4CT,KA5CS;AAqDpB7B,IAAAA,WAAAA,EAAa;AAIX,MAAA,GAAA,EAAA,YAAM;AACJ,YJvNUlE,CIuNN,CAAJ,IAAI,CAAJ,EAA6C;AAE3C,eADA,IAAIoG,CAAAA,GAAJ,EAAA,EACSxI,CAAAA,GADT,CAAA,EACgByI,CAAAA,GAAK,KADrB,UAAA,EACA,CAAA,EAA0CC,CAA1C,GAA8CD,CAAAA,CAA9C,CAA8CA,CAA9C,EAAsDzI,CAAtD,EAAA,EACM0I,CAAAA,CAAJ,QAAIA,KAAevG,IAAAA,CAAnB,YAAIuG,IACFF,CAAAA,CAAAA,IAAAA,CAAQE,CAAAA,CAARF,WAAAA,CADEE;;AAIN,iBAAOF,CAAAA,CAAAA,IAAAA,CAPoC,EAOpCA,CAAP;AAEA;;AAAA,eAAON,CAAAA,CAAAA,WAAAA,CAVL,IAUKA,CAAP;AAdO,OAAA;AAqBX,MAAA,GAAA,EAAA,UAAG,CAAH,EAAU;AACR,YAAA,gBAAI,OAAJ,CAAA,IAAA,SAAA,CAAA,EACES,CAAAA,GAAO,EAAPA;;AAEF,gBAAQ,KAAR,QAAA;AACE,eAAKxG,IAAAA,CAAL,YAAA;AACA,eAAKA,IAAAA,CAAL,sBAAA;AAhPN,mBAAOsD,KAAP,UAAA,GACEiB,KAAAA,WAAAA,CAAiBjB,KAAjBiB,UAAAA;;AAkPM,aAAA,IAAIiC,CAAAA,CAAJ,MAAA,IAAuB,KAAvB,QAAuB,KAAkBxG,IAAAA,CAAzC,YAAA,KACE,KAAA,WAAA,CAAiBsB,QAAAA,CAAAA,cAAAA,CAAjB,CAAiBA,CAAjB,CADF;AAGA;;AACF;AAEE,iBAAA,SAAA,GAfI,CAeJ;AAXJ;AAzBS,OAAA;AAwCX0E,MAAAA,YAAAA,EAAc,CA7FI;AAqDP,KArDO;AAiGpBnC,IAAAA,iBAAAA,EAAmB;AAIjB,MAAA,GAAA,EAAA,YAAM;AACJ,YAAI,KAAJ,OAAI,IAA4C1E,KAAhD,CAAgDA,KAA5B,KAAA,OAAA,CAApB,UAAA,EAA2D;AAEzD,eADA,IAAI2B,CAAAA,GAAI,KAAA,UACR,EAAOA,CAAP,IAAYA,CAAAA,CAAZ,QAAYA,KAAed,IAAAA,CAA3B,YAAA,GACEc,CAAAA,GAAIA,CAAAA,CAAAA,WAAJA;;AAEF,iBALyD,CAKzD;AAEA;;AAAA,eAAOiF,CAAAA,CAAAA,iBAAAA,CARL,IAQKA,CAAP;AAZa,OAAA;AAejBC,MAAAA,YAAAA,EAAc,CAhHI;AAiGD,KAjGC;AAmHpBlC,IAAAA,gBAAAA,EAAkB;AAIhB,MAAA,GAAA,EAAA,YAAM;AACJ,YAAI,KAAJ,OAAI,IAA2C3E,KAA/C,CAA+CA,KAA3B,KAAA,OAAA,CAApB,SAAA,EAA0D;AAExD,eADA,IAAI2B,CAAAA,GAAI,KAAA,SACR,EAAOA,CAAP,IAAYA,CAAAA,CAAZ,QAAYA,KAAed,IAAAA,CAA3B,YAAA,GACEc,CAAAA,GAAIA,CAAAA,CAAAA,eAAJA;;AAEF,iBALwD,CAKxD;AAEA;;AAAA,eAAOiF,CAAAA,CAAAA,gBAAAA,CARL,IAQKA,CAAP;AAZY,OAAA;AAehBC,MAAAA,YAAAA,EAAc,CAlII;AAmHF,KAnHE;AAqIpB/B,IAAAA,QAAAA,EAAU;AAIR,MAAA,GAAA,EAAA,YAAM;AACJ,YJvSUhE,CIuSV;AJvSUA,QAAAA,CIwSN,CAAJ,IAAI,CJxSMA,GIySRgE,CADF,GACarG,KAAAA,CAAAA,SAAAA,CAAAA,MAAAA,CAAAA,IAAAA,CAA4B,KAA5BA,UAAAA,EAA6C,UAAQ,CAAR,EAAY;AAClE,iBAAQkD,CAAAA,CAAR,QAAQA,KAAed,IAAAA,CAD2C,YAClE;AAFJ,SACapC,CJzSHqC,GI6SRgE,CALF,GAKa8B,CAAAA,CAAAA,QAAAA,CAAAA,IAAAA,CJ7SH9F;;AI+SVgE,QAAAA,CAAAA,CAAAA,IAAAA,GAAgBwC,UAAQ,CAARA,EAAgB;AAC9B,iBAAOxC,CAAAA,CADuB,CACvBA,CAAP;AAEF,SAHAA;;AAGA,eAZI,CAYJ;AAhBM,OAAA;AAkBR+B,MAAAA,YAAAA,EAAc,CAvJI;AAqIV,KArIU;AA2JpB9B,IAAAA,SAAAA,EAAW;AAIT,MAAA,GAAA,EAAA,YAAM;AACJ,YAAM3C,CAAAA,GAAU,eAAA,KAAA,SAAA,GACoBA,KADpB,OAAA,GACqC,IADrD;AJ7TUtB,eAAAA,CI+TN,CAAJ,IAAI,CJ/TMA,GCuGA0C,CGyND,CADT,CACS,CJhUC1C,GIkUD8F,CAAAA,CAAAA,SAAAA,CANL,CAMKA,CJlUC9F;AIwTH,OAAA;AAgBT,MAAA,GAAA,EAAA,UAAG,CAAH,EAAU;AA3UZ,aA4UI,IAAMsB,CAAAA,GAAU,eAAA,KAAA,SAAA,GACoBA,KADpB,OAAA,GA5UpB,IAAA,EA8UcA,CA9UP+B,CAAP,UAAA,GA8Uc/B,CA7UZgD,CAAAA,WA6UYhD,CAAAA,CA7UK+B,CAAjBiB,UA6UYhD;;AACV,YAAImF,CAAAA,GAAgB,KAAA,SAApB;AACKA,QAAAA,CAAL,IAAA,eAAA,CAAKA,KACHA,CADF,GAAA,KAAKA;AAGCC,QAAAA,CAAAA,GAAgBpB,EAAAA,CAAAA,aAAAA,CAAAA,CAAAA,CAAhBoB;;AAMN,aALIrB,CAAJ,IAA2BA,CAAAA,CAA3B,GAAIA,GACF,CAAA,CAAA,GAAA,CAAA,IAAA,CAAA,CAAA,EADF,CACE,CADEA,GAGFqB,CAAAA,CAHF,SAGEA,GAA0BH,CAE5B,EAAOG,CAAAA,CAAP,UAAA,GACEpF,CAAAA,CAAAA,WAAAA,CAAoBoF,CAAAA,CAfd,UAeNpF;AA/BK,OAAA;AAkCTyE,MAAAA,YAAAA,EAAc,CAxVlB;AAsTa;AA3JS,GA3JtB;AAAA,MAgWWY,EAAAA,GAAqB;AAE9BC,IAAAA,UAAAA,EAAY;AAIV,MAAA,GAAA,EAAA,YAAM;AACJ,eAAO,KAAP,OAAO,IAAgB,KAAA,OAAA,CAAvB,CAAO,IADH,IACJ;AALQ,OAAA;AAOVb,MAAAA,YAAAA,EAAc,CAzWlB;AAkWc;AAFkB,GAhWhC;AAAA,MAgXWc,CAAAA,GAAwB;AAEjCC,IAAAA,aAAAA,EAAe;AAIb,MAAA,GAAA,EAAA,YAAM;AA1WN,YAAA,CAAA,GADEvB,CAAJ,IAAqCA,CAAAA,CAArC,GAAIA,GACKA,CAAAA,CAAAA,GAAAA,CAAAA,IAAAA,CADT,QACSA,CADLA,GJtBK9F,CIwBG+F,CAAL,CJxBE/F,GIqByB,KAAA,CJrBzBA,GIyBA4B,QAAAA,CAAAA,aAFP;;AAWF,YAAKoE,CAAL,IAAgBA,CAAAA,CAAhB,QAAA,EAAA;AAGA,cAAIvF,CAAAA,GAAc,CAAC,CJxBLA,CIwBO,CAAA,IAAA,CAArB;;AACA,cAAA,SAAA,QAAA,IAGOA,CAHP,IASMwF,KATN,IASMA,KATN,CAGOxF,IAOAyF,CAAAA,CAAAA,QAAAA,CAAAA,IAAAA,CAAoBD,KAApBC,IAAAA,EAVP,CAUOA,CAVP,EAAA;AAkBA,iBADIC,CACJ,GJvCcxF,CIsCG,CAAA,CAAA,CACjB,EAAOwF,CAAP,IAAqBA,CAArB,KAAA,IAAA,GACEH,CACA,GADSG,CAAAA,CAAAA,IAATH,EACA,CAAA,GJzCYrF,CIyCC,CAAA,CAAA,CADbqF;;AAGF,YAAA,CAAA,GAAA,SAAA,QAAA,GAESG,CAAAA,GAAAA,IAAAA,GAFT,CAAA,GAMSA,CAAAA,KAAAA,IAAAA,GAAAA,CAAAA,GA5BT,IAsBA;AAtBA,WAAA,MAWI,CAAA,GAfJ,IAeI;AAfJ,SAAA,MACE,CAAA,GAAO,IAAP;;AA+VE,eADI,CACJ;AALW,OAAA;AAUb,MAAA,GAAA,EAAA,YAAM,CAVO,CAAA;AAWbG,MAAAA,YAAAA,EAAc,CAbiB;AAElB;AAFkB,GAhXnC;;AAyYAgB,WAASA,CAATA,CAA2B,CAA3BA,EAA2B,CAA3BA,EAA2B,CAA3BA,EAAqD;AACnD,SAAKzG,IAAL,CAAA,IAAA,CAAA,EAA2B;AACzB,UAAI0G,CAAAA,GAAUlH,MAAAA,CAAAA,wBAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAd;AACKkH,MAAAA,CAAL,IAAgBA,CAAAA,CAAhB,YAAKA,IACF,CADH,CACG,IADH,CAAKA,GAEHlH,MAAAA,CAAAA,cAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAA8BmH,CAAAA,CAFhC,CAEgCA,CAA9BnH,CAFGkH,GAGME,CAHX,IAIEC,OAAAA,CAAAA,IAAAA,CAAAA,kBAAAA,EAAAA,CAAAA,EAAAA,IAAAA,EANuB,CAMvBA,CAJGH;AAH4C;AAa9CI;;AAAAA,WAASA,CAATA,CAAuB,CAAvBA,EAA+B;AACpCL,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA;AACAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA;AACAA,IAAAA,CAAAA,CAAAA,CAAAA,EAHoC,CAGpCA,CAAAA;AAUK;;AAAA,MAAIM,EAAAA,GJ9aA5H,CI8a+B+F,CAAAA,CJ9a/B/F,GI+aT,YAAW,CAD6B+F,CJ9a/B/F,GI+aO,UAAQ,CAAR,EAAkB;AAC1B6H,IAAAA,CAAAA,CAAN,OAAMA,IAAmBA,CAAAA,CAAAA,OAAAA,CAAzB,CAAMA,KACJA,CAAAA,CAAAA,OAAAA,GAAkBA,CAAAA,CAAAA,OAAAA,IAAmB,EAArCA,EACAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,GAAqC,CAAA,CADrCA,EAEA,CAAA,CAAA,CAAA,EAAA,EAAA,EAA8C,CAJhB,CAI9B,CAHIA;AAFH,GAAA;AAAA,MAUIC,EAAAA,GJxbA9H,CIwb8B+F,CAAAA,CJxb9B/F,GIybT,YAAW,CAD4B+F,CJxb9B/F,GIybO,UAAQ,CAAR,EAAkB;AAC1B6H,IAAAA,CAAAA,CAAN,OAAMA,IAAmBA,CAAAA,CAAAA,OAAAA,CAAzB,CAAMA,KACJA,CAAAA,CAAAA,OAAAA,GAAkBA,CAAAA,CAAAA,OAAAA,IAAmB,EAArCA,EACAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,GAAoC,CAAA,CADpCA,EAEAP,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAA6C,CAA7CA,CAAAA,CAFAO,EAGA,CAAA,CAAA,CAAA,EAAA,EAAA,EAAgD,CALlB,CAK9B,CAJIA;GAZH;;ACrZPI,WAASA,EAATA,CAAiB,CAAjBA,EAAiB,CAAjBA,EAAiB,CAAjBA,EAA6C;ADqZlCL,IAAAA,ECpZT,CAAA,CAAA,CDoZSA;ACnZTO,IAAAA,CAAAA,GAAWA,CAAXA,IAAuB,IAAvBA;AACA3H,IAAAA,CAAAA,CAAAA,OAAAA,GAAeA,CAAAA,CAAfA,OAAeA,IAAgB,EAA/BA;AACA4H,IAAAA,CAAAA,CAAAA,OAAAA,GAAoBA,CAAAA,CAApBA,OAAoBA,IAAqB,EAAzCA;AACID,IAAAA,CAAJ,KACEA,CAAAA,CADF,OACEA,GAAmBA,CAAAA,CADrB,OACqBA,IADrB,EAAA,CAAIA;AAIJ3H,IAAAA,CAAAA,CAAAA,OAAAA,CAAAA,eAAAA,GAA+B2H,CAAAA,GAAWA,CAAAA,CAAAA,OAAAA,CAAXA,eAAAA,GAC7BC,CAAAA,CAAAA,SADF5H;AAEA,QAAI6H,CAAAA,GAAK7H,CAAAA,CAAAA,OAAAA,CAAAA,eAAT;AACI6H,IAAAA,CAAJ,IAAUA,CAAAA,CAAV,OAAIA,KACFA,CAAAA,CAAAA,OAAAA,CADF,WACEA,GADF,CAAIA;AAKJ,KADIC,CACJ,GADS9H,CAAAA,CAAAA,OAAAA,CAAAA,WAAAA,GAA2B2H,CACpC,KAAUG,CAAAA,CAAV,OAAA,KACEA,CAAAA,CAAAA,OAAAA,CADF,eACEA,GADF,CAAA;AAIA9H,IAAAA,CAAAA,CAAAA,OAAAA,CAAAA,UAAAA,GAA0B4H,CAA1B5H;AACI2H,IAAAA,CAAJ,GACMA,CADN,KACmBC,CAAAA,CAAAA,OAAAA,CADnB,UACMD,KACFC,CAAAA,CAAAA,OAAAA,CAFJ,UAEIA,GAFJ,CACMD,CADN,IAKEC,CAAAA,CAAAA,OAAAA,CAAAA,SAAAA,GAA8B5H,CAA9B4H,EACKA,CAAAA,CAAAA,OAAAA,CAAL,UAAKA,KACHA,CAAAA,CAAAA,OAAAA,CADF,UACEA,GAPJ,CAMOA,CANP,CAAID;AAWJC,IAAAA,CAAAA,CAAAA,OAAAA,CAAAA,UAAAA,GAjC2C,IAiC3CA;AAjC2C;;AAkEfG,WAAAA,CAAAA,CAAQ,CAARA,EAAe;AAC3C,QAAI,CAAC/H,CAAAA,CAAL,OAAI,IAA6Cf,KAAjD,CAAiDA,KAA5Be,CAAAA,CAAAA,OAAAA,CAArB,UAAA,EAA4D;AAC1DA,MAAAA,CAAAA,CAAAA,OAAAA,GAAeA,CAAAA,CAAfA,OAAeA,IAAgB,EAA/BA;AACAA,MAAAA,CAAAA,CAAAA,OAAAA,CAAAA,UAAAA,GAA0BoD,CAAAA,CAAAA,UAAAA,CAAAA,CAAAA,CAA1BpD;AACAA,MAAAA,CAAAA,CAAAA,OAAAA,CAAAA,SAAAA,GAAyBqD,CAAAA,CAAAA,SAAAA,CDyVlBiE,CCzVkBjE,CAAzBrD;ADyVOsH,MAAAA,ECxVP,CAAA,CAAA,CDwVOA;;ACtVP,WADA,IAAIzE,CAAAA,GAAK7C,CAAAA,CAAAA,OAAAA,CAAL6C,UAAK7C,GAA0BwD,CAAAA,CAAAA,UAAAA,CAAnC,CAAmCA,CAAnC,EACS7F,CAAAA,GADT,CAAA,EACA,CAAA,EAAkBA,CAAlB,GAAoBkF,CAAAA,CAApB,MAAkBlF,KAAiBiD,CAAnC,GAAqCiC,CAAAA,CAArC,CAAqCA,CAAnBlF,CAAlB,EAA6CA,CAA7C,EAAA,EACEiD,CAAAA,CAAAA,OAAAA,GAAYA,CAAAA,CAAAA,OAAAA,IAAa,EAAzBA,EACAA,CAAAA,CAAAA,OAAAA,CAAAA,UAAAA,GAAuBZ,CADvBY,EAEAA,CAAAA,CAAAA,OAAAA,CAAAA,WAAAA,GAAwBiC,CAAAA,CAAGlF,CAAHkF,GAAAA,CAAAA,CAAAA,IAAW,IAFnCjC,EAGAA,CAAAA,CAAAA,OAAAA,CAAAA,eAAAA,GAA4BiC,CAAAA,CAAGlF,CAAHkF,GAAAA,CAAAA,CAAAA,IAAW,IAHvCjC,ED2UKwG,ECvUL,CAXwD,CAWxD,CAJAxG;AARuC;;;;;AC5EtCwD,WAASA,CAATA,CAAqB,CAArBA,EAAqB,CAArBA,EAAqB,CAArBA,EAA8C;AACnD,QAAIpE,CAAJ,KAAA,CAAA,EACE,MAAM4C,KAAAA,CAAN,uFAAMA,CAAN;;AAEF,QAAA,CAAA,EAAc;AACZ,UAAIvC,CAAAA,GAAIsH,CAAAA,CAAJtH,OAAIsH,IAAoBA,CAAAA,CAAAA,OAAAA,CAAAA,UAA5B;AACA,UAAW1I,KAAX,CAAWA,KAAX,CAAWA,IAAaoB,CAAxB,KAAA,CAAWpB,IACFA,KADT,CACSA,KADT,CACSA,IAAa0D,CAAAA,CAAAA,UAAAA,CADtB,CACsBA,MADtB,CAAA,EAEE,MAAMC,KAAAA,CAJI,+HAIJA,CAAN;AAIJ;;AAAA,QAAI+E,CAAJ,KAAA,CAAA,EACE,OAAO3H,CAAP;AAGEA,IAAAA,CAAAA,CAAJ,UAAIA,IAGFqE,CAAAA,CAAYrE,CAAAA,CAAZqE,UAAAA,EAAAA,CAAAA,CAHErE;AAOAgI,IAAAA,CAAAA,GNrBU7H,CMqBE,CAAA,CAAA,CAAZ6H;AAEa,QAAA,CAAA;AAAA,QAAA,CAAA,GAAA,CAAA,EAoCe,CAAA,EAAA;AAChC,UAAI,CArC0BhI,CAqCzB,CAAL,kBAAA,EAAiC;AAC/B,YAAIyI,CAAJ;AACA,mBAvC4BzI,CAuCxB0I,CAAJ,SAAA,GACED,CADF,GACU,CAxCkBzI,CAwClB,CADV,GAvC4BA,CAyCjBkF,CAFX,gBAvC4BlF,KA0C1ByI,CAHF,GAvC4BzI,CA0ClBkF,CAAAA,gBA1CkBlF,CAuC5B,MAvC4BA,CAAAA,CAuC5B;;AAKA,YAAIyI,CAAJ,IAAaA,CAAAA,CAAb,MAAA,EAA2B;AACzB,UAAA,CAAA,GAAA,CAAA;AAAA,gBADyB,CACzB;AAR6B;AADD;;AAAA,MAAA,CAAA,GAAA,KAAA,CAAA;AAnChC;AAAA,KADIR,CACJ,GADiB,CACjB,KACED,CCgSF2C,CAAAA,CDhSE3C,CCgSF2C,IDhSE3C,CCgSF2C,KDhSE3C,CAAAA,CCgSF2C,CAAAA,CDhSE3C,ECgSF2C,GAAAA,MAAAA,CDhSsB1C,CEtBtB,YAAA,KFsBsBA,GAAAA,CAAAA,GEnBb4F,EAAAA,CAA0BC,EAAAA,CFmBb7F,CEnBa6F,CAA1BD,CDmTTlD,CDhSE3C,CADF;AAGIA,IAAAA,CAAJ,KAAA,WAAkBE,CAAAA,CAAlB,SAAA,IAAA,CAAA,CAAIF,IACFG,CAAAA,CAAAA,CAAAA,CADEH;;AAGJ,QNtCcjI,CMsCV,CAAJ,CAAI,CAAJ,EAA+C;AACA4H,MAAAA,CAAAA,GFwYtCL,CExYsCK;AFwYtCL,MAAAA,ECpbT,CAAA,CAAA,CDobSA;AExY8BY,MAAAA,CD3CvCX,CAAAA,OC2CuCW,GAAAA,CD3CnBX,CAApBA,OC2CuCW,ID3CE,EC2CFA;AD1CFjJ,WAArC,CAAqCA,KC0CEiJ,CD1CnCX,CAAAA,OC0CmCW,CD1CvC,UAAqCjJ,KC0CEiJ,CDzCrCX,CAAAA,OCyCqCW,CD1CvC,UC0CuCA,GD1CvC,IAAqCjJ;;AAIrC,UCsCiCe,CDtC7BwH,CAAJ,QCsCiCxH,KDtCXF,IAAAA,CAAtB,sBAAA,EAAmD;AAC7C+C,QAAAA,CAAAA,GCqC2B7C,CDrCtBwD,CAAAA,UAALX;;AACJ,aAASlF,CAAT,GAAA,CAAA,EAAcA,CAAd,GAAkBkF,CAAAA,CAAlB,MAAA,EAA6BlF,CAA7B,EAAA,EACE8J,EAAAA,CAAS5E,CAAAA,CAAT4E,CAAS5E,CAAT4E,EAAAA,CAAAA,EAAAA,CAAAA,CAAAA;;ACmC6BzH,QAAAA,CDhC/BuH,CAAAA,OCgC+BvH,GAAAA,CDhChBuH,CAAfA,OCgC+BvH,IDhCA,ECgCAA;AD/B3B0H,QAAAA,CAAAA,GAAuCzI,KAA7B,CAA6BA,KC+BZe,CD/BhBuH,CAAAA,OC+BgBvH,CD/BjB,UAA6Bf,GAA7B,IAA6BA,GAAoBA,KAAAA,CAA3DyI;AC+B2B1H,QAAAA,CD9B/BuH,CAAAA,OC8B+BvH,CD9B/BuH,UC8B+BvH,GAAAA,CD9BLuH,CAAAA,OC8BKvH,CD9B/BuH,SC8B+BvH,GD9BoB0H,CC8BpB1H;AAAAA,QAAAA,CD7B/BuH,CAAAA,OC6B+BvH,CD7B/BuH,UC6B+BvH,GDtCkB,CCsClBA;ADtCjC,OAAA,MAWEyH,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,CAAAA;;AC8BA,UAAIW,EAAAA,CAAJ,CAAIA,CAAJ,EAAmC;AACjCD,QAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,IAAAA,CAAAA;AACA,YAAA,CAAA,GAAsB,CAFW,CAEjC;AAFF,OAAA,MAKWD,CAAAA,CAAAA,OAAAA,CAAJ,IAAIA,KACTG,CADK,GACiB,CAVqB,CASlCH;AAIRG;;AAAAA,IAAAA,CAAL,KAEMT,CAGJ,GNpDY3H,CMiDI,CAAA,CAAA,CNjDJA,GMkDgBiI,CAADzC,CADX,INjDJxF,GMkD+BiI,CADvCN,EAGAD,CAAJ,IACEA,CACA,GADWW,EAAAA,CAAAA,CAAAA,CAAXX,EACA,CAAA,CAAA,YAAA,CAAA,IAAA,CAAA,CAAA,EAAA,CAAA,EAFF,CAEE,CAFF,IAIEY,CAAAA,CAAAA,WAAAA,CAAAA,IAAAA,CAAAA,CAAAA,EATJ,CASIA,CATJ,CAAKF;AAYLG,IAAAA,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA;AACA,WA1DmD,CA0DnD;AA1DmD;;AAkF9CnE,WAASA,CAATA,CAAoB,CAApBA,EAAoB,CAApBA,EAAmC;AACxC,QAAIrE,CAAAA,CAAJ,UAAIA,KAAJ,CAAA,EACE,MAAM4C,KAAAA,CAAAA,yDAAN,CAAMA,CAAN;AAGF,QACIoF,CAAAA,GNtFU7H,CMsFE,CAAA,CAAA,CADhB;;AAGA,QNhGcJ,CMgGV,CAAJ,CAAI,CAAJ,EAA+C;AACfC,MAAAA,CD5ChCuH,CAAAA,OC4CgCvH,GAAAA,CD5CjBuH,CAAfA,OC4CgCvH,ID5CD,EC4CCA;AAAMkI,MAAAA,CD3CtCX,CAAAA,OC2CsCW,GAAAA,CD3ClBX,CAApBA,OC2CsCW,ID3CG,EC2CHA;AAANlI,MAAAA,CD1ChC,KC0CsCkI,CD1CzBX,CAAAA,OC0CyBW,CD1CtC,UC0CgClI,KAAMkI,CDzCpCX,CAAAA,OCyCoCW,CD1CtC,UC0CsCA,GAANlI,CDzCCuH,CAAAA,OCyCDvH,CD1ChC,WC0CgCA;AAAAA,MAAAA,CDvChC,KCuCsCkI,CDvCzBX,CAAAA,OCuCyBW,CDvCtC,SCuCgClI,KAAMkI,CDtCpCX,CAAAA,OCsCoCW,CDvCtC,SCuCsCA,GAANlI,CDtCAuH,CAAAA,OCsCAvH,CDvChC,eCuCgCA;ADpChC,UAAIK,CAAAA,GCoC4BL,CDpCxBuH,CAAAA,OCoCwBvH,CDpChC,eAAA;AAAA,UACIY,CAAAA,GCmC4BZ,CDnCxBuH,CAAAA,OCmCwBvH,CDnCxBuH,WADR;AAEIlH,MAAAA,CAAJ,KACEA,CAAAA,CAAAA,OAAAA,GAAYA,CAAAA,CAAAA,OAAAA,IAAa,EAAzBA,EACA,CAAA,CAAA,OAAA,CAAA,WAAA,GAFF,CAAA,CAAIA;AAIAO,MAAAA,CAAJ,KACEA,CAAAA,CAAAA,OAAAA,GAAYA,CAAAA,CAAAA,OAAAA,IAAa,EAAzBA,EACA,CAAA,CAAA,OAAA,CAAA,eAAA,GAFF,CAAA,CAAIA;AC8B4BZ,MAAAA,CDvBhC,CAAA,OCuBgCA,CDvBhC,UCuBgCA,GAAAA,CDvBNuH,CAAAA,OCuBMvH,CDvBhC,eCuBgCA,GAAAA,CDtB9BuH,CAAAA,OCsB8BvH,CDvBhC,WCuBgCA,GDtBHf,KAAAA,CCsBGe;ADrBKf,WAArC,CAAqCA,KCqBCiJ,CDrBlCX,CAAAA,OCqBkCW,CDrBtC,UAAqCjJ,KCqBCiJ,CDnBpCX,CAAAA,OCmBoCW,CDrBtC,UCqBsCA,GDrBtC,IAAqCjJ;;ACsBnC,UAAImJ,EAAAA,CAAJ,CAAIA,CAAJ,EAAmC;AACjCD,QAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,IAAAA,CAAAA;AACA,YAAA,CAAA,GAAsB,CAFW,CAEjC;AAJ2C;AAO/CQ;;AAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA;;AAEA,QAAA,CAAA,EAAe;AAEb,OADIC,CACJ,GADwBV,CACxB,IADuD,WAArBA,CAAAA,CAAAA,SAClC,MACEW,CADF,GACwB,CADxB,CAAA;AC2SFoC,MAAAA,EAAAA,CDxS2BjD,CCwS3BiD,CAAAA;AAEMgC,MAAAA,CAAAA,GD1SqBjF,CC0Sf0C,CAAAA,CAANuC;;AACN,WAAKrM,IAAL,CAAA,IAAA,CAAA,EAEE,KADA,IAAI6H,CAAAA,GAAQwE,CAAAA,CAAZ,CAAYA,CAAZ,EACStP,CAAAA,GAAT,CAAA,EAAcA,CAAd,GAAkB8K,CAAAA,CAAlB,MAAA,EAAgC9K,CAAhC,EAAA,EAAqC;AACnC,YAAIuN,CAAAA,GAAOzC,CAAAA,CAAAA,CAAAA,CAAX;;AACA,YPjUU9G,EOiUN,CD/SmD3B,CC+SnD,EAAJ,CAAI,CAAJ,EAAqC;AACnCyI,UAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,EAAAA,CAAAA;AACMyE,cAAAA,CAAAA,GDjTelF,CCiTXyC,CAAAA,CDjTWzC,CCiTXyC,ODjTWzC,CCiTXyC,CDjTWzC,CCiTfkF;AACN,eAAA,CAAA,IDlTqBlF,CCmTnByC,CAAAA,CDnTmBzC,CCmTnByC,MDnTmBzC,CCmTnByC,CDnTmBzC,ECmTnByC,CDnTmBzC,CCkTrB;AAGArK,UAAAA,CAAAA;AA+BN,cADIgD,CACJ,GA9BiCuK,CA6BxB3D,CAAAA,OA7BwB2D,CA6BxB3D,CACT,EACE,KAAS5J,CAAT,GAAA,CAAA,EAAcA,CAAd,GAAgBgD,CAAAA,CAAhB,MAAA,EAA2BhD,CAA3B,EAAA,EAAgC;AAC9B,gBAAIqC,CAAAA,GAAOW,CAAAA,CAAX,CAAWA,CAAX;AAAA,gBACIuH,CAAAA,GAASvF,CAAAA,CAAAA,UAAAA,CAAAA,CAAAA,CADb;AAEIuF,YAAAA,CAAJ,IACE7D,CAAAA,CAAAA,WAAAA,CAAAA,IAAAA,CAAAA,CAAAA,EAJ4B,CAI5BA,CADE6D;AAjCFiF;AAAAA,UAAAA,CAAAA,GAAY,CARuB,CAQnCA;AAViC;AD5SrC;;AAAA,OC0TKA,CD1TL,IAAA,CAAA,KACEhF,CAAAA,CAPW,CAOXA,CADF;AAIGU;;AAAAA,IAAAA,CAAL,KAEMjB,CAOJ,GNxHY3H,CMiHI,CAAA,CAAA,CNjHJA,GMkHgBiI,CAADzC,CADX,INjHJxF,GMmHViI,CAFEN,EAOJ,CAAMxH,CAAAA,CAAAA,CAAAA,OAAAA,CAAN,IAAMA,IAAN,WAA6BJ,CAAAA,CAA7B,SAAMI,IACHwH,CADH,KACiBjF,CAAAA,CAAAA,UAAAA,CADjB,CACiBA,CADjB,KAEE4F,CAAAA,CAAAA,WAAAA,CAAAA,IAAAA,CAAAA,CAAAA,EAXJ,CAWIA,CAXJ,CAAKM;AAcLL,IAAAA,EAAAA,CAAAA,CAAAA,EAAAA,IAAAA,EAAAA,CAAAA,CAAAA;AACA,WA1CwC,CA0CxC;AAGFG;;AAAAA,WAASA,EAATA,CAA6B,CAA7BA,EAAoC;AAElC,QAAuB3I,CAYRuH,CAZf,OAAuBvH,IAYwCf,KAZ/D,CAY+DA,KAZxCe,CAYQuH,CAAAA,OAZRvH,CAAvB,CAAA,EAEE,KADA,IAAI6C,CAAAA,GAAK7C,CAAAA,CAAT,UAAA,EACSrC,CAAAA,GADT,CAAA,EACcoF,CAAAA,GAAEF,CAAAA,CADhB,MAAA,EACA,CAAA,EAA+BlF,CAA/B,GAAA,CAA+BA,KAASiD,CAAxC,GAA0CiC,CAAAA,CAA1C,CAA0CA,CAAXlF,CAA/B,EAAkDA,CAAlD,EAAA,EACEgL,EAAAA,CAAAA,CAAAA,CAAAA;AAGA3I,IAAAA,CAAAA,CAAJ,OAAIA,KACFA,CAAAA,CAAAA,OAAAA,CADF,CACEA,GAA8Bf,KATE,CAQ9Be;AAgBNsI;;AAAAA,WAASA,EAATA,CAA0B,CAA1BA,EAAiC;AAC/B,QAAIQ,CAAAA,GAAW9I,CAAf;AACIA,IAAAA,CAAJ,IAAA,WAAYA,CAAAA,CAAZ,SAAIA,KAEF8I,CAFF,GAEa,CADPC,CACO,GADK/I,CAAAA,CAAAA,OAAAA,IAAgBA,CAAAA,CAAAA,OAAAA,CAAAA,CACrB,KAAa+I,CAAAA,CAAb,MAAA,GAAgCA,CAAAA,CAAhC,CAAgCA,CAAhC,GACTT,EAAAA,CAAkBtI,CAAAA,CAHtB,WAGIsI,CAHAtI;AAKJ,WAP+B,CAO/B;AAGFoI;;AAAAA,WAASA,EAATA,CAA8B,CAA9BA,EAAqC;AAEnC,WAAA,CADIhI,CACJ,GADWJ,CACX,IADmBA,CAAAA,CAAAA,OAARA,IAAwBA,CAAAA,CAAAA,OAAAA,CAAAA,IACnC,KAAgBgJ,EAAAA,CAFmB,CAEnBA,CAAhB;AAFmC;;AAYrCC,WAASA,EAATA,CAAkC,CAAlCA,EAAkC,CAAlCA,EAA+C;AAC7C,QAAA,WAAA,CAAA,EACQf,CACN,GADelI,CAAAA,CAAAA,UAATkI,EACFE,EAAAA,CAAJ,CAAIA,CAAAA,IACFD,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAHJ,IAGIA,CAFID,CADR,KAKO,IAAA,WAAIlI,CAAAA,CAAJ,SAAA,IAAA,WAAA,CAAA,KACDI,CADC,GNjLOD,CMkLD,CADN,CACM,CADN,CAAA,EAEK;ACkPZ,UAAMiN,CAAAA,GDjPmBpN,CCiPTqN,CAAhB,CAAA;AAAA,UACMhB,CAAAA,GAAOC,EAAAA,CDlPYtM,CCkPZsM,CADb;;AAEA,UAAID,CAAJ,KAAA,CAAA,EAAA;AAII5D,QAAAA,CAAAA,GDvPArI,CCuPQsK,CAAAA,CDvPRtK,CCuPQsK,CDvPRtK,CCuPAqI;AACJ,YAAM9K,CAAAA,GAAI8K,CAAAA,CAAAA,OAAAA,CDxPezI,CCwPfyI,CAAV;AACA,aAAA,CAAA,IACEA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CADF;AAIIa,QAAAA,CAAAA,GD7PAlJ,CC6POsK,CAAAA,CD7PPtK,CC6PAkJ,CD7PAlJ,MAAAA,CC6P+BsK,CAAAA,CD7P/BtK,CC6PAkJ,CD7PAlJ,IC6PAkJ,ED7PAlJ,CC6PAkJ;AACJA,QAAAA,CAAAA,CAAAA,IAAAA,CD9PyBtJ,CC8PzBsJ;AACA,YAAIA,CAAAA,CAAJ,MAAA,KD/PIlJ,CCgQFsK,CAAAA,CDhQEtK,CC+PJ,CD/PIA,ICgQoBoM,EAAAA,CAbxB,CAawBA,CADxB;AD9PIrE;;AAAAA,MAAAA,CAAAA,CAFQ,CAERA,CAAAA;AAVyC;AAoB/CK;;AAAAA,WAASA,EAATA,CAAyB,CAAzBA,EAAyB,CAAzBA,EAAyB,CAAzBA,EAAwD;AAEtD,QADIU,CACJ,GADelJ,CAAAA,CAAAA,OAAAA,IAAgBA,CAAAA,CAAAA,OAAAA,CAAAA,CAC/B,EACMmJ,CAMJ,IALED,CAAAA,CAAAA,UAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CADEC,EAGAC,CAGJ,IAFEF,CAAAA,CAAAA,YAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAJEC,EAMJ,EAAA,CAToD,CASpD,CANIA;AAHgD;;AAiBjDxJ,WAASA,EAATA,CAAoB,CAApBA,EAAoC;AACzC,QAAKK,CAAL,IAAcA,CAAAA,CAAd,QAAA,EAAA;AAGAA,MAAAA,CAAAA,CAAAA,OAAAA,GAAeA,CAAAA,CAAfA,OAAeA,IAAgB,EAA/BA;AACA,UAAII,CAAAA,GAAOJ,CAAAA,CAAAA,OAAAA,CAAAA,CAAX;AACaf,WAAb,CAAaA,KAAb,CAAaA,KN1NCgB,CM2NR,CAAJ,CAAI,CN3NQA,GM4NVG,CADF,GAAA,CN3NYH,GM+NVG,CAJF,GAIS,CADH8H,CACG,GADMlI,CAAAA,CAAAA,UACN,IAASL,EAAAA,CAAT,CAASA,CAAT,GAA+BK,CN/N5BC,EMsORsI,CAAAA,CAAAA,QAAAA,CAAAA,IAAAA,CAA4BnH,QAAAA,CAA5BmH,eAAAA,EAAJ,CAAIA,MACFvI,CAAAA,CAAAA,OAAAA,CADF,CACEA,GAbJ,CAYMuI,CAZOtJ;AAgBb,aArBA,CAqBA;AAtByC;AAiCpCoK;;AAAAA,WAASA,CAATA,CAAc,CAAdA,EAAc,CAAdA,EAAc,CAAdA,EAAsC;AAC3C,QAAIC,CAAAA,GAAO,EAAX;AACAC,IAAAA,EAAAA,CAAcvJ,CAAAA,CAAduJ,UAAAA,EAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,CAAAA;AAEA,WAJ2C,CAI3C;AAGFA;;AAAAA,WAASA,EAATA,CAAsB,CAAtBA,EAAsB,CAAtBA,EAAsB,CAAtBA,EAAsB,CAAtBA,EAAwD;AACtD,SADsD,IAC7C5L,CAAAA,GAD6C,CAAA,EACxCoF,CAAAA,GAAEyG,CAAAA,CADsC,MAAA,EACtD,CAAA,EAAqC7L,CAArC,GAAA,CAAqCA,KAAS0I,CAA9C,GAAgDmD,CAAAA,CAAhD,CAAgDA,CAAX7L,CAArC,EAA8DA,CAA9D,EAAA,EAAmE;AAC7D,UAAA,CAAA;;AAAA,UAAA,CAAA,GAAA,CAAA,CAAA,QAAA,KAAA,IAAA,CAAA,YAAA,EAAA;AACA,QAAA,CAAA,GAAA,CAAA;AAAA,YAAA,CAAA,GAAA,CAAA;AAAA,YAAA,CAAA,GAAA,CAAA;AAAA,YAAA,CAAA,GAAA,CAAA;AAAA,YAOF8L,CAAAA,GAASC,CAAAA,CAAAA,CAAAA,CAPP;AAQFD,QAAAA,CAAJ,IACEH,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CADEG;AAGAE,QAAAA,CAAJ,IAAcA,CAAAA,CAAd,CAAcA,CAAVA,GACF,CADF,GAAA,CAAIA,IAGJJ,EAAAA,CAAcvJ,CAAAA,CAAduJ,UAAAA,EAAAA,CAAAA,EAAAA,CAAAA,EARiD,CAQjDA,CAAAA,EARiD,CAAA,GAAA,KAP3C,CAYFI;AAZF;;AAAA,UAAA,CAAA,EADiE;AADb;AA4BxD;;AAAA,MAAIE,CAAAA,GAAc,IAAlB;;AAEgBvF,WAAAA,EAAAA,CAAY,CAAZA,EAAY,CAAZA,EAAY,CAAZA,EAAgC;AACzCuF,IAAAA,CAAL,KACEA,CADF,GACgBpK,MAAAA,CADhB,QACgBA,IAAsBA,MAAAA,CAAAA,QAAAA,CADtC,WAAA,CAAKoK;AAGDA,IAAAA,CAAJ,IAAA,YAAA,CAAIA,GACFA,CAAAA,CAAAA,eAAAA,CAAAA,CAAAA,EADF,CACEA,CADEA,IAGFtB,CAAAA,CAAAA,YAAAA,CAAAA,IAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,GACA,EAAA,CAAA,CAAA,EAR4C,CAQ5C,CAJEsB;AAkCCpF;;AAAAA,WAASA,EAATA,CAAmB,CAAnBA,EAAmB,CAAnBA,EAAgC;AACrC,QAAIzE,CAAAA,CAAJ,aAAIA,KAAJ,QAAA,EACE,OAAOuI,CAAAA,CAAAA,UAAAA,CAAAA,IAAAA,CAAAA,QAAAA,EAAAA,CAAAA,EAAAA,CAAAA,CAAP;AAEF,QAAI3H,CAAAA,GAAI2H,CAAAA,CAAAA,UAAAA,CAAAA,IAAAA,CAAAA,QAAAA,EAAAA,CAAAA,EAA8C,CAA9CA,CAAAA,CAAR;;AACA,QAAA,CAAA,EAAU;AACJ1F,MAAAA,CAAAA,GAAK7C,CAAAA,CAAAA,UAAL6C;AACKlF,MAAAA,CAAAA,GAAT,CAASA;;AAAT,WAAK,IAAL,CAAA,EAAkBA,CAAlB,GAAsBkF,CAAAA,CAAtB,MAAA,EAAiClF,CAAjC,EAAA,EACEmM,CACA,GADKrF,EAAAA,CAAW5B,CAAAA,CAAX4B,CAAW5B,CAAX4B,EAAkB,CAAlBA,CAAAA,CAALqF,EACA,CAAA,CAAA,WAAA,CAJM,CAIN,CADAA;AAIJ;;AAAA,WAZqC,CAYrC;;;;AGtVF,MAAIiE,CAAAA,GAAJ,EAAA;AAAA,MACIC,EADJ;;AAEOC,WAASA,EAATA,CAAgB,CAAhBA,EAA2B;AAC3BD,IAAAA,EAAL,KACEA,EACA,GADY,CAAA,CAAZA,ETuFYvM,EStFZ,CAFF,CAEE,CAFF,CAAKuM;AAILD,IAAAA,CAAAA,CAAAA,IAAAA,CALgC,CAKhCA;AAGKG;;AAAAA,WAASA,CAATA,GAAiB;AACtBF,IAAAA,EAAAA,GAAY,CAAA,CAAZA;;AAEA,SADA,IAAIG,CAAAA,GAAW,CAAA,CAAQJ,CAAAA,CAAAA,MACvB,EAAOA,CAAAA,CAAP,MAAA,GACEA,CAAAA,CAAAA,KAAAA;;AAEF,WANsB,CAMtB;AAGFG;;AAAAA,EAAAA,CAAAA,CAAAA,IAAAA,GAAgBH,CAAhBG;AFTA,MAAMnE,EAAAA,GAA6B,EAAnC;;AAQuBE,WAAAA,CAAAA,CAAQ,CAARA,EAAQ,CAARA,EAAQ,CAARA,EAA+B;AACpD,QAAIC,CAAJ,KAAA,EAAA,EACE,MAAM,IAAA,SAAA,CAAN,qBAAM,CAAN;AAIEvD,IAAAA,CAAAA,GAAavF,QAAAA,CAAAA,sBAAAA,EAAbuF;AACJA,IAAAA,CAAAA,CAAAA,SAAAA,GAAuBsD,CAAAA,CAAAA,SAAvBtD;AAC0BA,IAAAA,CAU1B0D,CAAAA,CAV0B1D,GF8DjBoB,WE9DiBpB;AF8DjBoB,IAAAA,CElDT,CFkDSA,CElDT,CFkDSA;AAAAA,IAAAA,CEjDT,CAb0BpB,CAa1B,CFiDSoB;AE9DiBpB,IAAAA,CAe1BlB,CAAAA,IAf0BkB,GAAAA,CAAAA;AAAAA,IAAAA,CAgB1B2D,CAAAA,CAhB0B3D,GAAwBwD,CAgBlDG,IAhBkDH,CAgB1BI,CAhBoB9E,IAAlBkB;AAAkBlB,IAAAA,CAiB5C8B,CAAAA,OAjB4C9B,GAAAA,CAiB7B8B,CAAfA,OAjB4C9B,IAAAA,EAAAA;AAAAA,IAAAA,CAkB5C8B,CAAAA,OAlB4C9B,CAkB5C8B,IAlB4C9B,GAAlBkB,CAAkBlB;AAAAA,IAAAA,CAmB5C8B,CAAAA,OAnB4C9B,CAmB5C8B,CAnB4C9B,GAmBlB,aAnBAkB,CAmBA,CAAA,CAAA,GAnBAA,CAmBA,GAnBAA,IAAkBlB;AAAlBkB,IAAAA,CAqB1B6D,CAAAA,CArB0B7D,GAqBJ,CArBIA,CAAAA;AAAAA,IAAAA,CAuB1B8D,CAAAA,CAvB0B9D,GAAAA,EAAAA;AAAAA,IAAAA,CAwB1B+D,CAAAA,CAxB0B/D,GAAAA,EAAAA;AAAAA,IAAAA,CAyB1BgE,CAAAA,CAzB0BhE,GAyBJ,EAzBIA;AA2BtB9D,IAAAA,CAAAA,GAAKW,CAAAA,CAAAA,UAAAA,CA3BmCiC,CA2BnCjC,CAALX;;AACJ,SAtBkD,IAsBzClF,CAAAA,GAtByC,CAAA,EAsBpCoF,CAAAA,GAAEF,CAAAA,CAAhB,MAAA,EAA2BlF,CAA3B,GAAA,CAAA,EAAkCA,CAAlC,EAAA,EACE0G,CAAAA,CAAAA,WAAAA,CAAAA,IAAAA,CA7B0CoB,CA6B1CpB,EAAuBxB,CAAAA,CA5BzB,CA4ByBA,CAAvBwB;;AA5BF,WAToD,CASpD;AAGF4F;;AAAAA,EAAAA,CAAAA,CAAAA,SAAAA,GAAsBpK,MAAAA,CAAAA,MAAAA,CAAcuK,gBAAAA,CAAdvK,SAAAA,CAAtBoK;;AA8BmCW,WAAAA,CAAAA,CAAAA,CAAAA,EAAW;AACvC,IAAA,CAAA,CAAL,CAAK,KACH,CAAA,CAAA,CAAA,GAAsB,CAAA,CAAtB,EE5DYqD,EF6DZ,CAAQ,YAAM;AAAA,aAAA,EAAA,CAH4B,CAG5B,CAAA;AAH4B,KAG1C,CAFG;AADuC;;AAmChBnD,WAAAA,EAAAA,CAAAA,CAAAA,EAAW;AAxBvC,SAFA,IAAID,CAEJ,EAAA,CAAA,GAAa;AACPzK,MAAAA,CAAAA,CAAJ,CAAIA,KACFyK,CADF,GAAA,CAAIzK;;AAU0C,MAAA,CAAA,EAAA;AAPvCA,YAAAA,CAAAA,GAAAA,CAAAA;AAQLA,QAAAA,CAAAA,GAAO,CAAA,CAAA,IAAA,CAAA,WAAA,EAAPA;AACJ,YP1EcH,CO0EV,CAAJ,CAAI,CAAJ,EAEE,KADA,IAAI4C,CAAAA,GAAK,CAAA,CAAA,IAAA,CAAT,UAAA,EACSlF,CAAAA,GAAT,CAAA,EAAiBA,CAAjB,GAAqBkF,CAAAA,CAArB,MAAA,EAAgClF,CAAhC,EAAA,EAEE,IADA0I,CA+MKqC,GA/MD7F,CAAAA,CAAAA,CAAAA,CAAJwD,EA+MKqC,UA9MsBrC,CA8MtBqC,CA9ML,SAAA,EACE,MAP0C,CAO1C;AAP0C,QAAA,CAAA,GAAA,KAAA,CAAA;AAXnC;AA0BTtI;;AAAAA,IAAAA,CAAJ,IACEA,CAAAA,CAHqC,WAGrCA,EADEA;AAFmC;;AAQzC6J,EAAAA,CAAAA,CAAAA,SAAAA,CAAAA,WAAAA,GAAqC,YAAW;AAC9C,SAAA,CAAA,GAAsB,CAAA,CAAtB;AAOAgB,IAAAA,EAAAA,CANAF,IAMAE,CAAAA;;AAEA,SAH2C,IAGlCtN,CAAAA,GAHkC,CAAA,EAG3C,CAAA,EAAoBA,CAApB,GARAoN,KAQwBN,CARxBM,CAQA,MAAA,EAA+CpN,CAA/C,EAAA,EAAoD;AAClDuN,MAAAA,CAAAA,GATFH,KASSN,CATTM,CASSN,CATTM,CASEG;AAwFF,UAAIvK,CAAAA,GAAKuK,CAAAA,CAAAA,OAAAA,CAAAA,aAAT;AACAA,MAAAA,CAAAA,CAAAA,OAAAA,CAAAA,aAAAA,GAA6B,EAA7BA;AACAA,MAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,GAA8B,EAA9BA;AAEA,UADAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,GAAwCvK,CACxC,EACE,KAAK,IAAIhD,CAAAA,GAAT,CAAA,EAAcA,CAAd,GAAkBgD,CAAAA,CAAlB,MAAA,EAA6BhD,CAA7B,EAAA,EAAkC;AAChC,YAAIiD,CAAAA,GAAID,CAAAA,CAAAA,CAAAA,CAAR;AACAC,QAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,GAA8BA,CAAAA,CAAAA,OAAAA,CAAAA,YAA9BA;AAIIA,QAAAA,CAAAA,CAAAA,OAAAA,CAAJ,YAAIA,KAAJ,CAAIA,KACFA,CAAAA,CAAAA,OAAAA,CADF,YACEA,GAP8B,IAM5BA;AApG4C;AAKpD;;AAAA,SAASA,CAAT,GAbAmK,KAaWtF,IAbXsF,CAaA,UAAA,EAAA,CAAA,EAAoCnK,CAApC,GAAsCA,CAAAA,CAAtC,WAAA,EACEuK,EAAAA,CAdFJ,IAcEI,EAAAA,CAAAA,CAAAA;;AAGF,SAASxN,CAAT,GAAA,CAAA,EAAoBA,CAApB,GAjBAoN,KAiBwBN,CAjBxBM,CAiBA,MAAA,EAA+CpN,CAA/C,EAAA,EAAoD;AAClDuN,MAAAA,CAAAA,GAlBFH,KAkBSN,CAlBTM,CAkBSN,CAlBTM,CAkBEG;AAEA,UAAI,CAACA,CAAAA,CAAAA,OAAAA,CAAAA,aAAAA,CAAL,MAAA,EACE,KAAStK,CAAT,GAAWsK,CAAAA,CAAX,UAAA,EAAA,CAAA,EAA+BtK,CAA/B,GAAiCA,CAAAA,CAAjC,WAAA,EACE,EAAA,CAtBNmK,IAsBM,EAAA,CAAA,EAAA,CAAA,CAAA;AAGEK,MAAAA,CAAAA,GAAaF,CAAAA,CAAAA,UAAbE;AAEN,OADMC,CACN,GADuBD,CAAAA,CAAAA,OAAAA,IAAsBA,CAAAA,CAAAA,OAAAA,CAAAA,IAC7C,KAAsBpC,EAAAA,CAAtB,CAAsBA,CAAtB,IACEqC,CAAAA,CAAAA,WAAAA,EADF;AAGAC,MAAAA,EAAAA,CA9BFP,IA8BEO,EAAkCJ,CAAAA,CAAAA,OAAAA,CAAlCI,CAAAA,EACEJ,CAAAA,CAAAA,OAAAA,CADFI,aAAAA,CAAAA;;AAGA,UADIC,CACJ,GADwBL,CAAAA,CAAAA,OAAAA,CAAAA,CACxB,EAAuB;AACrB,aAASvN,CAAT,GAAA,CAAA,EAAcA,CAAd,GAAkB4N,CAAAA,CAAlB,MAAA,EAA4C5N,CAA5C,EAAA,EACE4N,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,GAAiD,IAAjDA;;AAEFL,QAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,GAAwC,IAAxCA;AAEIK,QAAAA,CAAAA,CAAJ,MAAIA,GAA2BL,CAAAA,CAAAA,OAAAA,CAAAA,aAAAA,CAA/B,MAAIK,KACFL,CAAAA,CAAAA,OAAAA,CADF,CACEA,GAAqB,CAPF,CAMjBK;AAQFL;;AAAAA,MAAAA,CAAAA,CAAAA,OAAAA,CAAJ,CAAIA,KACFA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,GAAqB,CAAA,CAArBA,EACA,EAAA,CAjDJH,IAiDI,EAhCgD,CAgChD,CAFEG;AAiGAzC;;AAAAA,IAAAA,CAAAA,GA/INuC,KA+IcP,CAARhC;AACFqD,IAAAA,CAAAA,GAAc,EAAdA;;AACJ,SAASnO,CAAT,GAAA,CAAA,EAAcA,CAAd,GAAkB8K,CAAAA,CAAlB,MAAA,EAAgC9K,CAAhC,EAAA,EACQuK,CAON,GAPeO,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,UAATP,EAOAA,CAAAA,CAAN,OAAMA,IAAkBA,CAAAA,CAAAA,OAAAA,CAAxB,IAAMA,IACJ,EAAA,IAAA,CAAA,CAAA,OAAA,CADF,CACE,CAAA,CADIA,IAEJ4D,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CATI5D;;AAYR,SAASvK,CAAT,GAAA,CAAA,EAAcA,CAAd,GAAkBmO,CAAAA,CAAlB,MAAA,EAAsCnO,CAAtC,EAAA,EAA2C;AACnCqC,MAAAA,CAAAA,GAAO8L,CAAAA,CAAAA,CAAAA,CAAP9L;AACa+L,MAAAA,CAAAA,GAAAA,CAAAA,KAhKrBf,IAgKqBe,GAhKrBf,KAgKqBe,IAAAA,GAA4B/L,CAA5B+L;AAOjBhI,MAAAA,CAAAA,GAAW,EAAXA;AACAlB,MAAAA,CAAAA,GAPmD7C,CAO9CwD,CAAAA,UAALX;;AACJ,WAAK,IAAIlF,CAAAA,GAAT,CAAA,EAAgBA,CAAhB,GAAoBkF,CAAAA,CAApB,MAAA,EAA+BlF,CAA/B,EAAA,EAAoC;AAClC,YAAIqF,CAAAA,GAAQH,CAAAA,CAAAA,CAAAA,CAAZ;;AAIA,YAAA,UAA2BG,CAcpB0F,CAdP,SAAA,EAAmC;AAC7BsD,UAAAA,CAAAA,GAAiBhJ,CAAAA,CAAAA,OAAAA,CAAAA,CAAjBgJ;;AACJ,eAAK,IAAIpO,CAAAA,GAAT,CAAA,EAAgBA,CAAhB,GAAoBoO,CAAAA,CAApB,MAAA,EAA2CpO,CAA3C,EAAA,EAEImG,CAAAA,CAAAA,IAAAA,CADoBiI,CAAAA,CAHS,CAGTA,CACpBjI;AAJN,SAAA,MAOEA,CAAAA,CAAAA,IAAAA,CAZgC,CAYhCA;AAeezB;;AAAAA,MAAAA,CAAAA,GAAAA,KAHfwG,CAGexG;AAHfwG,MAAAA,CAAAA,GAAWtF,CAAAA,CAAAA,UAAAA,CAAAA,CAAAA,CAAXsF;AACA5J,MAAAA,CAAAA,GRlEGV,EAAAA,CAAAA,CAAAA,EQkEwBuF,CRlEA5F,CAAxBK,MAAAA,EAAAA,CAAAA,EQkEkCsK,CRjEjB3K,CADjBK,MAAAA,CQkEHU;;AAEJ,WAJoE,IAItD+M,CAAAA,GAALtO,CAAKsO,GAAd,CAAA,EAAuBtO,CAAvB,GAAyBuB,CAAAA,CAAzB,MAAuBvB,KAAsB2E,CAA7C,GAA+CpD,CAAAA,CAA/C,CAA+CA,CAAxBvB,CAAvB,EAA4DA,CAA5D,EAAA,EAAiE;AAC/D,aAD+D,IACtDC,CAAAA,GADsD,CAAA,EAC/D,CAAA,EAAkBA,CAAlB,GAAsB0E,CAAAA,CAAAA,CAAAA,CAAtB,MAAkB1E,KAA0BgD,CAA5C,GAA8C0B,CAAAA,CAAAA,CAAAA,CAA9C,CAA8CA,CAA5B1E,CAAlB,EAA6DA,CAA7D,EAAA,EAKM+E,CAAAA,CAAAA,UAAAA,CAAAA,CAAAA,MAAkBiF,CAAlBjF,IACF0B,CAAAA,CAAAA,WAAAA,CAAAA,IAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CADE1B,EAGJ,CAAA,CAAA,MAAA,CAAgBL,CAAAA,CAAhB,KAAgBA,GAAhB,CAAA,EAAA,CAAA,CAHIK;;AAKNsJ,QAAAA,CAAAA,IAAK3J,CAAAA,CAX0D,CAW/D2J;AAGF;;AAAA,WAAStO,CAAT,GAAA,CAAA,EAAwBA,CAAxB,GAA0BuB,CAAAA,CAA1B,MAAwBvB,KAAsB2E,CAA9C,GAAgDpD,CAAAA,CAAhD,CAAgDA,CAAxBvB,CAAxB,EAA6DA,CAA7D,EAAA,EAEE,KADAuO,CACStO,GADFkL,CAAAA,CAASxG,CAAAA,CAATwG,KAAAA,CAAPoD,EACStO,CAAAA,GAAE0E,CAAAA,CAAX,KAAA,EAAuB1E,CAAvB,GAA2B0E,CAAAA,CAA3B,KAA2BA,GAAUA,CAAAA,CAArC,CAAA,EAAmD1E,CAAnD,EAAA,EACEgD,CAEA,GAFImD,CAAAA,CAAAA,CAAAA,CAAJnD,EACAwD,CAAAA,CAAAA,YAAAA,CAAAA,IAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,CADAxD,EAEA,CAAA,CAAA,MAAA,CAAA,CAAA,EAAA,CAAA,EAzDuC,CAyDvC,CAFAA;AAxN0C;AAkEJ,GAlE5CqJ;;AAkE4C,WAAA,EAAA,CAAA,CAAA,EAAQ,CAAR,EAAQ,CAAR,EAA2B;AACrEjK,IAAAA,CAAAA,CAAAA,OAAAA,GAAeA,CAAAA,CAAfA,OAAeA,IAAgB,EAA/BA;AACA,QAAIwL,CAAAA,GAAUxL,CAAAA,CAAAA,OAAAA,CAAAA,CAAd;AACAA,IAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,GAAiC,IAAjCA;AAEKkL,IAAAA,CAAL,KAGEA,CAHF,GAAA,CAEQ5B,CAFR,GAEe,CAAA,CAAA,CAAA,CADFtJ,CAAAA,CAAAA,IAAAA,IAnKOgK,YAoKL,CAFf,KAGiBV,CAAAA,CAHjB,CAGiBA,CAHjB,CAAK4B;AAKDA,IAAAA,CAAJ,IACEA,CAAAA,CAAAA,OAAAA,CAAAA,aAAAA,CAAAA,IAAAA,CAAAA,CAAAA,GACA,CAAA,CAAA,OAAA,CAAA,YAAA,GAFF,CAAA,IAIElL,CAAAA,CAAAA,OAAAA,CAJF,YAIEA,GAA4Bf,KAAAA,CAJ1BiM;AAMAM,IAAAA,CAAJ,KAAgBxL,CAAAA,CAAAA,OAAAA,CAAhB,YAAIwL,IACExL,CAAAA,CAAAA,OAAAA,CADN,YAAIwL,KAEAxL,CAAAA,CAAAA,OAAAA,CAAAA,YAAAA,CAAAA,OAAAA,CAFJ,CAEIA,GAA0C,CAlBuB,CAgBjEwL;AAmC6CC;;AAAAA,WAAAA,EAAAA,CAAAA,CAAAA,EAAQ,CAARA,EAAQ,CAARA,EAA8B;AAC/E,SAD+E,IACtE9N,CAAAA,GADsE,CAAA,EAC/E,CAAA,EAAkBA,CAAlB,GAAoB+N,CAAAA,CAApB,MAAkB/N,KAAuBiD,CAAzC,GAA2C8K,CAAAA,CAA3C,CAA2CA,CAAzB/N,CAAlB,EAAyDA,CAAzD,EAAA,EACE,IAAA,UAAIiD,CAAAA,CAAJ,SAAA,EAA2B;AACzB,UAAM+K,CAAAA,GAAiB/K,CAAAA,CAAAA,OAAAA,CAAAA,aAAvB;AACI+K,MAAAA,CAAJ,IAAsBA,CAAAA,CAAtB,MAAIA,IACFL,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAHuB,CAGvBA,CADEK;AAFN,KAAA,MAME5C,CAAAA,CAAAA,IAAAA,CAAe2C,CAAAA,CAR4D,CAQ5DA,CAAf3C;AAR2E;;AAa3C6C,WAAAA,EAAAA,CAAAA,CAAAA,EAAQ,CAARA,EAAe;AAInD5G,IAAAA,CAAAA,CAAAA,aAAAA,CAAAA,IAAAA,CAAAA,CAAAA,EAAyB,IAAA,KAAA,CAAzBA,YAAyB,CAAzBA;AACIkG,IAAAA,CAAAA,CAAAA,OAAAA,CAAJ,YAAIA,IACFW,EAAAA,CAAAA,CAAAA,EAAqBX,CAAAA,CAAAA,OAAAA,CAN4B,YAMjDW,CADEX;AA4F+BiB;;AAAAA,WAAAA,EAAAA,CAAAA,CAAAA,EAAW;AAC9C,QAAI,CAAA,CAAA,CAAA,CAAJ,MAAA,EAAgC;AAYhC,WAXiBxB,IAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAWRhN,CAAAA,GAAT,CAAA,EAAcA,CAAd,GAAkB8K,CAAAA,CAAlB,MAAA,EAAgC9K,CAAhC,EAAA,EAAqC;AACnC,YAAIuN,CAAAA,GAAOzC,CAAAA,CAAAA,CAAAA,CAAX;AAMAyC,QAAAA,CAAAA,CAAAA,OAAAA,GAAeA,CAAAA,CAAfA,OAAeA,IFtQRnD,EEsQPmD;AFtQOnD,QAAAA,CEuQP,CFvQOA,CEuQP,CFvQOA;AAAAA,QAAAA,CEwQP,CAAiBmD,CAAAA,CAAjB,UAAA,CFxQOnD;AEyQP,YAAIsE,CAAAA,GAAOC,EAAAA,CArBXF,CAqBWE,CAAX;AArBAF,QAAAA,CAsBI1B,CAAAA,CAtBJ0B,CAsBA,CAtBAA,KAuBEG,CAEA,GAFkBA,CAElB,IAFqC,EAArCA,EACAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAwB,CAAA,CADxBA,EAvBFH,CAyBE,CAAA,CAzBFA,CAyBE,CAzBFA,EAyBE,IAzBFA,CAsBA,CAtBAA,CAAAA,IAAAA,CA2BE1B,CAAAA,CA3BF0B,CAsBA,CAtBAA,IA2BwB,CA3BxBA,CA2BwB,CA3BxBA;AAAAA,QAAAA,CA6BA3B,CAAAA,CA7BA2B,CA6BA3B,IA7BA2B,CAWmC,CAXnCA;AA+BF;;AAAA,UAAA,CAAA,EACE,KAAKxL,IAAL,CAAA,IAAA,CAAA,EAhCAwL,CAiCE1B,CAAAA,CAjCF0B,CAiCE1B,CAjCF0B,IAiCqBI,EAAAA,CAjCrBJ,CAiCqC1B,CAAAA,CAjCrC0B,CACA,CADAA,CAiCqBI,CAjCrBJ;AACA,MAAA,CAAA,CAAA,CAAA,GAF8B,EAE9B;AAH4C;AAwCbK;;AAAAA,WAAAA,EAAAA,CAAQ,CAARA,EAAe;AAChD,QAAMJ,CAAAA,GAAOnB,CAAAA,CAAPmB,IAAOnB,IAAgBA,CAAAA,CAAAA,YAAAA,CAAvBmB,MAAuBnB,CAAhBA,IAvWOlB,YAuWpB;AACAkB,WAAAA,CAAAA,CAAAA,CAAAA,GAFgD,CAEhDA;AAFgD;;AAUjBwB,WAAAA,EAAAA,CAAQ,CAARA,EAAgB;AAI/C,WAAOjE,CAAAA,CAAAA,IAAAA,CAAW,UAAA,CAAA,EAAA,CAAA,EAAU;AACtBkE,MAAAA,CAAAA,GAAQC,EAAAA,CAAAA,CAAAA,CAARD;;AAEJ,WADA,IAAIE,CAAAA,GAAQD,EAAAA,CAAZ,CAAYA,CAAZ,EACSjP,CAAAA,GAAT,CAAA,EAAcA,CAAd,GAAkBgP,CAAAA,CAAlB,MAAA,EAAgChP,CAAhC,EAAA,EAAqC;AAC/BmP,QAAAA,CAAAA,GAAKH,CAAAA,CAAAA,CAAAA,CAALG;AACJ,YAAIC,CAAAA,GAAKF,CAAAA,CAAAA,CAAAA,CAAT;AACA,YAAIC,CAAJ,KAAA,CAAA,EACMjK,OAAAA,CACG,GADEnF,KAAAA,CAAAA,IAAAA,CAAWoP,CAAAA,CAAAA,UAAAA,CAAXpP,UAAAA,CAALmF,EACG,CAAA,CAAA,OAAA,CAAA,CAAA,IAAiBA,CAAAA,CAAAA,OAAAA,CALS,CAKTA,CADpBA;AAPkB;AAJmB,KAIxC4F,CAAP;AAcFmE;;AAAAA,WAASA,EAATA,CAAqB,CAArBA,EAA4B;AAC1B,QAAII,CAAAA,GAAY,EAAhB;;AACA,OACEA,CAAAA,CAAAA,OAAAA,CADF,CACEA,EADF,QAEUhN,CAFV,GAEiBA,CAAAA,CAFjB,UAAA;;AAGA,WAL0B,CAK1B;AAgEuCsN;;AAAAA,WAAAA,EAAAA,CAAAA,CAAAA,EAAW;AAClDrC,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA;AACA,WAAO,CAAA,CAAQ,CAAA,CAAA,CAAA,CAFmC,MAElD;AAGFhB;;AAAAA,EAAAA,CAAAA,CAAAA,SAAAA,CAAAA,gBAAAA,GAAuCsD,UAAQ,CAARA,EAAQ,CAARA,EAAQ,CAARA,EAAqC;AAC1E,iBAAI,OAAJ,CAAA,KACEC,CADF,GACqB;AACjBC,MAAAA,OAAAA,EAAS,CAAA,CAFb;AACqB,KADrB;AAKAD,IAAAA,CAAAA,CAAAA,CAAAA,GAAiC,IAAjCA;AACA,SAAA,IAAA,CAAA,gBAAA,CAAA,CAAA,EAAA,CAAA,EAP0E,CAO1E;AAGFE,GAVAzD;;GAUAyD,CAAAA,S,CAAAA,mB,GAA0CC,UAAQ,CAARA,EAAQ,CAARA,EAAQ,CAARA,EAAqC;AAC7E,iBAAI,OAAJ,CAAA,KACEH,CADF,GACqB;AACjBC,MAAAA,OAAAA,EAAS,CAAA,CAFb;AACqB,KADrB;AAKAD,IAAAA,CAAAA,CAAAA,CAAAA,GAAiC,IAAjCA;AACA,SAAA,IAAA,CAAA,mBAAA,CAAA,CAAA,EAAA,CAAA,EAP6E,CAO7E;AAGFvD,G;;AAAAA,EAAAA,CAAAA,CAAAA,SAAAA,CAAAA,cAAAA,GAAqC2D,UAAQ,CAARA,EAAa;AD7OlCvE,WAAAA,CC8OD,CAAA,IAAA,EAAqB,UAAQ,CAAR,EAAY;AAC5C,aAAOzI,CAAAA,CAAP,EAAOA,IADqC,CAC5C;AADW,KAAA,EAEV,UAAQ,CAAR,EAAY;AACb,aAAO,CAAA,CADM,CACb;AAHW,KAAA,CD9OCyI,CC8OD,CD9OCA,KC6OkC,ID7OlCA;ACoQSqE,GAvBzBzD;;AAuByByD,MAAAA,EAAAA,GAAAA,CAAAA,CH7FvB5G,SG6FuB4G;AH7FvB5G,EAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,EAA2C,CAA3CA,CAAAA,CAAAA;AACAA,EAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA,EAAiD,CAAjDA,CAAAA,CAAAA;;AMxaIsH,WAAAA,EAAAA,GAEU;AACZ,SAAA,CAAA,GAAkB,CAAA,CAAlB;AACA,SAAA,UAAA,GAAkB,EAAlB;AACA,SAAA,YAAA,GAAoB,EAApB;AACA,SAAA,CAAA,GAAiB,IAJL,GAIK,EAAjB;AAGFC;;AAAAA,WAAAA,EAAAA,CAAAA,CAAAA,EAAW;AACJ,IAAA,CAAA,CAAL,CAAK,KACH,CAAA,CAAA,CAAA,GAAkB,CAAA,CAAlB,EViFU5M,EUhFV,CAAgB,YAAM;AACpByM,MAAAA,EAAAA,CAJK,CAILA,CAAAA;AAJK,KAGP,CAFG;AAQPA;;AAAAA,WAAAA,EAAAA,CAAAA,CAAAA,EAAQ;AACN,QAAI,CAAA,CAAJ,CAAA,EAAqB;AACnB,MAAA,CAAA,CAAA,CAAA,GAAkB,CAAA,CAAlB;AACA,UAAII,CAAAA,GAAY,CAAA,CAAA,WAAA,EAAhB;AACIA,MAAAA,CAAAA,CAAJ,MAAIA,IACF,CAAA,CAAA,CAAA,CAAA,OAAA,CAAuB,UAAQ,CAAR,EAAa;AAClCC,QAAAA,CAAAA,CADkC,CAClCA,CAAAA;AALe,OAIjB,CADED;AAJA;AAYR;;AAAA,EAAA,EAAA,CAAA,SAAA,CAAA,WAAA,GAAA,YAAc;AACZ,QAAI,KAAA,UAAA,CAAJ,MAAI,IAA0B,KAAA,YAAA,CAA9B,MAAA,EAAwD;AACtD,UAAIA,CAAAA,GAAY,CAAC;AACfE,QAAAA,UAAAA,EAAY,KADG,UAAA;AAEfC,QAAAA,YAAAA,EAAc,KAFA;AAAC,OAAD,CAAhB;AAIA,WAAA,UAAA,GAAkB,EAAlB;AACA,WAAA,YAAA,GAAoB,EAApB;AACA,aAPsD,CAOtD;AAEF;;AAAA,WAVY,EAUZ;AAUyB,GApB3B;;AAoB2B,WAAA,EAAA,CAAQ,CAAR,EAAQ,CAAR,EAAyB;AACpDzO,IAAAA,CAAAA,CAAAA,OAAAA,GAAeA,CAAAA,CAAfA,OAAeA,IAAgB,EAA/BA;AACKA,IAAAA,CAAAA,CAAAA,OAAAA,CAAL,CAAKA,KACHA,CAAAA,CAAAA,OAAAA,CADF,CACEA,GAAwB,IAD1B,EAC0B,EADrBA;;AAGLA,IAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA;;AACA,QAAIkJ,CAAAA,GAAWlJ,CAAAA,CAAAA,OAAAA,CAAAA,CAAf;AACA,WAAO;AACL2O,MAAAA,CAAAA,EADK,CAAA;AAELC,MAAAA,CAAAA,EAFK,CAAA;AAGLC,MAAAA,CAAAA,EAHK,CAAA;AAIL,MAAA,WAAA,EAAA,YAAc;AACZ,eAAO3F,CAAAA,CADK,WACLA,EAAP;AAZgD;AAO7C,KAAP;AAU6B4F;;AAAAA,WAAAA,EAAAA,CAAQ,CAARA,EAAiB;AAC9C,QAAI5F,CAAAA,GAAW6F,CAAX7F,IAAqB6F,CAAAA,CAAAA,CAAzB;AACI7F,IAAAA,CAAJ,KACEA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAA0B6F,CAAAA,CAA1B7F,CAAAA,GACKA,CAAAA,CAAAA,CAAAA,CAAL,IAAKA,KACH6F,CAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CADF,CACEA,GAL0C,IAIvC7F,CAFP,CAAIA;AAF0C;;AAUzC8F,WAASA,EAATA,CAAwB,CAAxBA,EAAwB,CAAxBA,EAA4C;AAEjD,QAAMC,CAAAA,GAAiBvO,CAAAA,CAAAA,WAAAA,EAAvB;AACA,WAAO4N,CAAAA,CAAAA,GAAAA,CAAc,UAAQ,CAAR,EAAmB;AAEtC,UAAMY,CAAAA,GAAmBD,CAAnBC,KAAsCC,CAAAA,CAAAA,MAAAA,CAAAA,WAAAA,EAA5C;;AACA,UAAID,CAAJ,IAAuBC,CAAAA,CAAvB,UAAA,EAIE;AAAA,YAHI1L,CAGAtF,GAHQT,KAAAA,CAAAA,IAAAA,CAAWyR,CAAAA,CAAXzR,UAAAA,EAAAA,MAAAA,CAAuC,UAAQ,CAAR,EAAY;AAC7D,iBAAQuR,CAAR,KAA2BrO,CAAAA,CADkC,WAClCA,EAA3B;AADUlD,SAAAA,CAAR+F,EAGAtF,CAAAA,CAAJ,MAAA,EACEgR,OAAAA,CAKOA,GALItP,MAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAXsP,EACAtP,MAAAA,CAAAA,cAAAA,CAAAA,CAAAA,EAAAA,YAAAA,EAA8C;AAC5CuP,UAAAA,KAAAA,EAD4C,CAAA;AAE5CtJ,UAAAA,YAAAA,EAAc,CAFhBjG;AAA8C,SAA9CA,CADAsP,EADF,CACEA;AALJ,OAAA,MAYO,IAAA,CAAA,EACL,OAhBoC,CAgBpC;AAhBGb,KAAAA,EAAAA,MAAAA,CAkBG,UAAQ,CAAR,EAAY;AAAE,aAAF,CAAE;AArByB,KAG1CA,CAAP;;;;AC3EF,MAAoBe,CAAAA,GAAAA,oBAAsCC,IAAAA,CAA1D,GAA0DA,EAA1D;AAAA,MAGIC,EAAAA,GAAiB;AACnB,IAAA,IAAA,EAAQ,CADW,CAAA;AAEnB,IAAA,KAAA,EAAS,CAFU,CAAA;AAGnB,IAAA,OAAA,EAAW,CAHQ,CAAA;AAInB,IAAA,QAAA,EAAY,CAJO,CAAA;AAKnB,IAAA,KAAA,EAAS,CALU,CAAA;AAMnB,IAAA,QAAA,EAAY,CANO,CAAA;AAOnB,IAAA,SAAA,EAAa,CAPM,CAAA;AAQnB,IAAA,UAAA,EAAc,CARK,CAAA;AASnB,IAAA,UAAA,EAAc,CATK,CAAA;AAUnB,IAAA,SAAA,EAAa,CAVM,CAAA;AAWnB,IAAA,QAAA,EAAY,CAXO,CAAA;AAYnB,IAAA,SAAA,EAAa,CAZM,CAAA;AAanB,IAAA,OAAA,EAAW,CAbQ,CAAA;AAcnB,IAAA,KAAA,EAAS,CAdU,CAAA;AAenB,IAAA,WAAA,EAAe,CAfI,CAAA;AAgBnB,IAAA,KAAA,EAAS,CAhBU,CAAA;AAiBnB,IAAA,OAAA,EAAW,CAjBQ,CAAA;AAkBnB,IAAA,KAAA,EAAS,CAlBU,CAAA;AAmBnB,IAAA,gBAAA,EAAoB,CAnBD,CAAA;AAoBnB,IAAA,iBAAA,EAAqB,CApBF,CAAA;AAqBnB,IAAA,cAAA,EAAkB,CArBC,CAAA;AAsBnB,IAAA,UAAA,EAAc,CAtBK,CAAA;AAuBnB,IAAA,QAAA,EAAY,CAvBO,CAAA;AAwBnB,IAAA,SAAA,EAAa,CAxBM,CAAA;AAyBnB,IAAA,WAAA,EAAe,CAzBI,CAAA;AA0BnB,IAAA,WAAA,EAAe,CA1BI,CAAA;AA2BnB,IAAA,YAAA,EAAgB,CA3BG,CAAA;AA4BnB,IAAA,WAAA,EAAe,CA5BI,CAAA;AA6BnB,IAAA,WAAA,EAAe,CA7BI,CAAA;AA8BnB,IAAA,SAAA,EAAa,CA9BM,CAAA;AA+BnB,IAAA,aAAA,EAAiB,CA/BE,CAAA;AAgCnB,IAAA,UAAA,EAAc,CAhCK,CAAA;AAiCnB,IAAA,YAAA,EAAgB,CAjCG,CAAA;AAkCnB,IAAA,iBAAA,EAAqB,CAlCF,CAAA;AAmCnB,IAAA,kBAAA,EAAsB,CAnCH,CAAA;AAoCnB,IAAA,SAAA,EAAa,CApCM,CAAA;AAqCnB,IAAA,IAAA,EAAQ,CArCW,CAAA;AAsCnB,IAAA,SAAA,EAAa,CAtCM,CAAA;AAuCnB,IAAA,SAAA,EAAa,CAvCM,CAAA;AAwCnB,IAAA,QAAA,EAAY,CAxCO,CAAA;AAyCnB,IAAA,IAAA,EAAQ,CAzCW,CAAA;AA0CnB,IAAA,OAAA,EAAW,CA1CQ,CAAA;AA2CnB,IAAA,WAAA,EAAe,CA3CI,CAAA;AA4CnB,IAAA,UAAA,EAAc,CA5CK,CAAA;AA6CnB,IAAA,WAAA,EAAe,CA7CI,CAAA;AA8CnB,IAAA,QAAA,EAAY,CA9CO;AAAA,GAHrB;;AAoDAC,WAASA,EAATA,CAAqB,CAArBA,EAAqB,CAArBA,EAA2C;AACzC,QAAIC,CAAAA,GAAJ,EAAA;AAAA,QACIrR,CAAAA,GAAUsR,CADd;;AAGA,SADIC,CACJ,GADgBD,CAAAA,KAAAA,MAAAA,GAAAA,MAAAA,GAAgCA,CAAAA,CAAAA,WAAAA,EAChD,EAAA,CAAA,GACED,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,GAEE,CAAA,GADErR,CAAAA,CAAJ,YAAIA,GACQA,CAAAA,CADZ,YAAIA,GAEOA,CAAAA,CAAJ,QAAIA,KAAqB0B,IAAAA,CAAzB,sBAAI1B,IAAoDA,CAAAA,CAAxD,IAAIA,KAAqE0K,CAAzE,IAAqF1K,CAArF,KAAA,CAAIA,IACCA,CAAAA,CADL,IAAIA,GAGCA,CAAAA,CAAAA,UANZqR;;AAUEA,IAAAA,CAAAA,CAAaA,CAAAA,CAAbA,MAAaA,GAAjB,CAAIA,CAAAA,KAAJ,QAAIA,IACFA,CAAAA,CAAAA,IAAAA,CAAAA,MAAAA,CADEA;AAGJ,WAlByC,CAkBzC;AAlByC;;AAqB3CG,WAASA,EAATA,CAAiB,CAAjBA,EAAiB,CAAjBA,EAAiC;AAC/B,QAAI,CXpEU3P,CWoEd,EACE,OAAO4P,CAAP;AAIEC,IAAAA,CAAAA,GAAcN,EAAAA,CAAAA,CAAAA,EAAsB,CAAtBA,CAAAA,CAAdM;;AAEJ,SAR+B,IAQtBnS,CAAAA,GARsB,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAQ/B,CAAA,EAAiDA,CAAjD,GADSoS,CAC4C5R,CAArD,MAAA,EAAgER,CAAhE,EAAA,EAOE,IANAqS,CAMI,GARGD,CAEI,CAAA,CAAA,CAAXC,EACA5P,CAKI,GALG4P,CAAAA,KAAAA,MAAAA,GAAAA,MAAAA,GAA+BA,CAAAA,CAAAA,WAAAA,EADtCA,EAEI5P,CAIA,KAJS6P,CAAT7P,KACF8P,CACA,GADUJ,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAVI,EACA,CAAA,GAAW9P,CAFTA,CAFJ4P,EAMI,CXlFQ/P,CWkFP,CAAD,CAAC,CAAD,IAAuC,CAAvC,CAAuC,GAA3C,CAAA,EACE,OAhB2B,CAgB3B;AAhB2B;;AAqBjC,MAAIkQ,EAAAA,GAAa;AAKXrH,QAAAA,QAAAA,GAAW;AAEU,OAAvB,CAAuB,KAAnB,KAAJ,SAAuB,IAA6B7J,KAApD,CAAoDA,KAApB,KAAhC,CAAuB,KACrB,KADF,CACE,GAAkBsQ,EAAAA,CAAe,KADnC,IACoBA,CADG;AAGvB,aAAO,KAAP,CAAO,IAAmB,CALb,CAKb;AAVa,KAAA;;AAgBf,IAAA,YAAA,EAAA,YAAe;AACR,WAAL,CAAK,KACH,KADF,CACE,GAAsBC,EAAAA,CAAa,KAAbA,QAAAA,EAA+B,KADvD,QACwBA,CADnB;AAGL,aAAO,KAJM,CAIb;AApBa,KAAA;;AA0BX9O,QAAAA,MAAAA,GAAS;AACX,aAAOkP,EAAAA,CAAS,KAATA,aAAAA,EAA6B,KADzB,YACyB,EAA7BA,CAAP;AA3Ba,KAAA;;AAkCXQ,QAAAA,aAAAA,GAAgB;AAClB,UAAI,CAAC,KAAL,CAAA,EACE,OAAO,IAAP;AAEG,WAAL,CAAK,KACH,KADF,CACE,GAAmCZ,EAAAA,CAAa,KAAbA,CAAAA,EAAmC,CADxE,CACqCA,CADhC;AAIL,aAAOI,EAAAA,CAAS,KAATA,aAAAA,EAA6B,KARlB,CAQXA,CAAP;AA1Ca,KAAA;;AA+Cf,IAAA,eAAA,EAAA,YAAkB;AAChBS,MAAAA,KAAAA,CAAAA,SAAAA,CAAAA,eAAAA,CAAAA,IAAAA,CAAAA,IAAAA;AACA,WAAA,CAAA,GAA4B,CAFZ,CAEhB;AAjDa,KAAA;AAsDf,IAAA,wBAAA,EAAA,YAA2B;AACzBA,MAAAA,KAAAA,CAAAA,SAAAA,CAAAA,wBAAAA,CAAAA,IAAAA,CAAAA,IAAAA;AAEAC,WAAAA,CAAAA,GADA,KAAA,CAAA,GAAqC,CAFZ,CAGzBA;AAzDa;AAAA,GAAjB;;AA8DAC,WAASA,EAATA,CAA0B,CAA1BA,EAAiC;AAGnBC,aAAAA,CAAAA,CAAQ,CAARA,EAAQ,CAARA,EAAwB;AAC9BC,MAAAA,CAAAA,GAAQ,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAARA;AACJA,MAAAA,CAAAA,CAAAA,CAAAA,GAAmBtG,CAAnBsG,IAA8B,CAAA,CAAQtG,CAAAA,CAAAA,QAAtCsG;AACA,aAHkC,CAGlC;AXhHY3P;;AAAAA,IAAAA,EWmHd,CAAA,CAAA,EAAA,CAAA,CXnHcA;AWoHd0P,IAAAA,CAAAA,CAAAA,SAAAA,GAAkBE,CAAAA,CAAAA,SAAlBF;AACA,WAX+B,CAW/B;AAGF;;AAAA,MAAIG,EAAAA,GAA8B;AAChC,IAAA,KAAA,EAAS,CADuB,CAAA;AAEhC,IAAA,IAAA,EAAQ,CAFwB;AAAA,GAAlC;;AAWAC,WAASA,EAATA,CAAsB,CAAtBA,EAA8B;AAC5B,WAAOH,CAAAA,CAAP,QAAOA,KAAsBA,CAAAA,CAA7B,MAAOA,IAAsCA,CAAAA,CAA7C,CAA6CA,KAA0BA,CAAAA,CAD3C,aAC5B;AASFI;;AAAAA,WAASA,EAATA,CAAqB,CAArBA,EAAqB,CAArBA,EAAqB,CAArBA,EAA0C;AAGxC,QAFIC,CAEJ,GAFS9Q,CAAAA,CAAAA,UAAAA,IAAmBA,CAAAA,CAAAA,UAAAA,CAAgByQ,CAAAA,CAAhBzQ,IAAAA,CAAnBA,IACPA,CAAAA,CAAAA,UAAAA,CAAgByQ,CAAAA,CAAhBzQ,IAAAA,EAAAA,CAAAA,CACF,EACE,KADM,IACGrC,CAAAA,GADH,CAAA,EACN,CAAA,EAAA,CAAqBoT,CAArB,GAA0BD,CAAAA,CAA1B,CAA0BA,CAA1B,MACM,CAAA,EAAA,CADN,CACM,CAAA,IAAwBL,CAAAA,CAD9B,MAC8BA,KAAiBA,CAAAA,CAD/C,aAAA,MAIEM,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,EAAAA,CAAAA,GACIC,CAAAA,CAAAA,CALN,CAAA,CAAA,EAAkCrT,CAAlC,EAAA,CAJsC;AAAA;;AAgB1CsT,WAASA,EAATA,CAAiC,CAAjCA,EAAqC;AACnC,QAAIlB,CAAAA,GAAOmB,CAAAA,CAAAA,YAAAA,EAAX;AAGArR,IAAAA,MAAAA,CAAAA,cAAAA,CAAAA,CAAAA,EAAAA,eAAAA,EAA0C;AACxCsR,MAAAA,GAAAA,EAAKA,YAAW;AACd,eADc,CACd;AAFsC,OAAA;AAIxCrL,MAAAA,YAAAA,EAAc,CAJhBjG;AAA0C,KAA1CA;;AAMA,SAAK,IAAIlC,CAAAA,GAAIoS,CAAAA,CAAJpS,MAAIoS,GAAb,CAAA,EAAA,KAAA,CAAA,EAAsCpS,CAAtC,EAAA,EAA2C;AACzC,UAAA,CAAA,GAAOoS,CAAAA,CAAAA,CAAAA,CAAP;AAEAc,MAAAA,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,SAAAA,CAAAA;AACA,UAAIK,CAAAA,CAAJ,CAAA,EAJyC;AAU3CrR;;AAAAA,IAAAA,MAAAA,CAAAA,cAAAA,CAAAA,CAAAA,EAAAA,YAAAA,EAAuC;AAAC,MAAA,GAAA,EAAA,YAAM;AAAE,eAAOwQ,KAAAA,CAAT,SAAE;AAAhDxQ;AAAuC,KAAvCA;AAIA,QAAIuR,CAAJ;;AACA,SAASzT,CAAT,GAAA,CAAA,EAAgBA,CAAhB,GAAoBoS,CAAAA,CAApB,MAAA,EAAiCpS,CAAjC,EAAA,EAAsC;AACpCqC,MAAAA,CAAAA,GAAO+P,CAAAA,CAAAA,CAAAA,CAAP/P;AACA,UAAMI,CAAAA,GAAOJ,CAAAA,CAAPI,OAAOJ,IAAgBA,CAAAA,CAAAA,OAAAA,CAAAA,IAA7B;AACA,UAAA,MAAA,CAAA,IAAgBI,CAAhB,IAAwBA,CAAxB,KAAA,CAAA,EAME,IALAyQ,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,QAAAA,CAAAA,EAEI7Q,CAGAsQ,KAHS7Q,MAATO,KACFoR,CAEEd,GAFctQ,CAAAA,CAAAA,WAAAA,EADdA,CAFJ6Q,EAKIP,CAAAA,CAAJ,CAAA,EATkC;AAzBH;AAAA;;AAwD9BqB,WAASA,EAATA,CAAqB,CAArBA,EAAqB,CAArBA,EAAqB,CAArBA,EAAqB,CAArBA,EAAqB,CAArBA,EAAqB,CAArBA,EAAoE;AACzE,SAAK,IAAIhU,CAAAA,GAAT,CAAA,EAAgBA,CAAhB,GAAoBiU,CAAAA,CAApB,MAAA,EAAqCjU,CAArC,EAAA,EAA0C;AACd,UAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA;AAAA,UAdpB2T,CAAAA,GAIJI,CAJF,CAAA,IAc0B;AAAA,UAbjBH,CAAAA,GAGPG,CAHF,CAAA,OAa0B;AAAA,UAZpBF,CAAAA,GAEJE,CAFF,CAAA,IAY0B;AAAA,UAXjBD,CAAAA,GACPC,CADF,CAAA,OAW0B;AAA1B,UAAuC1R,CAAvC,KAVE0R,CALFL,CAAAA,IAeuCrR,IAAM6R,CAA7C,KARSP,CAQ8BtR,IAAYyN,CAAnD,KAPY8D,CAO2BvR,IAAqB8R,CAA5D,KANSN,CAM8BxR,IAA2B+R,CAAlE,KALYN,CAKZ,EACE,OAFsC,CAEtC;AAGJ;;AAAA,WAAQ,CANiE,CAMzE;AANyE;;AAyBpE9M,WAASA,EAATA,CAAyB,CAAzBA,EAAyB,CAAzBA,EAAyB,CAAzBA,EAA2D;AAChE,QAAA,CAAA,EAAA;AAIA,UAAMqN,CAAAA,GAAc,OAAOC,CAA3B;AAGA,UAAA,eAAA,CAAA,IAAA,aAAA,CAAA,EAKA,IAAA,aAAA,CAAA,IAAkCA,CAAAA,CAAlC,WAAkCA,IAAlC,eAAyD,OAAOA,CAAAA,CAAhE,WAAA,EAAA;AAWA,YAAIzE,CAAJ,IAAA,aAAwB,OAAxB,CAAA,EAA8D;AAC5D,cAAA,CAAA,GAAU,CAAA,CAAQA,CAAAA,CAAAA,OAAlB;AACA,cAAA,CAAA,GAAO,CAAA,CAAQA,CAAAA,CAAAA,IAAf;AACA,cAAA,CAAA,GAAU,CAAA,CAAQA,CAAAA,CAH0C,OAG5D;AAHF,SAAA,MAKEC,CAEA,GAFU,CAAA,CAAQD,CAAlBC,EAEA,CAAA,GADAqE,CACA,GADO,CAAA,CADPrE;;AAOF,YAAI/M,CAAAA,GAAU8M,CAAV9M,IAA8B8M,CAAAA,CAA9B9M,CAAU8M,IAAd,IAAA;AAAA,YAEIoE,CAAAA,GAAWK,CAAAA,CAAAA,CAAAA,CAFf;;AAGA,YAAA,CAAA,EAEE;AAAA,cAAoE,CAApE,CAAoE,GAAhEN,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,EAAJ,CAAIA,CAAJ,EAAA;AAFF,SAAA,MAMEM,CAAAA,CAAAA,CAAAA,CAAAA,GAA6B,EAA7BA;;AAOIC,QAAAA,CAAAA,GAAYA,UAAQ,CAARA,EAAY;AAExBJ,UAAAA,CAAJ,IACE,KAAA,mBAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CADEA;AAGCZ,UAAAA,CAAAA,CAAL,QAAKA,IACHiB,EAAAA,CAAAA,CAAAA,CADGjB;;AAIL,cAAIxQ,CAAJ,KAAA,IAAA,EAAqB;AAEnB,gBAAA,CAAA,GAAwBb,MAAAA,CAAAA,wBAAAA,CAAAA,CAAAA,EAAAA,eAAAA,CAAxB;AACA,YAAA,MAAA,CAAA,cAAA,CAAA,CAAA,EAAA,eAAA,EAA0C;AAAC,cAAA,GAAA,EAAA,YAAM;AAAE,uBAAF,CAAE;AAAT,eAAA;AAA0BiG,cAAAA,YAAAA,EAAc,CAH/D;AAGuB,aAA1C;AAKF;;AAAA,cAAIoL,CAAAA,CAAJ,QAAIA,IAAkD,CAAtD,CAAsD,GAApCA,CAAAA,CAAAA,YAAAA,GAAAA,OAAAA,CAAlB,CAAkBA,CAAlB,EACE,IAAIN,EAAAA,CAAJ,CAAIA,CAAAA,IAAoBM,CAAAA,CAAxB,MAAwBA,KAAaA,CAAAA,CAArC,aAAA,EACMA,CAAAA,CAAJ,UAAIA,KAAiBb,KAAAA,CAArB,cAAIa,IACFA,CAAAA,CAFJ,wBAEIA,EADEA,CADN,KAOA,IAAIA,CAAAA,CAAJ,UAAIA,KAAiBb,KAAAA,CAArB,eAAIa,IAA2CA,CAAAA,CAA/C,OAAIA,IAAwDA,CAAAA,CAA5D,MAA4DA,KAA5D,CAAIA,IAAiFxQ,CAArF,YAAA,MAAA,EAAA;AAGA,gBAAI0R,CAAAA,GAAM,eAAA,CAAA,GACRH,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,EADQ,CACRA,CADQ,GAEPA,CAAAA,CAFO,WAEPA,IAAuBA,CAAAA,CAAAA,WAAAA,CAAAA,CAAAA,CAF1B;AAGIvR,YAAAA,CAAJ,KAAA,IAAIA,KAEE2R,CAAJ,IACExS,MAAAA,CAAAA,cAAAA,CAAAA,CAAAA,EAAAA,eAAAA,EAAAA,CAAAA,GACA,CAAA,GAFF,IAAA,IAIE,OAAOqR,CAAAA,CANX,aAAIxQ;AASJ,mBAfA,CAeA;AAxC0B;AA4C9BuR,SA5CMC;;AA4CND,QAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,CAAgC;AAC9BjS,UAAAA,IAAAA,EAD8B,IAAA;AAE9B6R,UAAAA,IAAAA,EAF8B,CAAA;AAG9BpE,UAAAA,OAAAA,EAH8B,CAAA;AAI9BqE,UAAAA,IAAAA,EAJ8B,CAAA;AAK9BC,UAAAA,OAAAA,EAL8B,CAAA;AAM9BG,UAAAA,CAAAA,EANFD;AAAgC,SAAhCA;AASItB,QAAAA,EAAAA,CAAJ,CAAIA,CAAAA,IACF,KAAA,UAAA,GAAkB,KAAA,UAAA,IAAmB,EAArC,EACA,KAAA,UAAA,CAAA,CAAA,IAAwB,KAAA,UAAA,CAAA,CAAA,KACtB;AAAC,UAAA,OAAA,EAAD,EAAA;AAAgB,UAAA,MAAA,EAAhB;AAAA,SAFF,EAGA,KAAA,UAAA,CAAA,CAAA,EAAsBlD,CAAAA,GAAAA,SAAAA,GAAtB,QAAA,EAAA,IAAA,CAJF,CAIE,CAJEkD,IAQF2B,CAFU,gBAAA,MAAA,GAAyB/J,CAAAA,CAAzB,CAAA,GACRA,CAAAA,CAAAA,gBACF+J,EAAAA,IAAAA,CAAAA,IAAAA,EAAAA,CAAAA,EAAAA,CAAAA,EApGF,CAoGEA,CARE3B;AAxGJ;AADgE;AAAA;;AAwH3D/L,WAASA,EAATA,CAA4B,CAA5BA,EAA4B,CAA5BA,EAA4B,CAA5BA,EAA8D;AACnE,QAAA,CAAA,EAAA;AAMA,UAAI4I,CAAJ,IAAA,aAAwB,OAAxB,CAAA,EAA8D;AAC5D,YAAA,CAAA,GAAU,CAAA,CAAQA,CAAAA,CAAAA,OAAlB;AACA,YAAA,CAAA,GAAO,CAAA,CAAQA,CAAAA,CAAAA,IAAf;AACA,YAAA,CAAA,GAAU,CAAA,CAAQA,CAAAA,CAH0C,OAG5D;AAHF,OAAA,MAKEC,CAEA,GAFU,CAAA,CAAQD,CAAlBC,EAEA,CAAA,GADAqE,CACA,GADO,CAAA,CADPrE;;AAIF,UAAI/M,CAAAA,GAAU8M,CAAV9M,IAA8B8M,CAAAA,CAA9B9M,CAAU8M,IAAd,IAAA;AAAA,UAEI0E,CAAAA,GAAYjT,KApJZ2S,CAkJJ;AAlJIA,UAAAA,CAAAA,GAAW,IAAXA;;AACJ,UAAI;AACFA,QAAAA,CAAAA,GAmJ8BK,CAnJnB,CADT,CACS,CAAXL;AACA,OAFF,CAEE,OAAA,CAAA,EAAU,CAmJRA;;AAAAA,MAAAA,CAAJ,KACMW,CACJ,GADUZ,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,CAANY,EACO,CAAX,CAAW,GAAX,CAAW,KACTL,CAEA,GAFYN,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAZM,EAEKN,CAAAA,CAAL,MAAKA,KACHK,CAAAA,CADF,CACEA,CAAAA,GAA6BhT,KANnC,CAKS2S,CAHI,CAFb,CAAIA;AAYJU,OAFU,gBAAA,MAAA,GAAyB/J,CAAAA,CAAzB,CAAA,GACRA,CAAAA,CAAAA,mBACF+J,EAAAA,IAAAA,CAAAA,IAAAA,EAAAA,CAAAA,EAAqBJ,CAArBI,IAAAA,CAAAA,EAAAA,CAAAA;AACIJ,MAAAA,CAAJ,IAAiBvB,EAAAA,CAAjB,CAAiBA,CAAbuB,IACA,KADJ,UAAIA,IACmB,KAAA,UAAA,CADvB,CACuB,CADnBA,KAEIhQ,CAEN,GAFY,KAAA,UAAA,CAAA,CAAA,EAAsBuL,CAAAA,GAAAA,SAAAA,GAAtB,QAAA,CAANvL,EACAqQ,CACN,GADYrQ,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CADNA,EAEK,CAAX,CAAW,GAAX,CAAW,IACTA,CAAAA,CAAAA,MAAAA,CAAAA,CAAAA,EArCJ,CAqCIA,CALAgQ;AAjC+D;AAAA;;AA2CrEM,WAASA,EAATA,GAAuC;AACrC,SAAKC,IAAL,CAAA,IAAA,EAAA,EACEhT,MAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,EAA4B,UAAQ,CAAR,EAAY;AACjCyR,MAAAA,CAAAA,CAAL,QAAKA,KACHiB,EAAAA,CAAAA,CAAAA,CAAAA,EACA,EAAA,CAHoC,CAGpC,CAFGjB;AADPzR,KAAAA,EAKG,CAPgC,CAEnCA;AASJ0S;;AAAAA,WAASA,EAATA,CAAmB,CAAnBA,EAA2B;AACzB1B,IAAAA,CAAAA,CAAAA,QAAAA,GAAoBA,CAAAA,CAAAA,MAApBA;AACAA,IAAAA,CAAAA,CAAAA,CAAAA,GAAwBA,CAAAA,CAAAA,aAAxBA;;AAEA,QXzdSjR,CWydL+F,CAAJ,CAAA,EAAA;AXxZA,UAAIvE,CAAAA,GAAQnB,MAAAA,CAAAA,cAAAA,CAAAA,CAAAA,CAAZ;;AACA,UAAI,CAACmB,CAAAA,CAAAA,cAAAA,CAAL,cAAKA,CAAL,EAA2C;AACzC,YAAIC,CAAAA,GAAapB,MAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAjB;AACAoB,QAAAA,CAAAA,CAAAA,CAAAA,GAA2BD,CAA3BC;AACAR,QAAAA,CAAAA,CAAAA,CAAAA,EAAAA,EAAAA,CAAAA;AACAO,QAAAA,CAAAA,CAAAA,YAAAA,GAJyC,CAIzCA;AWoZqByP;;AAAAA,MAAAA,CXjZvBvP,CAAAA,SWiZuBuP,GXjZPzP,CAAAA,CAAAA,YWiZOyP;AXlbThQ,KWibd,MXjbcA,CWqbZ,CAAA,CAAA,EARuB,EAQvB,CXrbYA;AWybhB;;AAAA,MAAIiS,EAAAA,GAAenC,EAAAA,CAAkB9Q,MAAAA,CAArC,KAAmB8Q,CAAnB;AAAA,MACIoC,EAAAA,GAAqBpC,EAAAA,CAAkB9Q,MAAAA,CAD3C,WACyB8Q,CADzB;AAAA,MAEIqC,EAAAA,GAAoBrC,EAAAA,CAAkB9Q,MAAAA,CAAlB8Q,UAAAA,CAFxB;;ACzdAsC,WAASA,EAATA,CAAwB,CAAxBA,EAA+B;ANuR7B,QAAIzS,CAAAA,GMtRoBJ,CNsRbL,CNlRGM,WYJUD,ENsRxB;ANlRcC,IAAAA,CMmRV,CAAJ,CAAI,CNnRUA,IMoRZ2J,EAAAA,CAAAA,CAAAA,CNpRY3J;AYHd,WAAOD,CAAAA,CAAP,OAAOA,IAAgBA,CAAAA,CAAAA,OAAAA,CAAvB,YAAOA,IAFsB,IAE7B;AAF6B;;AAK/B,MAAI8S,EAAAA,GAAc;AAKhBnO,IAAAA,gBAAAA,EDqRcA,ECrRIoO,CAAAA,IDqRJpO,CC1RE,MD0RFA,CC1RE;AAOhBC,IAAAA,mBAAAA,ED2YcA,EC3YOmO,CAAAA,ID2YPnO,CClZhB,MDkZgBA;AClZE,GAAlB;AAAA,MAWIoO,EAAAA,GAAY;AAEdrO,IAAAA,gBAAAA,ED6QcA,EC/QA;AAIdC,IAAAA,mBAAAA,EDmYcA,ECvYA;AAMd,IAAA,WAAA,EAAA,UAAW,CAAX,EAAkB;ANfJR,aAAAA,CMgBL,CAAA,IAAA,EADS,CACT,CNhBKA;AMSA,KAAA;AAUd,IAAA,YAAA,EAAA,UAAY,CAAZ,EAAY,CAAZ,EAA6B;ANnBfA,aAAAA,CMoBL,CAAA,IAAA,EAAA,CAAA,EADoB,CACpB,CNpBKA;AMSA,KAAA;AAcd,IAAA,WAAA,EAAA,UAAW,CAAX,EAAkB;AN2DJC,aAAAA,CM1DL,CAAA,IAAA,EADS,CACT,CN0DKA;AMzEA,KAAA;AAqBd,IAAA,YAAA,EAAA,UAAY,CAAZ,EAAY,CAAZ,EAA6B;AN9BfD,MAAAA,CM+BZ,CAAA,IAAA,EAAA,CAAA,ENmDYC,CMnDZ,CN/BYD;AAkFAC,MAAAA,CMlDZ,CAAA,IAAA,EAAA,CAAA,CNkDYA;AMjDZ,aAH2B,CAG3B;AAxBY,KAAA;AA8Bd,IAAA,SAAA,EAAA,UAAS,CAAT,EAAgB;ANmQhB,UAAA,cAAIqE,KAAJ,SAAA,EACE,IAAA,CAAA,GAAOH,CAAAA,CAAAA,SAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EADT,CACSA,CAAP,CADF,KAIE,IADI3H,CMrQ4BqS,GNqQxB1K,CAAAA,CAAAA,SAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAmC,CAAnCA,CAAAA,CAAJ3H,EACJ,CAAA,EAAU;AACJiC,QAAAA,CAAAA,GAAKW,KAAAA,UAALX;;AACJ,aAFQ,IAEClF,CAAAA,GAFD,CAAA,EAER,CAAA,EAAkBA,CAAlB,GAAsBkF,CAAAA,CAAtB,MAAA,EAAiClF,CAAjC,EAAA,EACEmM,CACAlJ,GADKiC,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAgB,CAAhBA,CAAAA,CAALiH,EACAlJ,CAAAA,CAAAA,WAAAA,CAJM,CAINA,CADAkJ;AMzQJ;AAAA,aADc,CACd;AA/BY,KAAA;AAqCd,IAAA,WAAA,EAAA,YAAqB;ANoKPnK,aAAAA,EMnKL,CADY,IACZ,CNmKKA;AMzMA,KAAA;AAyCd,IAAA,QAAA,EAAA,UAAQ,CAAR,EAAe;AZoCDgC,aAAAA,EYnCL,CAAA,IAAA,EADM,CACN,CZmCKA;AY7EA,KAAA;;AAgDVuR,QAAAA,WAAAA,GAAc;AAEhB,UAAMC,CAAAA,GAAgB,KAAA,aAAtB;AAIA,UZqBSzR,EYrBT,IAHiCgE,CAAAA,CAAAA,QAAAA,CAAAA,IAAAA,CAAAA,CAAAA,EAAAA,IAAAA,CZwBxBhE,IYrBLyR,CAAAA,CAAJ,eAAIA,IACFzN,CAAAA,CAAAA,QAAAA,CAAAA,IAAAA,CAAoByN,CAAAA,CAApBzN,eAAAA,EADF,IACEA,CADF,EAEE,OAAO,CAAA,CAAP;;AAGF,WADI1F,CACJ,GADW,IACX,EAAOA,CAAP,IAAe,EAAEA,CAAF,YAAf,QAAe,CAAf,GACEA,CAAAA,GAAOA,CAAAA,CAAPA,UAAOA,KAAoBA,CL/DtBiK,YAAAA,CK+DsBjK,GAAsDA,CAADyF,CAArDzF,IAAAA,GAAmEf,KAA9Fe,CAAOA,CAAPA;;AAEF,aAAO,CAAC,EAAEA,CAAF,IAAUA,CAAV,YAdQ,QAcR,CAAR;AA9DY,KAAA;;AAoEd,IAAA,aAAA,EAAA,UAAa,CAAb,EAAqB;AH/EPkO,MAAAA,CGgFZ;AACA,aAAOlJ,CAAAA,CAAAA,aAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAFY,CAEZA,CAAP;AAjFJ;AAWgB,GAXhB;AAAA,MAuFIoO,EAAAA,GAAY;AAIVC,QAAAA,YAAAA,GAAe;AACjB,aAAOR,EAAAA,CADU,IACVA,CAAP;AA5FJ;;AAuFgB,GAvFhB;AAAA,MAgGIS,EAAAA,GAAgB;AAMlB,IAAA,aAAA,EAAA,UAAa,CAAb,EAAwB;AN+IVjK,aAAAA,CM7IC,CAAA,IAAA,EAAqB,UAAQ,CAAR,EAAY;AZvFzC9I,eAAAA,EAAAA,CAAAA,IAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA;AYuFQ,OAAA,EAEV,UAAQ,CAAR,EAAY;AACb,eAAO,CAAA,CADM,CACb;AAHW,OAAA,CN6ID8I,CM7IC,CN6IDA,KM/IU,IN+IVA;AMrJI,KAAA;AAmBlB,IAAA,gBAAA,EAAA,UAAgB,CAAhB,EAA2B;ANkIbA,aAAAA,CMjIL,CAAA,IAAA,EAAqB,UAAQ,CAAR,EAAY;AZnGnC9I,eAAAA,EAAAA,CAAAA,IAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA;AYkGoB,OAClB,CNiIK8I;AMrPhB;AAgGoB,GAhGpB;AAAA,MA2HIkK,EAAAA,GAAY;AAKd,IAAA,aAAA,EAAA,UAAa,CAAb,EAAuB;AACrB,UAAA,WAAI,KAAJ,SAAA,EAA+B;ANiJjC,YAAInT,CAAAA,GAAOT,KNlRGM,WMkRHN,EAAX;ANlRcM,QAAAA,CMmRV,CAAJ,CAAI,CNnRUA,IMoRZ2J,EAAAA,CAAAA,CAAAA,CNpRY3J;AYmIV,eAAO,KAAA,OAAA,GAAA,CACHkK,CAAAA,IAAWA,CAAAA,CAAXA,OAAAA,GAA6B,KAAA,OAAA,CAA7BA,CAAAA,GACF,KAAA,OAAA,CAFK,aAAA,KAAA,EAAA,GAFsB,EAE7B;AAHmB;AAhIzB;AA2HgB,GA3HhB;AAAA,MA4IIqJ,EAAAA,GZvGY3S,CYuGG,CAAgB;AAKjC,IAAA,YAAA,EAAA,UAAY,CAAZ,EAAY,CAAZ,EAA0B;ANyIZyD,MAAAA,EMxIZ,CAAA,IAAA,EAAA,CAAA,EADwB,CACxB,CNwIYA;AM9ImB,KAAA;AAYjC,IAAA,eAAA,EAAA,UAAe,CAAf,EAAsB;AN+ItBiE,MAAAA,CAAAA,CAAAA,eAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAAA,CAAAA;AACAU,MAAAA,EAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA;AM5JiC,KAAA;AAmBjC,IAAA,YAAA,EAAA,UAAY,CAAZ,EAAsB;ALiVtB,UAAI,CAAJ,IAAA,EACE,MAAA,sBAAA;AAEF,UAAI,CAAJ,CAAA,EACE,MAAA,uBAAA;AAEK,aAAA,IAAA,CAAA,CAAA,EAAA,EAAA,IAAA,EAAA,CAAA,CAAA;AK1W0B,KAAA;;AA0B7BiC,QAAAA,IAAAA,GAAO;AACT,aAAO,KAAA,YAAA,CADE,MACF,CAAP;AA3B+B,KAAA;;AAiC7BA,QAAAA,IAAAA,CAAK,CAALA,EAAY;AN6GF5G,MAAAA,EM5GZ,CAAA,IAAA,EAAA,MAAA,EADc,CACd,CN4GYA;AM9ImB,KAAA;;AAwC7B+O,QAAAA,YAAAA,GAAe;AACjB,aAAOR,EAAAA,CADU,IACVA,CAAP;AAzCe;;AAAgB,GAAhB,EAAA,EAAA,EAAA,EAAA,CA5InB;AA0LAhT,EAAAA,MAAAA,CAAAA,gBAAAA,CAAAA,EAAAA,ERoKW6G,EQpKX7G;AAEA,MAAI4T,EAAAA,GZvJY5S,CYuJI,CAAgB;AAIlC,IAAA,UAAA,EAAA,UAAU,CAAV,EAAU,CAAV,EAAuB;ANgIT4D,aAAAA,EM/HL,CAAA,CAAA,EADc,CACd,CN+HKA;AMpIoB,KAAA;AAWlC,IAAA,cAAA,EAAA,UAAc,CAAd,EAAmB;AN8CL4E,aAAAA,CM7CC,CAAA,IAAA,EAAqB,UAAQ,CAAR,EAAY;AAC5C,eAAOzI,CAAAA,CAAP,EAAOA,IADqC,CAC5C;AADW,OAAA,EAEV,UAAQ,CAAR,EAAY;AACb,eAAO,CAAA,CADM,CACb;AAHW,OAAA,CN6CDyI,CM7CC,CN6CDA,KM9CK,IN8CLA;AMzDI;AAAgB,GAAhB,EAAA,EAAA,CAApB;AAsBAxJ,EAAAA,MAAAA,CAAAA,gBAAAA,CAAAA,EAAAA,EAAuC;AACrC,IAAA,cAAA,ER2JS+G,CQ3JSC,CADpBhH;AAAuC,GAAvCA;MAII6T,EAAAA,GAAavO,WAAAA,CAAAA,SAAAA,CAAjB,I;MAEIwO,EAAAA,GZnLY9S,CYmLO,CAAgB;AAIrC,IAAA,IAAA,EAAA,YAAO;AACL,UAAIT,CAAAA,GAAO,KAAPA,OAAO,IAAgB,KAAA,OAAA,CAAA,IAA3B;AAEA,OADIwT,CACJ,GADmBxT,CACnB,IAD2BA,CAAAA,CAAAA,aAC3B,IACEwT,CAAAA,CADF,IACEA,EADF,GAGEF,EAAAA,CAAAA,IAAAA,CANG,IAMHA,CAHF;AAPmB;AAAgB,GAAhB,C;;AAevBG,WAASA,CAATA,CAAqB,CAArBA,EAAqB,CAArBA,EAAkC;AAEhC,SADA,IAAIlT,CAAAA,GAAKd,MAAAA,CAAAA,mBAAAA,CAAT,CAASA,CAAT,EACSlC,CAAAA,GAAT,CAAA,EAAcA,CAAd,GAAkBgD,CAAAA,CAAlB,MAAA,EAA6BhD,CAA7B,EAAA,EAAkC;AAChC,UAAIiD,CAAAA,GAAID,CAAAA,CAAR,CAAQA,CAAR;AAAA,UACIsL,CAAAA,GAAIpM,MAAAA,CAAAA,wBAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CADR;AAKIoM,MAAAA,CAAAA,CAAJ,KAAIA,GACFjL,CAAAA,CADF,CACEA,CAAAA,GAAWiL,CAAAA,CADb,KAAIA,GAGFpM,MAAAA,CAAAA,cAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAT8B,CAS9BA,CAHEoM;AAR0B;;;;;ACjOlC,MbnBWzM,CamBPuU,CAAJ,CAAA,EAA0B;AAiBxBtU,IAAAA,MAAAA,CAAAA,QAAAA,GAhBeuU;AAEb,MAAA,KAAA,EbtBOxU,CasBEuU,CAFIC,CAAAA;AAIb,MAAA,KAAA,EAASC,UAAAA,CAAAA,EAAUjU;AAAAA,eAAAA,CAAAA;AAJNgU,OAAAA;AAKb,MAAA,WAAA,EbZY/T,CaOC+T;AAMb,MAAA,OAAA,EJrBY/F,EIeC+F;AAOb,MAAA,KAAA,EJdY9F,CIOC8F;AAQb,MAAA,QAAA,Eb5BOxU,CaoBMwU;AASb,MAAA,eAAA,EHkDYhF,EG3DCgF;AAUb,MAAA,eAAA,EHsBOtF,EGhCMsF;AAWb,MAAA,iBAAA,EHsCOlF,EGjDMkF;AAYb,MAAA,aAAA,EAZaA,CAAAA;AAab,MAAA,UAAA,EFqcFvU;AEldeuU,KAgBfvU;AFkcAA,IAAAA,MAAAA,CAAAA,KAAAA,GAAeiT,EAAfjT;AACAA,IAAAA,MAAAA,CAAAA,WAAAA,GAAqBkT,EAArBlT;AACAA,IAAAA,MAAAA,CAAAA,UAAAA,GAAoBmT,EAApBnT;AACA+S,IAAAA,EAAAA;AC5NA,QAAIsB,EAAAA,GACDrU,MAAAA,CADCqU,cACDrU,IAA4BA,MAAAA,CAAAA,cAAAA,CAD3BqU,iBACDrU,IACD0F,WAFF;AAIA0O,IAAAA,CAAAA,CAAapU,MAAAA,CAAAA,IAAAA,CAAboU,SAAAA,EAAAA,EAAAA,CAAAA;AACAA,IAAAA,CAAAA,CAAapU,MAAAA,CAAAA,MAAAA,CAAboU,SAAAA,EAAAA,EAAAA,CAAAA;AACAA,IAAAA,CAAAA,CAAapU,MAAAA,CAAAA,IAAAA,CAAboU,SAAAA,EAAAA,EAAAA,CAAAA;AACAA,IAAAA,CAAAA,CAAapU,MAAAA,CAAAA,gBAAAA,CAAboU,SAAAA,EAAAA,EAAAA,CAAAA;AACAA,IAAAA,CAAAA,CAAapU,MAAAA,CAAAA,OAAAA,CAAboU,SAAAA,EAAAA,EAAAA,CAAAA;AACA,IAAA,CAAA,CAAapU,MAAAA,CAAAA,QAAAA,CAAb,SAAA,EAAA,EAAA,CAAA;AACIA,IAAAA,MAAAA,CAAJ,eAAIA,IACFoU,CAAAA,CAAapU,MAAAA,CAAAA,eAAAA,CAAboU,SAAAA,EAAAA,EAAAA,CADEpU;AAGJoU,IAAAA,CAAAA,CAAaC,EAAAA,CAAbD,SAAAA,EZ1RSrU,EY0RTqU,CAAAA;AZ1RSrU,IAAAA,CYgSL+F,CAAJ,CZhSS/F,KIiaK2H,CQhIZ,CAAe1H,MAAAA,CAAAA,IAAAA,CAAf,SAAA,CRgIY0H,EAAAA,CQ/HZ,CAAe1H,MAAAA,CAAAA,IAAAA,CAAf,SAAA,CR+HY0H,EAAAA,CQ9HZ,CAAe1H,MAAAA,CAAAA,gBAAAA,CAAf,SAAA,CR8HY0H,EAAAA,CQ7HZ,CAAe1H,MAAAA,CAAAA,OAAAA,CAAf,SAAA,CR6HY0H,EAAAA,CQ5HZ,CAAe2M,EAAAA,CAAf,SAAA,CR4HY3M,EAAAA,CQ3HZ,CAAe1H,MAAAA,CAAAA,QAAAA,CAAf,SAAA,CR2HY0H,EQ1HR1H,MAAAA,CAAJ,eAAIA,IR0HQ0H,CQzHV,CAAe1H,MAAAA,CAAAA,eAAAA,CARnB,SAQI,CZxSKD;Aa2CTC,IAAAA,MAAAA,CAAAA,UAAAA,GNtBSwK,CMsBTxK;AAxBwB;;AAAA;AAAA,C,EAAA,I,CAAA,I","sourcesContent":[null,null,null,null,null,"/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nfunction newSplice(index, removed, addedCount) {\n  return {\n    index: index,\n    removed: removed,\n    addedCount: addedCount\n  };\n}\n\nconst EDIT_LEAVE = 0;\nconst EDIT_UPDATE = 1;\nconst EDIT_ADD = 2;\nconst EDIT_DELETE = 3;\n\n// Note: This function is *based* on the computation of the Levenshtein\n// \"edit\" distance. The one change is that \"updates\" are treated as two\n// edits - not one. With Array splices, an update is really a delete\n// followed by an add. By retaining this, we optimize for \"keeping\" the\n// maximum array items in the original array. For example:\n//\n//   'xxxx123' -> '123yyyy'\n//\n// With 1-edit updates, the shortest path would be just to update all seven\n// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n// leaves the substring '123' intact.\nfunction calcEditDistances(current, currentStart, currentEnd,\n                            old, oldStart, oldEnd) {\n  // \"Deletion\" columns\n  let rowCount = oldEnd - oldStart + 1;\n  let columnCount = currentEnd - currentStart + 1;\n  let distances = new Array(rowCount);\n\n  // \"Addition\" rows. Initialize null column.\n  for (let i = 0; i < rowCount; i++) {\n    distances[i] = new Array(columnCount);\n    distances[i][0] = i;\n  }\n\n  // Initialize null row\n  for (let j = 0; j < columnCount; j++)\n    distances[0][j] = j;\n\n  for (let i = 1; i < rowCount; i++) {\n    for (let j = 1; j < columnCount; j++) {\n      if (equals(current[currentStart + j - 1], old[oldStart + i - 1]))\n        distances[i][j] = distances[i - 1][j - 1];\n      else {\n        let north = distances[i - 1][j] + 1;\n        let west = distances[i][j - 1] + 1;\n        distances[i][j] = north < west ? north : west;\n      }\n    }\n  }\n\n  return distances;\n}\n\n// This starts at the final weight, and walks \"backward\" by finding\n// the minimum previous weight recursively until the origin of the weight\n// matrix.\nfunction spliceOperationsFromEditDistances(distances) {\n  let i = distances.length - 1;\n  let j = distances[0].length - 1;\n  let current = distances[i][j];\n  let edits = [];\n  while (i > 0 || j > 0) {\n    if (i == 0) {\n      edits.push(EDIT_ADD);\n      j--;\n      continue;\n    }\n    if (j == 0) {\n      edits.push(EDIT_DELETE);\n      i--;\n      continue;\n    }\n    let northWest = distances[i - 1][j - 1];\n    let west = distances[i - 1][j];\n    let north = distances[i][j - 1];\n\n    let min;\n    if (west < north)\n      min = west < northWest ? west : northWest;\n    else\n      min = north < northWest ? north : northWest;\n\n    if (min == northWest) {\n      if (northWest == current) {\n        edits.push(EDIT_LEAVE);\n      } else {\n        edits.push(EDIT_UPDATE);\n        current = northWest;\n      }\n      i--;\n      j--;\n    } else if (min == west) {\n      edits.push(EDIT_DELETE);\n      i--;\n      current = west;\n    } else {\n      edits.push(EDIT_ADD);\n      j--;\n      current = north;\n    }\n  }\n\n  edits.reverse();\n  return edits;\n}\n\n/**\n * Splice Projection functions:\n *\n * A splice map is a representation of how a previous array of items\n * was transformed into a new array of items. Conceptually it is a list of\n * tuples of\n *\n *   <index, removed, addedCount>\n *\n * which are kept in ascending index order of. The tuple represents that at\n * the |index|, |removed| sequence of items were removed, and counting forward\n * from |index|, |addedCount| items were added.\n */\n\n/**\n * Lacking individual splice mutation information, the minimal set of\n * splices can be synthesized given the previous state and final state of an\n * array. The basic approach is to calculate the edit distance matrix and\n * choose the shortest path through it.\n *\n * Complexity: O(l * p)\n *   l: The length of the current array\n *   p: The length of the old array\n */\nfunction calcSplices(current, currentStart, currentEnd,\n                      old, oldStart, oldEnd) {\n  let prefixCount = 0;\n  let suffixCount = 0;\n  let splice;\n\n  let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n  if (currentStart == 0 && oldStart == 0)\n    prefixCount = sharedPrefix(current, old, minLength);\n\n  if (currentEnd == current.length && oldEnd == old.length)\n    suffixCount = sharedSuffix(current, old, minLength - prefixCount);\n\n  currentStart += prefixCount;\n  oldStart += prefixCount;\n  currentEnd -= suffixCount;\n  oldEnd -= suffixCount;\n\n  if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\n    return [];\n\n  if (currentStart == currentEnd) {\n    splice = newSplice(currentStart, [], 0);\n    while (oldStart < oldEnd)\n      splice.removed.push(old[oldStart++]);\n\n    return [ splice ];\n  } else if (oldStart == oldEnd)\n    return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\n  let ops = spliceOperationsFromEditDistances(\n      calcEditDistances(current, currentStart, currentEnd,\n                             old, oldStart, oldEnd));\n\n  splice = undefined;\n  let splices = [];\n  let index = currentStart;\n  let oldIndex = oldStart;\n  for (let i = 0; i < ops.length; i++) {\n    switch(ops[i]) {\n      case EDIT_LEAVE:\n        if (splice) {\n          splices.push(splice);\n          splice = undefined;\n        }\n\n        index++;\n        oldIndex++;\n        break;\n      case EDIT_UPDATE:\n        if (!splice)\n          splice = newSplice(index, [], 0);\n\n        splice.addedCount++;\n        index++;\n\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n      case EDIT_ADD:\n        if (!splice)\n          splice = newSplice(index, [], 0);\n\n        splice.addedCount++;\n        index++;\n        break;\n      case EDIT_DELETE:\n        if (!splice)\n          splice = newSplice(index, [], 0);\n\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n    }\n  }\n\n  if (splice) {\n    splices.push(splice);\n  }\n  return splices;\n}\n\nfunction sharedPrefix(current, old, searchLength) {\n  for (let i = 0; i < searchLength; i++)\n    if (!equals(current[i], old[i]))\n      return i;\n  return searchLength;\n}\n\nfunction sharedSuffix(current, old, searchLength) {\n  let index1 = current.length;\n  let index2 = old.length;\n  let count = 0;\n  while (count < searchLength && equals(current[--index1], old[--index2]))\n    count++;\n\n  return count;\n}\n\nfunction equals(currentValue, previousValue) {\n  return currentValue === previousValue;\n}\n\nexport function calculateSplices(current, previous) {\n  return calcSplices(current, 0, current.length, previous, 0,\n                          previous.length);\n}\n\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nexport let settings = window['ShadyDOM'] || {};\n\nsettings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);\n\nlet desc = Object.getOwnPropertyDescriptor(Node.prototype, 'firstChild');\n\nsettings.hasDescriptors = Boolean(desc && desc.configurable && desc.get);\nsettings.inUse = settings['force'] || !settings.hasNativeShadowDOM;\n\nexport function isTrackingLogicalChildNodes(node) {\n  return (node.__shady && node.__shady.firstChild !== undefined);\n}\n\nexport function isShadyRoot(obj) {\n  return Boolean(obj.__localName === 'ShadyRoot');\n}\n\nexport function ownerShadyRootForNode(node) {\n  let root = node.getRootNode();\n  if (isShadyRoot(root)) {\n    return root;\n  }\n}\n\nlet p = Element.prototype;\nlet matches = p.matches || p.matchesSelector ||\n  p.mozMatchesSelector || p.msMatchesSelector ||\n  p.oMatchesSelector || p.webkitMatchesSelector;\n\nexport function matchesSelector(element, selector) {\n  return matches.call(element, selector);\n}\n\nfunction copyOwnProperty(name, source, target) {\n  let pd = Object.getOwnPropertyDescriptor(source, name);\n  if (pd) {\n    Object.defineProperty(target, name, pd);\n  }\n}\n\nexport function extend(target, source) {\n  if (target && source) {\n    let n$ = Object.getOwnPropertyNames(source);\n    for (let i=0, n; (i<n$.length) && (n=n$[i]); i++) {\n      copyOwnProperty(n, source, target);\n    }\n  }\n  return target || source;\n}\n\nexport function extendAll(target, ...sources) {\n  for (let i=0; i < sources.length; i++) {\n    extend(target, sources[i]);\n  }\n  return target;\n}\n\nexport function mixin(target, source) {\n  for (var i in source) {\n    target[i] = source[i];\n  }\n  return target;\n}\n\nexport function patchPrototype(obj, mixin) {\n  let proto = Object.getPrototypeOf(obj);\n  if (!proto.hasOwnProperty('__patchProto')) {\n    let patchProto = Object.create(proto);\n    patchProto.__sourceProto = proto;\n    extend(patchProto, mixin);\n    proto['__patchProto'] = patchProto;\n  }\n  // old browsers don't have setPrototypeOf\n  obj.__proto__ = proto['__patchProto'];\n}\n\n\nlet twiddle = document.createTextNode('');\nlet content = 0;\nlet queue = [];\nnew MutationObserver(() => {\n  while (queue.length) {\n    // catch errors in user code...\n    try {\n      queue.shift()();\n    } catch(e) {\n      // enqueue another record and throw\n      twiddle.textContent = content++;\n      throw(e);\n    }\n  }\n}).observe(twiddle, {characterData: true});\n\n// use MutationObserver to get microtask async timing.\nexport function microtask(callback) {\n  queue.push(callback);\n  twiddle.textContent = content++;\n}\n\nexport const hasDocumentContains = Boolean(document.contains);\n\nexport function contains(container, node) {\n  while (node) {\n    if (node == container) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n// Cribbed from ShadowDOM polyfill\n// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28\n/////////////////////////////////////////////////////////////////////////////\n// innerHTML and outerHTML\n\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\nlet escapeAttrRegExp = /[&\\u00A0\"]/g;\nlet escapeDataRegExp = /[&\\u00A0<>]/g;\n\nfunction escapeReplace(c) {\n  switch (c) {\n    case '&':\n      return '&amp;';\n    case '<':\n      return '&lt;';\n    case '>':\n      return '&gt;';\n    case '\"':\n      return '&quot;';\n    case '\\u00A0':\n      return '&nbsp;';\n  }\n}\n\nfunction escapeAttr(s) {\n  return s.replace(escapeAttrRegExp, escapeReplace);\n}\n\nfunction escapeData(s) {\n  return s.replace(escapeDataRegExp, escapeReplace);\n}\n\nfunction makeSet(arr) {\n  let set = {};\n  for (let i = 0; i < arr.length; i++) {\n    set[arr[i]] = true;\n  }\n  return set;\n}\n\n// http://www.whatwg.org/specs/web-apps/current-work/#void-elements\nlet voidElements = makeSet([\n  'area',\n  'base',\n  'br',\n  'col',\n  'command',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'keygen',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr'\n]);\n\nlet plaintextParents = makeSet([\n  'style',\n  'script',\n  'xmp',\n  'iframe',\n  'noembed',\n  'noframes',\n  'plaintext',\n  'noscript'\n]);\n\n/**\n * @param {Node} node\n * @param {Node} parentNode\n * @param {Function=} callback\n */\nexport function getOuterHTML(node, parentNode, callback) {\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE: {\n      let tagName = node.localName;\n      let s = '<' + tagName;\n      let attrs = node.attributes;\n      for (let i = 0, attr; (attr = attrs[i]); i++) {\n        s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n      }\n      s += '>';\n      if (voidElements[tagName]) {\n        return s;\n      }\n      return s + getInnerHTML(node, callback) + '</' + tagName + '>';\n    }\n    case Node.TEXT_NODE: {\n      let data = /** @type {Text} */ (node).data;\n      if (parentNode && plaintextParents[parentNode.localName]) {\n        return data;\n      }\n      return escapeData(data);\n    }\n    case Node.COMMENT_NODE: {\n      return '<!--' + /** @type {Comment} */ (node).data + '-->';\n    }\n    default: {\n      window.console.error(node);\n      throw new Error('not implemented');\n    }\n  }\n}\n\n/**\n * @param {Node} node\n * @param {Function=} callback\n */\nexport function getInnerHTML(node, callback) {\n  if (node.localName === 'template') {\n    node =  /** @type {HTMLTemplateElement} */ (node).content;\n  }\n  let s = '';\n  let c$ = callback ? callback(node) : node.childNodes;\n  for (let i=0, l=c$.length, child; (i<l) && (child=c$[i]); i++) {\n    s += getOuterHTML(child, node, callback);\n  }\n  return s;\n}\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport {getInnerHTML} from './innerHTML.js';\n\nlet nodeWalker = document.createTreeWalker(document, NodeFilter.SHOW_ALL,\n  null, false);\n\nlet elementWalker = document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT,\n  null, false);\n\nexport function parentNode(node) {\n  nodeWalker.currentNode = node;\n  return nodeWalker.parentNode();\n}\n\nexport function firstChild(node) {\n  nodeWalker.currentNode = node;\n  return nodeWalker.firstChild();\n}\n\nexport function lastChild(node) {\n  nodeWalker.currentNode = node;\n  return nodeWalker.lastChild();\n}\n\nexport function previousSibling(node) {\n  nodeWalker.currentNode = node;\n  return nodeWalker.previousSibling();\n}\n\nexport function nextSibling(node) {\n  nodeWalker.currentNode = node;\n  return nodeWalker.nextSibling();\n}\n\nexport function childNodes(node) {\n  let nodes = [];\n  nodeWalker.currentNode = node;\n  let n = nodeWalker.firstChild();\n  while (n) {\n    nodes.push(n);\n    n = nodeWalker.nextSibling();\n  }\n  return nodes;\n}\n\nexport function parentElement(node) {\n  elementWalker.currentNode = node;\n  return elementWalker.parentNode();\n}\n\nexport function firstElementChild(node) {\n  elementWalker.currentNode = node;\n  return elementWalker.firstChild();\n}\n\nexport function lastElementChild(node) {\n  elementWalker.currentNode = node;\n  return elementWalker.lastChild();\n}\n\nexport function previousElementSibling(node) {\n  elementWalker.currentNode = node;\n  return elementWalker.previousSibling();\n}\n\nexport function nextElementSibling(node) {\n  elementWalker.currentNode = node;\n  return elementWalker.nextSibling();\n}\n\nexport function children(node) {\n  let nodes = [];\n  elementWalker.currentNode = node;\n  let n = elementWalker.firstChild();\n  while (n) {\n    nodes.push(n);\n    n = elementWalker.nextSibling();\n  }\n  return nodes;\n}\n\nexport function innerHTML(node) {\n  return getInnerHTML(node, (n) => childNodes(n));\n}\n\nexport function textContent(node) {\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n    case Node.DOCUMENT_FRAGMENT_NODE:\n      let textWalker = document.createTreeWalker(node, NodeFilter.SHOW_TEXT,\n        null, false);\n      let content = '', n;\n      while ( (n = textWalker.nextNode()) ) {\n        // TODO(sorvell): can't use textContent since we patch it on Node.prototype!\n        // However, should probably patch it only on element.\n        content += n.nodeValue;\n      }\n      return content;\n    default:\n      return node.nodeValue;\n  }\n}\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nexport let appendChild = Element.prototype.appendChild;\nexport let insertBefore = Element.prototype.insertBefore;\nexport let removeChild = Element.prototype.removeChild;\nexport let setAttribute = Element.prototype.setAttribute;\nexport let removeAttribute = Element.prototype.removeAttribute;\nexport let cloneNode = Element.prototype.cloneNode;\nexport let importNode = Document.prototype.importNode;\nexport let addEventListener = Element.prototype.addEventListener;\nexport let removeEventListener = Element.prototype.removeEventListener;\nexport let windowAddEventListener = Window.prototype.addEventListener;\nexport let windowRemoveEventListener = Window.prototype.removeEventListener;\nexport let dispatchEvent = Element.prototype.dispatchEvent;\nexport let querySelector = Element.prototype.querySelector;\nexport let querySelectorAll = Element.prototype.querySelectorAll;\nexport let contains = Node.prototype.contains || HTMLElement.prototype.contains;\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from './utils.js';\nimport {getInnerHTML} from './innerHTML.js';\nimport * as nativeTree from './native-tree.js';\nimport {contains as nativeContains} from './native-methods.js';\n\nfunction clearNode(node) {\n  while (node.firstChild) {\n    node.removeChild(node.firstChild);\n  }\n}\n\nconst nativeInnerHTMLDesc = /** @type {ObjectPropertyDescriptor} */(\n  Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML') ||\n  Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML'));\n\nconst inertDoc = document.implementation.createHTMLDocument('inert');\n\nconst nativeActiveElementDescriptor =\n  /** @type {ObjectPropertyDescriptor} */(\n    Object.getOwnPropertyDescriptor(Document.prototype, 'activeElement')\n  );\nfunction getDocumentActiveElement() {\n  if (nativeActiveElementDescriptor && nativeActiveElementDescriptor.get) {\n    return nativeActiveElementDescriptor.get.call(document);\n  } else if (!utils.settings.hasDescriptors) {\n    return document.activeElement;\n  }\n}\n\nfunction activeElementForNode(node) {\n  let active = getDocumentActiveElement();\n  // In IE11, activeElement might be an empty object if the document is\n  // contained in an iframe.\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10998788/\n  if (!active || !active.nodeType) {\n    return null;\n  }\n  let isShadyRoot = !!(utils.isShadyRoot(node));\n  if (node !== document) {\n    // If this node isn't a document or shady root, then it doesn't have\n    // an active element.\n    if (!isShadyRoot) {\n      return null;\n    }\n    // If this shady root's host is the active element or the active\n    // element is not a descendant of the host (in the composed tree),\n    // then it doesn't have an active element.\n    if (node.host === active ||\n        !nativeContains.call(node.host, active)) {\n      return null;\n    }\n  }\n  // This node is either the document or a shady root of which the active\n  // element is a (composed) descendant of its host; iterate upwards to\n  // find the active element's most shallow host within it.\n  let activeRoot = utils.ownerShadyRootForNode(active);\n  while (activeRoot && activeRoot !== node) {\n    active = activeRoot.host;\n    activeRoot = utils.ownerShadyRootForNode(active);\n  }\n  if (node === document) {\n    // This node is the document, so activeRoot should be null.\n    return activeRoot ? null : active;\n  } else {\n    // This node is a non-document shady root, and it should be\n    // activeRoot.\n    return activeRoot === node ? active : null;\n  }\n}\n\nlet OutsideAccessors = {\n\n  parentElement: {\n    /** @this {Node} */\n    get() {\n      let l = this.__shady && this.__shady.parentNode;\n      if (l && l.nodeType !== Node.ELEMENT_NODE) {\n        l = null;\n      }\n      return l !== undefined ? l : nativeTree.parentElement(this);\n    },\n    configurable: true\n  },\n\n  parentNode: {\n    /** @this {Node} */\n    get() {\n      let l = this.__shady && this.__shady.parentNode;\n      return l !== undefined ? l : nativeTree.parentNode(this);\n    },\n    configurable: true\n  },\n\n  nextSibling: {\n    /** @this {Node} */\n    get() {\n      let l = this.__shady && this.__shady.nextSibling;\n      return l !== undefined ? l : nativeTree.nextSibling(this);\n    },\n    configurable: true\n  },\n\n  previousSibling: {\n    /** @this {Node} */\n    get() {\n      let l = this.__shady && this.__shady.previousSibling;\n      return l !== undefined ? l : nativeTree.previousSibling(this);\n    },\n    configurable: true\n  },\n\n  className: {\n    /**\n     * @this {HTMLElement}\n     */\n    get() {\n      return this.getAttribute('class') || '';\n    },\n    /**\n     * @this {HTMLElement}\n     */\n    set(value) {\n      this.setAttribute('class', value);\n    },\n    configurable: true\n  },\n\n  // fragment, element, document\n  nextElementSibling: {\n    /**\n     * @this {HTMLElement}\n     */\n    get() {\n      if (this.__shady && this.__shady.nextSibling !== undefined) {\n        let n = this.nextSibling;\n        while (n && n.nodeType !== Node.ELEMENT_NODE) {\n          n = n.nextSibling;\n        }\n        return n;\n      } else {\n        return nativeTree.nextElementSibling(this);\n      }\n    },\n    configurable: true\n  },\n\n  previousElementSibling: {\n    /**\n     * @this {HTMLElement}\n     */\n    get() {\n      if (this.__shady && this.__shady.previousSibling !== undefined) {\n        let n = this.previousSibling;\n        while (n && n.nodeType !== Node.ELEMENT_NODE) {\n          n = n.previousSibling;\n        }\n        return n;\n      } else {\n        return nativeTree.previousElementSibling(this);\n      }\n    },\n    configurable: true\n  }\n\n};\n\nlet InsideAccessors = {\n\n  childNodes: {\n    /**\n     * @this {HTMLElement}\n     */\n    get() {\n      let childNodes;\n      if (utils.isTrackingLogicalChildNodes(this)) {\n        if (!this.__shady.childNodes) {\n          this.__shady.childNodes = [];\n          for (let n=this.firstChild; n; n=n.nextSibling) {\n            this.__shady.childNodes.push(n);\n          }\n        }\n        childNodes = this.__shady.childNodes;\n      } else {\n        childNodes = nativeTree.childNodes(this);\n      }\n      childNodes.item = function(index) {\n        return childNodes[index];\n      }\n      return childNodes;\n    },\n    configurable: true\n  },\n\n  childElementCount: {\n    /** @this {HTMLElement} */\n    get() {\n      return this.children.length;\n    },\n    configurable: true\n  },\n\n  firstChild: {\n    /** @this {HTMLElement} */\n    get() {\n      let l = this.__shady && this.__shady.firstChild;\n      return l !== undefined ? l : nativeTree.firstChild(this);\n    },\n    configurable: true\n  },\n\n  lastChild: {\n  /** @this {HTMLElement} */\n    get() {\n      let l = this.__shady && this.__shady.lastChild;\n      return l !== undefined ? l : nativeTree.lastChild(this);\n    },\n    configurable: true\n  },\n\n  textContent: {\n    /**\n     * @this {HTMLElement}\n     */\n    get() {\n      if (utils.isTrackingLogicalChildNodes(this)) {\n        let tc = [];\n        for (let i = 0, cn = this.childNodes, c; (c = cn[i]); i++) {\n          if (c.nodeType !== Node.COMMENT_NODE) {\n            tc.push(c.textContent);\n          }\n        }\n        return tc.join('');\n      } else {\n        return nativeTree.textContent(this);\n      }\n    },\n    /**\n     * @this {HTMLElement}\n     * @param {string} text\n     */\n    set(text) {\n      if (typeof text === 'undefined' || text === null) {\n        text = ''\n      }\n      switch (this.nodeType) {\n        case Node.ELEMENT_NODE:\n        case Node.DOCUMENT_FRAGMENT_NODE:\n          clearNode(this);\n          // Document fragments must have no childnodes if setting a blank string\n          if (text.length > 0 || this.nodeType === Node.ELEMENT_NODE) {\n            this.appendChild(document.createTextNode(text));\n          }\n          break;\n        default:\n          // TODO(sorvell): can't do this if patch nodeValue.\n          this.nodeValue = text;\n          break;\n      }\n    },\n    configurable: true\n  },\n\n  // fragment, element, document\n  firstElementChild: {\n    /**\n     * @this {HTMLElement}\n     */\n    get() {\n      if (this.__shady && this.__shady.firstChild !== undefined) {\n        let n = this.firstChild;\n        while (n && n.nodeType !== Node.ELEMENT_NODE) {\n          n = n.nextSibling;\n        }\n        return n;\n      } else {\n        return nativeTree.firstElementChild(this);\n      }\n    },\n    configurable: true\n  },\n\n  lastElementChild: {\n    /**\n     * @this {HTMLElement}\n     */\n    get() {\n      if (this.__shady && this.__shady.lastChild !== undefined) {\n        let n = this.lastChild;\n        while (n && n.nodeType !== Node.ELEMENT_NODE) {\n          n = n.previousSibling;\n        }\n        return n;\n      } else {\n        return nativeTree.lastElementChild(this);\n      }\n    },\n    configurable: true\n  },\n\n  children: {\n    /**\n     * @this {HTMLElement}\n     */\n    get() {\n      let children;\n      if (utils.isTrackingLogicalChildNodes(this)) {\n        children = Array.prototype.filter.call(this.childNodes, function(n) {\n          return (n.nodeType === Node.ELEMENT_NODE);\n        });\n      } else {\n        children = nativeTree.children(this);\n      }\n      children.item = function(index) {\n        return children[index];\n      }\n      return children;\n    },\n    configurable: true\n  },\n\n  // element (HTMLElement on IE11)\n  innerHTML: {\n    /**\n     * @this {HTMLElement}\n     */\n    get() {\n      const content = this.localName === 'template' ?\n        /** @type {HTMLTemplateElement} */(this).content : this;\n      if (utils.isTrackingLogicalChildNodes(this)) {\n        return getInnerHTML(content);\n      } else {\n        return nativeTree.innerHTML(content);\n      }\n    },\n    /**\n     * @this {HTMLElement}\n     */\n    set(text) {\n      const content = this.localName === 'template' ?\n        /** @type {HTMLTemplateElement} */(this).content : this;\n      clearNode(content);\n      let containerName = this.localName;\n      if (!containerName || containerName === 'template') {\n        containerName = 'div';\n      }\n      const htmlContainer = inertDoc.createElement(containerName);\n      if (nativeInnerHTMLDesc && nativeInnerHTMLDesc.set) {\n        nativeInnerHTMLDesc.set.call(htmlContainer, text);\n      } else {\n        htmlContainer.innerHTML = text;\n      }\n      while (htmlContainer.firstChild) {\n        content.appendChild(htmlContainer.firstChild);\n      }\n    },\n    configurable: true\n  }\n\n};\n\n// Note: Can be patched on element prototype on all browsers.\n// Must be patched on instance on browsers that support native Shadow DOM\n// but do not have builtin accessors (old Chrome).\nexport let ShadowRootAccessor = {\n\n  shadowRoot: {\n    /**\n     * @this {HTMLElement}\n     */\n    get() {\n      return this.__shady && this.__shady.publicRoot || null;\n    },\n    configurable: true\n  }\n};\n\n// Note: Can be patched on document prototype on browsers with builtin accessors.\n// Must be patched separately on simulated ShadowRoot.\n// Must be patched as `_activeElement` on browsers without builtin accessors.\nexport let ActiveElementAccessor = {\n\n  activeElement: {\n    /**\n     * @this {HTMLElement}\n     */\n    get() {\n      return activeElementForNode(this);\n    },\n    /**\n     * @this {HTMLElement}\n     */\n    set() {},\n    configurable: true\n  }\n\n};\n\n// patch a group of descriptors on an object only if it exists or if the `force`\n// argument is true.\n/**\n * @param {!Object} obj\n * @param {!Object} descriptors\n * @param {boolean=} force\n */\nfunction patchAccessorGroup(obj, descriptors, force) {\n  for (let p in descriptors) {\n    let objDesc = Object.getOwnPropertyDescriptor(obj, p);\n    if ((objDesc && objDesc.configurable) ||\n      (!objDesc && force)) {\n      Object.defineProperty(obj, p, descriptors[p]);\n    } else if (force) {\n      console.warn('Could not define', p, 'on', obj);\n    }\n  }\n}\n\n// patch dom accessors on proto where they exist\nexport function patchAccessors(proto) {\n  patchAccessorGroup(proto, OutsideAccessors);\n  patchAccessorGroup(proto, InsideAccessors);\n  patchAccessorGroup(proto, ActiveElementAccessor);\n}\n\n// ensure element descriptors (IE/Edge don't have em)\nexport function patchShadowRootAccessors(proto) {\n  patchAccessorGroup(proto, InsideAccessors, true);\n  patchAccessorGroup(proto, ActiveElementAccessor, true);\n}\n\n// ensure an element has patched \"outside\" accessors; no-op when not needed\nexport let patchOutsideElementAccessors = utils.settings.hasDescriptors ?\n  function() {} : function(element) {\n    if (!(element.__shady && element.__shady.__outsideAccessors)) {\n      element.__shady = element.__shady || {};\n      element.__shady.__outsideAccessors = true;\n      patchAccessorGroup(element, OutsideAccessors, true);\n    }\n  }\n\n// ensure an element has patched \"inside\" accessors; no-op when not needed\nexport let patchInsideElementAccessors = utils.settings.hasDescriptors ?\n  function() {} : function(element) {\n    if (!(element.__shady && element.__shady.__insideAccessors)) {\n      element.__shady = element.__shady || {};\n      element.__shady.__insideAccessors = true;\n      patchAccessorGroup(element, InsideAccessors, true);\n      patchAccessorGroup(element, ShadowRootAccessor, true);\n    }\n  }\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport {patchInsideElementAccessors, patchOutsideElementAccessors} from './patch-accessors.js';\nimport {firstChild, lastChild, childNodes} from './native-tree.js';\n\nexport function recordInsertBefore(node, container, ref_node) {\n  patchInsideElementAccessors(container);\n  container.__shady = container.__shady || {};\n  if (container.__shady.firstChild !== undefined) {\n    container.__shady.childNodes = null;\n  }\n  // handle document fragments\n  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    let c$ = node.childNodes;\n    for (let i=0; i < c$.length; i++) {\n      linkNode(c$[i], container, ref_node);\n    }\n    // cleanup logical dom in doc fragment.\n    node.__shady = node.__shady || {};\n    let resetTo = (node.__shady.firstChild !== undefined) ? null : undefined;\n    node.__shady.firstChild = node.__shady.lastChild = resetTo;\n    node.__shady.childNodes = resetTo;\n  } else {\n    linkNode(node, container, ref_node);\n  }\n}\n\nfunction linkNode(node, container, ref_node) {\n  patchOutsideElementAccessors(node);\n  ref_node = ref_node || null;\n  node.__shady = node.__shady || {};\n  container.__shady = container.__shady || {};\n  if (ref_node) {\n    ref_node.__shady = ref_node.__shady || {};\n  }\n  // update ref_node.previousSibling <-> node\n  node.__shady.previousSibling = ref_node ? ref_node.__shady.previousSibling :\n    container.lastChild;\n  let ps = node.__shady.previousSibling;\n  if (ps && ps.__shady) {\n    ps.__shady.nextSibling = node;\n  }\n  // update node <-> ref_node\n  let ns = node.__shady.nextSibling = ref_node;\n  if (ns && ns.__shady) {\n    ns.__shady.previousSibling = node;\n  }\n  // update node <-> container\n  node.__shady.parentNode = container;\n  if (ref_node) {\n    if (ref_node === container.__shady.firstChild) {\n      container.__shady.firstChild = node;\n    }\n  } else {\n    container.__shady.lastChild = node;\n    if (!container.__shady.firstChild) {\n      container.__shady.firstChild = node;\n    }\n  }\n  // remove caching of childNodes\n  container.__shady.childNodes = null;\n}\n\nexport function recordRemoveChild(node, container) {\n  node.__shady = node.__shady || {};\n  container.__shady = container.__shady || {};\n  if (node === container.__shady.firstChild) {\n    container.__shady.firstChild = node.__shady.nextSibling;\n  }\n  if (node === container.__shady.lastChild) {\n    container.__shady.lastChild = node.__shady.previousSibling;\n  }\n  let p = node.__shady.previousSibling;\n  let n = node.__shady.nextSibling;\n  if (p) {\n    p.__shady = p.__shady || {};\n    p.__shady.nextSibling = n;\n  }\n  if (n) {\n    n.__shady = n.__shady || {};\n    n.__shady.previousSibling = p;\n  }\n  // When an element is removed, logical data is no longer tracked.\n  // Explicitly set `undefined` here to indicate this. This is disginguished\n  // from `null` which is set if info is null.\n  node.__shady.parentNode = node.__shady.previousSibling =\n    node.__shady.nextSibling = undefined;\n  if (container.__shady.childNodes !== undefined) {\n    // remove caching of childNodes\n    container.__shady.childNodes = null;\n  }\n}\n\nexport let recordChildNodes = function(node) {\n  if (!node.__shady || node.__shady.firstChild === undefined) {\n    node.__shady = node.__shady || {};\n    node.__shady.firstChild = firstChild(node);\n    node.__shady.lastChild = lastChild(node);\n    patchInsideElementAccessors(node);\n    let c$ = node.__shady.childNodes = childNodes(node);\n    for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n      n.__shady = n.__shady || {};\n      n.__shady.parentNode = node;\n      n.__shady.nextSibling = c$[i+1] || null;\n      n.__shady.previousSibling = c$[i-1] || null;\n      patchOutsideElementAccessors(n);\n    }\n  }\n}\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from './utils.js';\nimport * as logicalTree from './logical-tree.js';\nimport * as nativeMethods from './native-methods.js';\nimport {parentNode} from './native-tree.js';\n\n// Patched `insertBefore`. Note that all mutations that add nodes are routed\n// here. When a <slot> is added or a node is added to a host with a shadowRoot\n// with a slot, a standard dom `insert` call is aborted and `_asyncRender`\n// is called on the relevant shadowRoot. In all other cases, a standard dom\n// `insert` can be made, but the location and ref_node may need to be changed.\n/**\n * @param {Node} parent\n * @param {Node} node\n * @param {Node=} ref_node\n */\nexport function insertBefore(parent, node, ref_node) {\n  if (node === parent) {\n    throw Error(`Failed to execute 'appendChild' on 'Node': The new child element contains the parent.`);\n  }\n  if (ref_node) {\n    let p = ref_node.__shady && ref_node.__shady.parentNode;\n    if ((p !== undefined && p !== parent) ||\n      (p === undefined && parentNode(ref_node) !== parent)) {\n      throw Error(`Failed to execute 'insertBefore' on 'Node': The node ` +\n       `before which the new node is to be inserted is not a child of this node.`);\n    }\n  }\n  if (ref_node === node) {\n    return node;\n  }\n  // remove from existing location\n  if (node.parentNode) {\n    // NOTE: avoid node.removeChild as this *can* trigger another patched\n    // method (e.g. custom elements) and we want only the shady method to run.\n    removeChild(node.parentNode, node);\n  }\n  // add to new parent\n  let preventNativeInsert;\n  let ownerRoot = utils.ownerShadyRootForNode(parent);\n  // if a slot is added, must render containing root.\n  let slotsAdded = ownerRoot && findContainedSlots(node);\n  if (slotsAdded) {\n    ownerRoot._addSlots(slotsAdded);\n  }\n  if (ownerRoot && (parent.localName === 'slot' || slotsAdded)) {\n    ownerRoot._asyncRender();\n  }\n  if (utils.isTrackingLogicalChildNodes(parent)) {\n    logicalTree.recordInsertBefore(node, parent, ref_node);\n    // when inserting into a host with a shadowRoot with slot, use\n    // `shadowRoot._asyncRender()` via `attach-shadow` module\n    if (hasShadowRootWithSlot(parent)) {\n      parent.__shady.root._asyncRender();\n      preventNativeInsert = true;\n    // when inserting into a host with shadowRoot with NO slot, do nothing\n    // as the node should not be added to composed dome anywhere.\n    } else if (parent.__shady.root) {\n      preventNativeInsert = true;\n    }\n  }\n  if (!preventNativeInsert) {\n    // if adding to a shadyRoot, add to host instead\n    let container = utils.isShadyRoot(parent) ?\n      /** @type {ShadowRoot} */(parent).host : parent;\n    // if ref_node, get the ref_node that's actually in composed dom.\n    if (ref_node) {\n      ref_node = firstComposedNode(ref_node);\n      nativeMethods.insertBefore.call(container, node, ref_node);\n    } else {\n      nativeMethods.appendChild.call(container, node);\n    }\n  }\n  scheduleObserver(parent, node);\n  return node;\n}\n\nfunction findContainedSlots(node) {\n  if (!node['__noInsertionPoint']) {\n    let slots;\n    if (node.localName === 'slot') {\n      slots = [node];\n    } else if (node.querySelectorAll) {\n      slots = node.querySelectorAll('slot');\n    }\n    if (slots && slots.length) {\n      return slots;\n    }\n  }\n}\n\n/**\n * Patched `removeChild`. Note that all dom \"removals\" are routed here.\n * Removes the given `node` from the element's `children`.\n * This method also performs dom composition.\n * @param {Node} parent\n * @param {Node} node\n*/\nexport function removeChild(parent, node) {\n  if (node.parentNode !== parent) {\n    throw Error('The node to be removed is not a child of this node: ' +\n      node);\n  }\n  let preventNativeRemove;\n  let ownerRoot = utils.ownerShadyRootForNode(node);\n  let removingInsertionPoint;\n  if (utils.isTrackingLogicalChildNodes(parent)) {\n    logicalTree.recordRemoveChild(node, parent);\n    if (hasShadowRootWithSlot(parent)) {\n      parent.__shady.root._asyncRender();\n      preventNativeRemove = true;\n    }\n  }\n  removeOwnerShadyRoot(node);\n  // if removing slot, must render containing root\n  if (ownerRoot) {\n    let changeSlotContent = parent && parent.localName === 'slot';\n    if (changeSlotContent) {\n      preventNativeRemove = true;\n    }\n    removingInsertionPoint = ownerRoot._removeContainedSlots(node);\n    if (removingInsertionPoint || changeSlotContent) {\n      ownerRoot._asyncRender();\n    }\n  }\n  if (!preventNativeRemove) {\n    // if removing from a shadyRoot, remove form host instead\n    let container = utils.isShadyRoot(parent) ?\n      /** @type {ShadowRoot} */(parent).host :\n      parent;\n    // not guaranteed to physically be in container; e.g.\n    // (1) if parent has a shadyRoot, element may or may not at distributed\n    // location (could be undistributed)\n    // (2) if parent is a slot, element may not ben in composed dom\n    if (!(parent.__shady.root || node.localName === 'slot') ||\n      (container === parentNode(node))) {\n      nativeMethods.removeChild.call(container, node);\n    }\n  }\n  scheduleObserver(parent, null, node);\n  return node;\n}\n\nfunction removeOwnerShadyRoot(node) {\n  // optimization: only reset the tree if node is actually in a root\n  if (hasCachedOwnerRoot(node)) {\n    let c$ = node.childNodes;\n    for (let i=0, l=c$.length, n; (i<l) && (n=c$[i]); i++) {\n      removeOwnerShadyRoot(n);\n    }\n  }\n  if (node.__shady) {\n    node.__shady.ownerShadyRoot = undefined;\n  }\n}\n\nfunction hasCachedOwnerRoot(node) {\n  return Boolean(node.__shady && node.__shady.ownerShadyRoot !== undefined);\n}\n\n/**\n * Finds the first flattened node that is composed in the node's parent.\n * If the given node is a slot, then the first flattened node is returned\n * if it exists, otherwise advance to the node's nextSibling.\n * @param {Node} node within which to find first composed node\n * @returns {Node} first composed node\n */\nfunction firstComposedNode(node) {\n  let composed = node;\n  if (node && node.localName === 'slot') {\n    let flattened = node.__shady && node.__shady.flattenedNodes;\n    composed = flattened && flattened.length ? flattened[0] :\n      firstComposedNode(node.nextSibling);\n  }\n  return composed;\n}\n\nfunction hasShadowRootWithSlot(node) {\n  let root = node && node.__shady && node.__shady.root;\n  return (root && root._hasInsertionPoint());\n}\n\n/**\n * Should be called whenever an attribute changes. If the `slot` attribute\n * changes, provokes rendering if necessary. If a `<slot>` element's `name`\n * attribute changes, updates the root's slot map and renders.\n * @param {Node} node\n * @param {string} name\n */\nfunction distributeAttributeChange(node, name) {\n  if (name === 'slot') {\n    const parent = node.parentNode;\n    if (hasShadowRootWithSlot(parent)) {\n      parent.__shady.root._asyncRender();\n    }\n  } else if (node.localName === 'slot' && name === 'name') {\n    let root = utils.ownerShadyRootForNode(node);\n    if (root) {\n      root._updateSlotName(node);\n      root._asyncRender();\n    }\n  }\n}\n\n/**\n * @param {Node} node\n * @param {Node=} addedNode\n * @param {Node=} removedNode\n */\nfunction scheduleObserver(node, addedNode, removedNode) {\n  let observer = node.__shady && node.__shady.observer;\n  if (observer) {\n    if (addedNode) {\n      observer.addedNodes.push(addedNode);\n    }\n    if (removedNode) {\n      observer.removedNodes.push(removedNode);\n    }\n    observer.schedule();\n  }\n}\n\n/**\n * @param {Node} node\n * @param {Object=} options\n */\nexport function getRootNode(node, options) { // eslint-disable-line no-unused-vars\n  if (!node || !node.nodeType) {\n    return;\n  }\n  node.__shady = node.__shady || {};\n  let root = node.__shady.ownerShadyRoot;\n  if (root === undefined) {\n    if (utils.isShadyRoot(node)) {\n      root = node;\n    } else {\n      let parent = node.parentNode;\n      root = parent ? getRootNode(parent) : node;\n    }\n    // memo-ize result for performance but only memo-ize\n    // result if node is in the document. This avoids a problem where a root\n    // can be cached while an element is inside a fragment.\n    // If this happens and we cache the result, the value can become stale\n    // because for perf we avoid processing the subtree of added fragments.\n    if (nativeMethods.contains.call(document.documentElement, node)) {\n      node.__shady.ownerShadyRoot = root;\n    }\n  }\n  return root;\n}\n\n// NOTE: `query` is used primarily for ShadyDOM's querySelector impl,\n// but it's also generally useful to recurse through the element tree\n// and is used by Polymer's styling system.\n/**\n * @param {Node} node\n * @param {Function} matcher\n * @param {Function=} halter\n */\nexport function query(node, matcher, halter) {\n  let list = [];\n  queryElements(node.childNodes, matcher,\n    halter, list);\n  return list;\n}\n\nfunction queryElements(elements, matcher, halter, list) {\n  for (let i=0, l=elements.length, c; (i<l) && (c=elements[i]); i++) {\n    if (c.nodeType === Node.ELEMENT_NODE &&\n        queryElement(c, matcher, halter, list)) {\n      return true;\n    }\n  }\n}\n\nfunction queryElement(node, matcher, halter, list) {\n  let result = matcher(node);\n  if (result) {\n    list.push(node);\n  }\n  if (halter && halter(result)) {\n    return result;\n  }\n  queryElements(node.childNodes, matcher,\n    halter, list);\n}\n\nexport function renderRootNode(element) {\n  var root = element.getRootNode();\n  if (utils.isShadyRoot(root)) {\n    root._render();\n  }\n}\n\nlet scopingShim = null;\n\nexport function setAttribute(node, attr, value) {\n  if (!scopingShim) {\n    scopingShim = window['ShadyCSS'] && window['ShadyCSS']['ScopingShim'];\n  }\n  if (scopingShim && attr === 'class') {\n    scopingShim['setElementClass'](node, value);\n  } else {\n    nativeMethods.setAttribute.call(node, attr, value);\n    distributeAttributeChange(node, attr);\n  }\n}\n\nexport function removeAttribute(node, attr) {\n  nativeMethods.removeAttribute.call(node, attr);\n  distributeAttributeChange(node, attr);\n}\n\nexport function cloneNode(node, deep) {\n  if (node.localName == 'template') {\n    return nativeMethods.cloneNode.call(node, deep);\n  } else {\n    let n = nativeMethods.cloneNode.call(node, false);\n    if (deep) {\n      let c$ = node.childNodes;\n      for (let i=0, nc; i < c$.length; i++) {\n        nc = c$[i].cloneNode(true);\n        n.appendChild(nc);\n      }\n    }\n    return n;\n  }\n}\n\n// note: Though not technically correct, we fast path `importNode`\n// when called on a node not owned by the main document.\n// This allows, for example, elements that cannot\n// contain custom elements and are therefore not likely to contain shadowRoots\n// to cloned natively. This is a fairly significant performance win.\nexport function importNode(node, deep) {\n  if (node.ownerDocument !== document) {\n    return nativeMethods.importNode.call(document, node, deep);\n  }\n  let n = nativeMethods.importNode.call(document, node, false);\n  if (deep) {\n    let c$ = node.childNodes;\n    for (let i=0, nc; i < c$.length; i++) {\n      nc = importNode(c$[i], true);\n      n.appendChild(nc);\n    }\n  }\n  return n;\n}","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as mutation from './logical-mutation.js';\nimport {calculateSplices} from './array-splice.js';\nimport * as utils from './utils.js';\nimport {enqueue} from './flush.js';\nimport {recordChildNodes} from './logical-tree.js';\nimport {removeChild, insertBefore, dispatchEvent} from './native-methods.js';\nimport {parentNode, childNodes} from './native-tree.js';\nimport {patchShadowRootAccessors} from './patch-accessors.js';\n\n// Do not export this object. It must be passed as the first argument to the\n// ShadyRoot constructor in `attachShadow` to prevent the constructor from\n// throwing. This prevents the user from being able to manually construct a\n// ShadyRoot (i.e. `new ShadowRoot()`).\nconst ShadyRootConstructionToken = {};\n\nconst CATCHALL_NAME = '__catchall';\n\n/**\n * @constructor\n * @extends {ShadowRoot}\n */\nexport let ShadyRoot = function(token, host, options) {\n  if (token !== ShadyRootConstructionToken) {\n    throw new TypeError('Illegal constructor');\n  }\n  // NOTE: this strange construction is necessary because\n  // DocumentFragment cannot be subclassed on older browsers.\n  let shadowRoot = document.createDocumentFragment();\n  shadowRoot.__proto__ = ShadyRoot.prototype;\n  /** @type {ShadyRoot} */ (shadowRoot)._init(host, options);\n  return shadowRoot;\n};\n\nShadyRoot.prototype = Object.create(DocumentFragment.prototype);\n\nShadyRoot.prototype._init = function(host, options) {\n  // NOTE: set a fake local name so this element can be\n  // distinguished from a DocumentFragment when patching.\n  // FF doesn't allow this to be `localName`\n  this.__localName = 'ShadyRoot';\n  // logical dom setup\n  recordChildNodes(host);\n  recordChildNodes(this);\n  // root <=> host\n  this.host = host;\n  this._mode = options && options.mode;\n  host.__shady = host.__shady || {};\n  host.__shady.root = this;\n  host.__shady.publicRoot = this._mode !== 'closed' ? this : null;\n  // state flags\n  this._renderPending = false;\n  this._hasRendered = false;\n  this._slotList = [];\n  this._slotMap = {};\n  this.__pendingSlots = [];\n  // fast path initial render: remove existing physical dom.\n  let c$ = childNodes(host);\n  for (let i=0, l=c$.length; i < l; i++) {\n    removeChild.call(host, c$[i])\n  }\n}\n\n// async render\nShadyRoot.prototype._asyncRender = function() {\n  if (!this._renderPending) {\n    this._renderPending = true;\n    enqueue(() => this._render());\n  }\n}\n\n// returns the oldest renderPending ancestor root.\nShadyRoot.prototype._getRenderRoot = function() {\n  let renderRoot;\n  let root = this;\n  while (root) {\n    if (root._renderPending) {\n      renderRoot = root;\n    }\n    root = root._rendererForHost();\n  }\n  return renderRoot;\n}\n\n// Returns the shadyRoot `this.host` if `this.host`\n// has children that require distribution.\nShadyRoot.prototype._rendererForHost = function() {\n  let root = this.host.getRootNode();\n  if (utils.isShadyRoot(root)) {\n    let c$ = this.host.childNodes;\n    for (let i=0, c; i < c$.length; i++) {\n      c = c$[i];\n      if (this._isInsertionPoint(c)) {\n        return root;\n      }\n    }\n  }\n}\n\nShadyRoot.prototype._render = function() {\n  const root = this._getRenderRoot();\n  if (root) {\n    root['_renderRoot']();\n  }\n}\n\n// NOTE: avoid renaming to ease testability.\nShadyRoot.prototype['_renderRoot'] = function() {\n  this._renderPending = false;\n  this._distribute();\n  this._compose();\n  this._hasRendered = true;\n}\n\nShadyRoot.prototype._distribute = function() {\n  this._validateSlots();\n  // capture # of previously assigned nodes to help determine if dirty.\n  for (let i=0, slot; i < this._slotList.length; i++) {\n    slot = this._slotList[i];\n    this._clearSlotAssignedNodes(slot);\n  }\n  // distribute host children.\n  for (let n=this.host.firstChild; n; n=n.nextSibling) {\n    this._distributeNodeToSlot(n);\n  }\n  // fallback content, slotchange, and dirty roots\n  for (let i=0, slot; i < this._slotList.length; i++) {\n    slot = this._slotList[i];\n    // distribute fallback content\n    if (!slot.__shady.assignedNodes.length) {\n      for (let n=slot.firstChild; n; n=n.nextSibling) {\n        this._distributeNodeToSlot(n, slot);\n      }\n    }\n    const slotParent = slot.parentNode;\n    const slotParentRoot = slotParent.__shady && slotParent.__shady.root;\n    if (slotParentRoot && slotParentRoot._hasInsertionPoint()) {\n      slotParentRoot['_renderRoot']();\n    }\n    this._addAssignedToFlattenedNodes(slot.__shady.flattenedNodes,\n      slot.__shady.assignedNodes);\n    let prevAssignedNodes = slot.__shady._previouslyAssignedNodes;\n    if (prevAssignedNodes) {\n      for (let i=0; i < prevAssignedNodes.length; i++) {\n        prevAssignedNodes[i].__shady._prevAssignedSlot = null;\n      }\n      slot.__shady._previouslyAssignedNodes = null;\n      // dirty if previously less assigned nodes than previously assigned.\n      if (prevAssignedNodes.length > slot.__shady.assignedNodes.length) {\n        slot.__shady.dirty = true;\n      }\n    }\n    /* Note: A slot is marked dirty whenever a node is newly assigned to it\n    or a node is assigned to a different slot (done in `_distributeNodeToSlot`)\n    or if the number of nodes assigned to the slot has decreased (done above);\n     */\n    if (slot.__shady.dirty) {\n      slot.__shady.dirty = false;\n      this._fireSlotChange(slot);\n    }\n  }\n}\n\n/**\n * Distributes given `node` to the appropriate slot based on its `slot`\n * attribute. If `forcedSlot` is given, then the node is distributed to the\n * `forcedSlot`.\n * Note: slot to which the node is assigned will be marked dirty for firing\n * `slotchange`.\n * @param {Node} node\n * @param {Node=} forcedSlot\n *\n */\nShadyRoot.prototype._distributeNodeToSlot = function(node, forcedSlot) {\n  node.__shady = node.__shady || {};\n  let oldSlot = node.__shady._prevAssignedSlot;\n  node.__shady._prevAssignedSlot = null;\n  let slot = forcedSlot;\n  if (!slot) {\n    let name = node.slot || CATCHALL_NAME;\n    const list = this._slotMap[name];\n    slot = list && list[0];\n  }\n  if (slot) {\n    slot.__shady.assignedNodes.push(node);\n    node.__shady.assignedSlot = slot;\n  } else {\n    node.__shady.assignedSlot = undefined;\n  }\n  if (oldSlot !== node.__shady.assignedSlot) {\n    if (node.__shady.assignedSlot) {\n      node.__shady.assignedSlot.__shady.dirty = true;\n    }\n  }\n}\n\n/**\n * Clears the assignedNodes tracking data for a given `slot`. Note, the current\n * assigned node data is tracked (via _previouslyAssignedNodes and\n * _prevAssignedSlot) to see if `slotchange` should fire. This data may be out\n *  of date at this time because the assigned nodes may have already been\n * distributed to another root. This is ok since this data is only used to\n * track changes.\n * @param {HTMLSlotElement} slot\n */\nShadyRoot.prototype._clearSlotAssignedNodes = function(slot) {\n  let n$ = slot.__shady.assignedNodes;\n  slot.__shady.assignedNodes = [];\n  slot.__shady.flattenedNodes = [];\n  slot.__shady._previouslyAssignedNodes = n$;\n  if (n$) {\n    for (let i=0; i < n$.length; i++) {\n      let n = n$[i];\n      n.__shady._prevAssignedSlot = n.__shady.assignedSlot;\n      // only clear if it was previously set to this slot;\n      // this helps ensure that if the node has otherwise been distributed\n      // ignore it.\n      if (n.__shady.assignedSlot === slot) {\n        n.__shady.assignedSlot = null;\n      }\n    }\n  }\n}\n\nShadyRoot.prototype._addAssignedToFlattenedNodes = function(flattened, assigned) {\n  for (let i=0, n; (i<assigned.length) && (n=assigned[i]); i++) {\n    if (n.localName == 'slot') {\n      const nestedAssigned = n.__shady.assignedNodes;\n      if (nestedAssigned && nestedAssigned.length) {\n        this._addAssignedToFlattenedNodes(flattened, nestedAssigned);\n      }\n    } else {\n      flattened.push(assigned[i]);\n    }\n  }\n}\n\nShadyRoot.prototype._fireSlotChange = function(slot) {\n  // NOTE: cannot bubble correctly here so not setting bubbles: true\n  // Safari tech preview does not bubble but chrome does\n  // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)\n  dispatchEvent.call(slot, new Event('slotchange'));\n  if (slot.__shady.assignedSlot) {\n    this._fireSlotChange(slot.__shady.assignedSlot);\n  }\n}\n\n// Reify dom such that it is at its correct rendering position\n// based on logical distribution.\n// NOTE: here we only compose parents of <slot> elements and not the\n// shadowRoot into the host. The latter is performend via a fast path\n// in the `logical-mutation`.insertBefore.\nShadyRoot.prototype._compose = function() {\n  const slots = this._slotList;\n  let composeList = [];\n  for (let i=0; i < slots.length; i++) {\n    const parent = slots[i].parentNode;\n    /* compose node only if:\n      (1) parent does not have a shadowRoot since shadowRoot has already\n      composed into the host\n      (2) we're not already composing it\n      [consider (n^2) but rare better than Set]\n    */\n    if (!(parent.__shady && parent.__shady.root) &&\n      composeList.indexOf(parent) < 0) {\n      composeList.push(parent);\n    }\n  }\n  for (let i=0; i < composeList.length; i++) {\n    const node = composeList[i];\n    const targetNode = node === this ? this.host : node;\n    this._updateChildNodes(targetNode, this._composeNode(node));\n  }\n}\n\n// Returns the list of nodes which should be rendered inside `node`.\nShadyRoot.prototype._composeNode = function(node) {\n  let children = [];\n  let c$ = node.childNodes;\n  for (let i = 0; i < c$.length; i++) {\n    let child = c$[i];\n    // Note: if we see a slot here, the nodes are guaranteed to need to be\n    // composed here. This is because if there is redistribution, it has\n    // already been handled by this point.\n    if (this._isInsertionPoint(child)) {\n      let flattenedNodes = child.__shady.flattenedNodes;\n      for (let j = 0; j < flattenedNodes.length; j++) {\n        let distributedNode = flattenedNodes[j];\n          children.push(distributedNode);\n      }\n    } else {\n      children.push(child);\n    }\n  }\n  return children;\n}\n\nShadyRoot.prototype._isInsertionPoint = function(node) {\n    return node.localName == 'slot';\n  }\n\n// Ensures that the rendered node list inside `container` is `children`.\nShadyRoot.prototype._updateChildNodes = function(container, children) {\n  let composed = childNodes(container);\n  let splices = calculateSplices(children, composed);\n  // process removals\n  for (let i=0, d=0, s; (i<splices.length) && (s=splices[i]); i++) {\n    for (let j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {\n      // check if the node is still where we expect it is before trying\n      // to remove it; this can happen if we move a node and\n      // then schedule its previous host for distribution resulting in\n      // the node being removed here.\n      if (parentNode(n) === container) {\n        removeChild.call(container, n);\n      }\n      composed.splice(s.index + d, 1);\n    }\n    d -= s.addedCount;\n  }\n  // process adds\n  for (let i=0, s, next; (i<splices.length) && (s=splices[i]); i++) { //eslint-disable-line no-redeclare\n    next = composed[s.index];\n    for (let j=s.index, n; j < s.index + s.addedCount; j++) {\n      n = children[j];\n      insertBefore.call(container, n, next);\n      composed.splice(j, 0, n);\n    }\n  }\n}\n\nShadyRoot.prototype._addSlots = function(slots) {\n  this.__pendingSlots.push(...slots);\n}\n\nShadyRoot.prototype._validateSlots = function() {\n  if (this.__pendingSlots.length) {\n    this._mapSlots(this.__pendingSlots);\n    this.__pendingSlots = [];\n  }\n}\n\n/**\n * Adds the given slots. Slots are maintained in an dom-ordered list.\n * In addition a map of name to slot is updated.\n */\nShadyRoot.prototype._mapSlots = function(slots) {\n  let slotNamesToSort;\n  for (let i=0; i < slots.length; i++) {\n    let slot = slots[i];\n    // ensure insertionPoints's and their parents have logical dom info.\n    // save logical tree info\n    // a. for shadyRoot\n    // b. for insertion points (fallback)\n    // c. for parents of insertion points\n    slot.__shady = slot.__shady || {};\n    recordChildNodes(slot);\n    recordChildNodes(slot.parentNode);\n    let name = this._nameForSlot(slot);\n    if (this._slotMap[name]) {\n      slotNamesToSort = slotNamesToSort || {};\n      slotNamesToSort[name] = true;\n      this._slotMap[name].push(slot);\n    } else {\n      this._slotMap[name] = [slot];\n    }\n    this._slotList.push(slot);\n  }\n  if (slotNamesToSort) {\n    for (let n in slotNamesToSort) {\n      this._slotMap[n] = this._sortSlots(this._slotMap[n]);\n    }\n  }\n}\n\nShadyRoot.prototype._nameForSlot = function(slot) {\n  const name = slot['name'] || slot.getAttribute('name') || CATCHALL_NAME;\n  slot.__slotName = name;\n  return name;\n}\n\n/**\n * Slots are kept in an ordered list. Slots with the same name\n * are sorted here by tree order.\n */\nShadyRoot.prototype._sortSlots = function(slots) {\n  // NOTE: Cannot use `compareDocumentPosition` because it's not polyfilled,\n  // but the code here could be used to polyfill the preceeding/following info\n  // in `compareDocumentPosition`.\n  return slots.sort((a, b) => {\n    let listA = ancestorList(a);\n    let listB = ancestorList(b);\n    for (var i=0; i < listA.length; i++) {\n      let nA = listA[i];\n      let nB = listB[i];\n      if (nA !== nB) {\n        let c$ = Array.from(nA.parentNode.childNodes);\n        return c$.indexOf(nA) - c$.indexOf(nB);\n      }\n    }\n  });\n}\n\nfunction ancestorList(node) {\n  let ancestors = [];\n  do {\n    ancestors.unshift(node);\n  } while ((node = node.parentNode));\n  return ancestors;\n}\n\n/**\n * Removes from tracked slot data any slots contained within `container` and\n * then updates the tracked data (_slotList and _slotMap).\n * Any removed slots also have their `assignedNodes` removed from comopsed dom.\n */\nShadyRoot.prototype._removeContainedSlots = function(container) {\n  this._validateSlots();\n  let didRemove;\n  const map = this._slotMap;\n  for (let n in map) {\n    let slots = map[n];\n    for (let i=0; i < slots.length; i++) {\n      let slot = slots[i];\n      if (utils.contains(container, slot)) {\n        slots.splice(i, 1);\n        const x = this._slotList.indexOf(slot);\n        if (x >= 0) {\n          this._slotList.splice(x, 1);\n        }\n        i--;\n        this._removeFlattenedNodes(slot);\n        didRemove = true;\n      }\n    }\n  }\n  return didRemove;\n}\n\nShadyRoot.prototype._updateSlotName = function(slot) {\n  const oldName = slot.__slotName;\n  const name = this._nameForSlot(slot);\n  if (name === oldName) {\n    return;\n  }\n  // remove from existing tracking\n  let slots = this._slotMap[oldName];\n  const i = slots.indexOf(slot);\n  if (i >= 0) {\n    slots.splice(i, 1);\n  }\n  // add to new location and sort if nedessary\n  let list = this._slotMap[name] || (this._slotMap[name] = []);\n  list.push(slot);\n  if (list.length > 1) {\n    this._slotMap[name] = this._sortSlots(list);\n  }\n}\n\nShadyRoot.prototype._removeFlattenedNodes = function(slot) {\n  let n$ = slot.__shady.flattenedNodes;\n  if (n$) {\n    for (let i=0; i<n$.length; i++) {\n      let node = n$[i];\n      let parent = parentNode(node);\n      if (parent) {\n        removeChild.call(parent, node);\n      }\n    }\n  }\n}\n\nShadyRoot.prototype._hasInsertionPoint = function() {\n  this._validateSlots();\n  return Boolean(this._slotList.length);\n}\n\nShadyRoot.prototype.addEventListener = function(type, fn, optionsOrCapture) {\n  if (typeof optionsOrCapture !== 'object') {\n    optionsOrCapture = {\n      capture: Boolean(optionsOrCapture)\n    }\n  }\n  optionsOrCapture.__shadyTarget = this;\n  this.host.addEventListener(type, fn, optionsOrCapture);\n}\n\nShadyRoot.prototype.removeEventListener = function(type, fn, optionsOrCapture) {\n  if (typeof optionsOrCapture !== 'object') {\n    optionsOrCapture = {\n      capture: Boolean(optionsOrCapture)\n    }\n  }\n  optionsOrCapture.__shadyTarget = this;\n  this.host.removeEventListener(type, fn, optionsOrCapture);\n}\n\nShadyRoot.prototype.getElementById = function(id) {\n  let result = mutation.query(this, function(n) {\n    return n.id == id;\n  }, function(n) {\n    return Boolean(n);\n  })[0];\n  return result || null;\n}\n\n/**\n  Implements a pared down version of ShadowDOM's scoping, which is easy to\n  polyfill across browsers.\n*/\nexport function attachShadow(host, options) {\n  if (!host) {\n    throw 'Must provide a host.';\n  }\n  if (!options) {\n    throw 'Not enough arguments.'\n  }\n  return new ShadyRoot(ShadyRootConstructionToken, host, options);\n}\n\npatchShadowRootAccessors(ShadyRoot.prototype);",null,"/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from './utils.js';\n\n// render enqueuer/flusher\nlet flushList = [];\nlet scheduled;\nexport function enqueue(callback) {\n  if (!scheduled) {\n    scheduled = true;\n    utils.microtask(flush);\n  }\n  flushList.push(callback);\n}\n\nexport function flush() {\n  scheduled = false;\n  let didFlush = Boolean(flushList.length);\n  while (flushList.length) {\n    flushList.shift()();\n  }\n  return didFlush;\n}\n\nflush['list'] = flushList;\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from './utils.js';\n\nclass AsyncObserver {\n\n  constructor() {\n    this._scheduled = false;\n    this.addedNodes = [];\n    this.removedNodes = [];\n    this.callbacks = new Set();\n  }\n\n  schedule() {\n    if (!this._scheduled) {\n      this._scheduled = true;\n      utils.microtask(() => {\n        this.flush();\n      });\n    }\n  }\n\n  flush() {\n    if (this._scheduled) {\n      this._scheduled = false;\n      let mutations = this.takeRecords();\n      if (mutations.length) {\n        this.callbacks.forEach(function(cb) {\n          cb(mutations);\n        });\n      }\n    }\n  }\n\n  takeRecords() {\n    if (this.addedNodes.length || this.removedNodes.length) {\n      let mutations = [{\n        addedNodes: this.addedNodes,\n        removedNodes: this.removedNodes\n      }];\n      this.addedNodes = [];\n      this.removedNodes = [];\n      return mutations;\n    }\n    return [];\n  }\n\n}\n\n// TODO(sorvell): consider instead polyfilling MutationObserver\n// directly so that users do not have to fork their code.\n// Supporting the entire api may be challenging: e.g. filtering out\n// removed nodes in the wrong scope and seeing non-distributing\n// subtree child mutations.\nexport let observeChildren = function(node, callback) {\n  node.__shady = node.__shady || {};\n  if (!node.__shady.observer) {\n    node.__shady.observer = new AsyncObserver();\n  }\n  node.__shady.observer.callbacks.add(callback);\n  let observer = node.__shady.observer;\n  return {\n    _callback: callback,\n    _observer: observer,\n    _node: node,\n    takeRecords() {\n      return observer.takeRecords()\n    }\n  };\n}\n\nexport let unobserveChildren = function(handle) {\n  let observer = handle && handle._observer;\n  if (observer) {\n    observer.callbacks.delete(handle._callback);\n    if (!observer.callbacks.size) {\n      handle._node.__shady.observer = null;\n    }\n  }\n}\n\nexport function filterMutations(mutations, target) {\n  /** @const {Node} */\n  const targetRootNode = target.getRootNode();\n  return mutations.map(function(mutation) {\n    /** @const {boolean} */\n    const mutationInScope = (targetRootNode === mutation.target.getRootNode());\n    if (mutationInScope && mutation.addedNodes) {\n      let nodes = Array.from(mutation.addedNodes).filter(function(n) {\n        return (targetRootNode === n.getRootNode());\n      });\n      if (nodes.length) {\n        mutation = Object.create(mutation);\n        Object.defineProperty(mutation, 'addedNodes', {\n          value: nodes,\n          configurable: true\n        });\n        return mutation;\n      }\n    } else if (mutationInScope) {\n      return mutation;\n    }\n  }).filter(function(m) { return m});\n}\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from './utils.js';\nimport * as nativeMethods from './native-methods.js';\n\n/*\nMake this name unique so it is unlikely to conflict with properties on objects passed to `addEventListener`\nhttps://github.com/webcomponents/shadydom/issues/173\n*/\nconst /** string */ eventWrappersName = `__eventWrappers${Date.now()}`;\n\n// https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937\nlet alwaysComposed = {\n  'blur': true,\n  'focus': true,\n  'focusin': true,\n  'focusout': true,\n  'click': true,\n  'dblclick': true,\n  'mousedown': true,\n  'mouseenter': true,\n  'mouseleave': true,\n  'mousemove': true,\n  'mouseout': true,\n  'mouseover': true,\n  'mouseup': true,\n  'wheel': true,\n  'beforeinput': true,\n  'input': true,\n  'keydown': true,\n  'keyup': true,\n  'compositionstart': true,\n  'compositionupdate': true,\n  'compositionend': true,\n  'touchstart': true,\n  'touchend': true,\n  'touchmove': true,\n  'touchcancel': true,\n  'pointerover': true,\n  'pointerenter': true,\n  'pointerdown': true,\n  'pointermove': true,\n  'pointerup': true,\n  'pointercancel': true,\n  'pointerout': true,\n  'pointerleave': true,\n  'gotpointercapture': true,\n  'lostpointercapture': true,\n  'dragstart': true,\n  'drag': true,\n  'dragenter': true,\n  'dragleave': true,\n  'dragover': true,\n  'drop': true,\n  'dragend': true,\n  'DOMActivate': true,\n  'DOMFocusIn': true,\n  'DOMFocusOut': true,\n  'keypress': true\n};\n\nfunction pathComposer(startNode, composed) {\n  let composedPath = [];\n  let current = startNode;\n  let startRoot = startNode === window ? window : startNode.getRootNode();\n  while (current) {\n    composedPath.push(current);\n    if (current.assignedSlot) {\n      current = current.assignedSlot;\n    } else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {\n      current = current.host;\n    } else {\n      current = current.parentNode;\n    }\n  }\n  // event composedPath includes window when startNode's ownerRoot is document\n  if (composedPath[composedPath.length - 1] === document) {\n    composedPath.push(window);\n  }\n  return composedPath;\n}\n\nfunction retarget(refNode, path) {\n  if (!utils.isShadyRoot) {\n    return refNode;\n  }\n  // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's\n  // shadow-including inclusive ancestor, return ANCESTOR.\n  let refNodePath = pathComposer(refNode, true);\n  let p$ = path;\n  for (let i=0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {\n    ancestor = p$[i];\n    root = ancestor === window ? window : ancestor.getRootNode();\n    if (root !== lastRoot) {\n      rootIdx = refNodePath.indexOf(root);\n      lastRoot = root;\n    }\n    if (!utils.isShadyRoot(root) || rootIdx > -1) {\n      return ancestor;\n    }\n  }\n}\n\nlet eventMixin = {\n\n  /**\n   * @this {Event}\n   */\n  get composed() {\n    // isTrusted may not exist in this browser, so just check if isTrusted is explicitly false\n    if (this.isTrusted !== false && this.__composed === undefined) {\n      this.__composed = alwaysComposed[this.type];\n    }\n    return this.__composed || false;\n  },\n\n  /**\n   * @this {Event}\n   */\n  composedPath() {\n    if (!this.__composedPath) {\n      this.__composedPath = pathComposer(this['__target'], this.composed);\n    }\n    return this.__composedPath;\n  },\n\n  /**\n   * @this {Event}\n   */\n  get target() {\n    return retarget(this.currentTarget, this.composedPath());\n  },\n\n  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting\n  /**\n   * @this {Event}\n   */\n  get relatedTarget() {\n    if (!this.__relatedTarget) {\n      return null;\n    }\n    if (!this.__relatedTargetComposedPath) {\n      this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);\n    }\n    // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget\n    return retarget(this.currentTarget, this.__relatedTargetComposedPath);\n  },\n  /**\n   * @this {Event}\n   */\n  stopPropagation() {\n    Event.prototype.stopPropagation.call(this);\n    this.__propagationStopped = true;\n  },\n  /**\n   * @this {Event}\n   */\n  stopImmediatePropagation() {\n    Event.prototype.stopImmediatePropagation.call(this);\n    this.__immediatePropagationStopped = true;\n    this.__propagationStopped = true;\n  }\n\n};\n\nfunction mixinComposedFlag(Base) {\n  // NOTE: avoiding use of `class` here so that transpiled output does not\n  // try to do `Base.call` with a dom construtor.\n  let klazz = function(type, options) {\n    let event = new Base(type, options);\n    event.__composed = options && Boolean(options['composed']);\n    return event;\n  }\n  // put constructor properties on subclass\n  utils.mixin(klazz, Base);\n  klazz.prototype = Base.prototype;\n  return klazz;\n}\n\nlet nonBubblingEventsToRetarget = {\n  'focus': true,\n  'blur': true\n};\n\n\n/**\n * Check if the event has been retargeted by comparing original `target`, and calculated `target`\n * @param {Event} event\n * @return {boolean} True if the original target and calculated target are the same\n */\nfunction hasRetargeted(event) {\n  return event['__target'] !== event.target || event.__relatedTarget !== event.relatedTarget;\n}\n\n/**\n *\n * @param {Event} event\n * @param {Node} node\n * @param {string} phase\n */\nfunction fireHandlers(event, node, phase) {\n  let hs = node.__handlers && node.__handlers[event.type] &&\n    node.__handlers[event.type][phase];\n  if (hs) {\n    for (let i = 0, fn; (fn = hs[i]); i++) {\n      if (hasRetargeted(event) && event.target === event.relatedTarget) {\n        return;\n      }\n      fn.call(node, event);\n      if (event.__immediatePropagationStopped) {\n        return;\n      }\n    }\n  }\n}\n\nfunction retargetNonBubblingEvent(e) {\n  let path = e.composedPath();\n  let node;\n  // override `currentTarget` to let patched `target` calculate correctly\n  Object.defineProperty(e, 'currentTarget', {\n    get: function() {\n      return node;\n    },\n    configurable: true\n  });\n  for (let i = path.length - 1; i >= 0; i--) {\n    node = path[i];\n    // capture phase fires all capture handlers\n    fireHandlers(e, node, 'capture');\n    if (e.__propagationStopped) {\n      return;\n    }\n  }\n\n  // set the event phase to `AT_TARGET` as in spec\n  Object.defineProperty(e, 'eventPhase', {get() { return Event.AT_TARGET }});\n\n  // the event only needs to be fired when owner roots change when iterating the event path\n  // keep track of the last seen owner root\n  let lastFiredRoot;\n  for (let i = 0; i < path.length; i++) {\n    node = path[i];\n    const root = node.__shady && node.__shady.root;\n    if (i === 0 || (root && root === lastFiredRoot)) {\n      fireHandlers(e, node, 'bubble');\n      // don't bother with window, it doesn't have `getRootNode` and will be last in the path anyway\n      if (node !== window) {\n        lastFiredRoot = node.getRootNode();\n      }\n      if (e.__propagationStopped) {\n        return;\n      }\n    }\n  }\n}\n\nfunction listenerSettingsEqual(savedListener, node, type, capture, once, passive) {\n  let {\n    node: savedNode,\n    type: savedType,\n    capture: savedCapture,\n    once: savedOnce,\n    passive: savedPassive\n  } = savedListener;\n  return node === savedNode &&\n    type === savedType &&\n    capture === savedCapture &&\n    once === savedOnce &&\n    passive === savedPassive;\n}\n\nexport function findListener(wrappers, node, type, capture, once, passive) {\n  for (let i = 0; i < wrappers.length; i++) {\n    if (listenerSettingsEqual(wrappers[i], node, type, capture, once, passive)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Firefox can throw on accessing eventWrappers inside of `removeEventListener` during a selenium run\n * Try/Catch accessing eventWrappers to work around\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1353074\n */\nfunction getEventWrappers(eventLike) {\n  let wrappers = null;\n  try {\n    wrappers = eventLike[eventWrappersName];\n  } catch (e) {} // eslint-disable-line no-empty\n  return wrappers;\n}\n\n/**\n * @this {Event}\n */\nexport function addEventListener(type, fnOrObj, optionsOrCapture) {\n  if (!fnOrObj) {\n    return;\n  }\n\n  const handlerType = typeof fnOrObj;\n\n  // bail if `fnOrObj` is not a function, not an object\n  if (handlerType !== 'function' && handlerType !== 'object') {\n    return;\n  }\n\n  // bail if `fnOrObj` is an object without a `handleEvent` method\n  if (handlerType === 'object' && (!fnOrObj.handleEvent || typeof fnOrObj.handleEvent !== 'function')) {\n    return;\n  }\n\n  // The callback `fn` might be used for multiple nodes/events. Since we generate\n  // a wrapper function, we need to keep track of it when we remove the listener.\n  // It's more efficient to store the node/type/options information as Array in\n  // `fn` itself rather than the node (we assume that the same callback is used\n  // for few nodes at most, whereas a node will likely have many event listeners).\n  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n  let capture, once, passive;\n  if (optionsOrCapture && typeof optionsOrCapture === 'object') {\n    capture = Boolean(optionsOrCapture.capture);\n    once = Boolean(optionsOrCapture.once);\n    passive = Boolean(optionsOrCapture.passive);\n  } else {\n    capture = Boolean(optionsOrCapture);\n    once = false;\n    passive = false;\n  }\n  // hack to let ShadyRoots have event listeners\n  // event listener will be on host, but `currentTarget`\n  // will be set to shadyroot for event listener\n  let target = (optionsOrCapture && optionsOrCapture.__shadyTarget) || this;\n\n  let wrappers = fnOrObj[eventWrappersName];\n  if (wrappers) {\n    // Stop if the wrapper function has already been created.\n    if (findListener(wrappers, target, type, capture, once, passive) > -1) {\n      return;\n    }\n  } else {\n    fnOrObj[eventWrappersName] = [];\n  }\n\n  /**\n   * @this {HTMLElement}\n   * @param {Event} e\n   */\n  const wrapperFn = function(e) {\n    // Support `once` option.\n    if (once) {\n      this.removeEventListener(type, fnOrObj, optionsOrCapture);\n    }\n    if (!e['__target']) {\n      patchEvent(e);\n    }\n    let lastCurrentTargetDesc;\n    if (target !== this) {\n      // replace `currentTarget` to make `target` and `relatedTarget` correct for inside the shadowroot\n      lastCurrentTargetDesc = Object.getOwnPropertyDescriptor(e, 'currentTarget');\n      Object.defineProperty(e, 'currentTarget', {get() { return target }, configurable: true});\n    }\n    // There are two critera that should stop events from firing on this node\n    // 1. the event is not composed and the current node is not in the same root as the target\n    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node\n    if (e.composed || e.composedPath().indexOf(target) > -1) {\n      if (hasRetargeted(e) && e.target === e.relatedTarget) {\n        if (e.eventPhase === Event.BUBBLING_PHASE) {\n          e.stopImmediatePropagation();\n        }\n        return;\n      }\n      // prevent non-bubbling events from triggering bubbling handlers on shadowroot, but only if not in capture phase\n      if (e.eventPhase !== Event.CAPTURING_PHASE && !e.bubbles && e.target !== target && !(target instanceof Window)) {\n        return;\n      }\n      let ret = handlerType === 'function' ?\n        fnOrObj.call(target, e) :\n        (fnOrObj.handleEvent && fnOrObj.handleEvent(e));\n      if (target !== this) {\n        // replace the \"correct\" `currentTarget`\n        if (lastCurrentTargetDesc) {\n          Object.defineProperty(e, 'currentTarget', lastCurrentTargetDesc);\n          lastCurrentTargetDesc = null;\n        } else {\n          delete e['currentTarget'];\n        }\n      }\n      return ret;\n    }\n  };\n  // Store the wrapper information.\n  fnOrObj[eventWrappersName].push({\n    node: this,\n    type: type,\n    capture: capture,\n    once: once,\n    passive: passive,\n    wrapperFn: wrapperFn\n  });\n\n  if (nonBubblingEventsToRetarget[type]) {\n    this.__handlers = this.__handlers || {};\n    this.__handlers[type] = this.__handlers[type] ||\n      {'capture': [], 'bubble': []};\n    this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);\n  } else {\n    let ael = this instanceof Window ? nativeMethods.windowAddEventListener :\n      nativeMethods.addEventListener;\n    ael.call(this, type, wrapperFn, optionsOrCapture);\n  }\n}\n\n/**\n * @this {Event}\n */\nexport function removeEventListener(type, fnOrObj, optionsOrCapture) {\n  if (!fnOrObj) {\n    return;\n  }\n\n  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n  let capture, once, passive;\n  if (optionsOrCapture && typeof optionsOrCapture === 'object') {\n    capture = Boolean(optionsOrCapture.capture);\n    once = Boolean(optionsOrCapture.once);\n    passive = Boolean(optionsOrCapture.passive);\n  } else {\n    capture = Boolean(optionsOrCapture);\n    once = false;\n    passive = false;\n  }\n  let target = (optionsOrCapture && optionsOrCapture.__shadyTarget) || this;\n  // Search the wrapped function.\n  let wrapperFn = undefined;\n  let wrappers = getEventWrappers(fnOrObj);\n  if (wrappers) {\n    let idx = findListener(wrappers, target, type, capture, once, passive);\n    if (idx > -1) {\n      wrapperFn = wrappers.splice(idx, 1)[0].wrapperFn;\n      // Cleanup.\n      if (!wrappers.length) {\n        fnOrObj[eventWrappersName] = undefined;\n      }\n    }\n  }\n  let rel = this instanceof Window ? nativeMethods.windowRemoveEventListener :\n    nativeMethods.removeEventListener;\n  rel.call(this, type, wrapperFn || fnOrObj, optionsOrCapture);\n  if (wrapperFn && nonBubblingEventsToRetarget[type] &&\n      this.__handlers && this.__handlers[type]) {\n    const arr = this.__handlers[type][capture ? 'capture' : 'bubble'];\n    const idx = arr.indexOf(wrapperFn);\n    if (idx > -1) {\n      arr.splice(idx, 1);\n    }\n  }\n}\n\nfunction activateFocusEventOverrides() {\n  for (let ev in nonBubblingEventsToRetarget) {\n    window.addEventListener(ev, function(e) {\n      if (!e['__target']) {\n        patchEvent(e);\n        retargetNonBubblingEvent(e);\n      }\n    }, true);\n  }\n}\n\nfunction patchEvent(event) {\n  event['__target'] = event.target;\n  event.__relatedTarget = event.relatedTarget;\n  // patch event prototype if we can\n  if (utils.settings.hasDescriptors) {\n    utils.patchPrototype(event, eventMixin);\n  // and fallback to patching instance\n  } else {\n    utils.extend(event, eventMixin);\n  }\n}\n\nlet PatchedEvent = mixinComposedFlag(window.Event);\nlet PatchedCustomEvent = mixinComposedFlag(window.CustomEvent);\nlet PatchedMouseEvent = mixinComposedFlag(window.MouseEvent);\n\nexport function patchEvents() {\n  window.Event = PatchedEvent;\n  window.CustomEvent = PatchedCustomEvent;\n  window.MouseEvent = PatchedMouseEvent;\n  activateFocusEventOverrides();\n}\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from './utils.js';\nimport {flush} from './flush.js';\nimport {dispatchEvent, contains as nativeContains} from './native-methods.js';\nimport * as mutation from './logical-mutation.js';\nimport {ActiveElementAccessor, ShadowRootAccessor, patchAccessors} from './patch-accessors.js';\nimport {addEventListener, removeEventListener} from './patch-events.js';\nimport {attachShadow, ShadyRoot} from './attach-shadow.js';\n\nfunction getAssignedSlot(node) {\n  mutation.renderRootNode(node);\n  return node.__shady && node.__shady.assignedSlot || null;\n}\n\nlet windowMixin = {\n\n  // NOTE: ensure these methods are bound to `window` so that `this` is correct\n  // when called directly from global context without a receiver; e.g.\n  // `addEventListener(...)`.\n  addEventListener: addEventListener.bind(window),\n\n  removeEventListener: removeEventListener.bind(window)\n\n};\n\nlet nodeMixin = {\n\n  addEventListener: addEventListener,\n\n  removeEventListener: removeEventListener,\n\n  appendChild(node) {\n    return mutation.insertBefore(this, node);\n  },\n\n  insertBefore(node, ref_node) {\n    return mutation.insertBefore(this, node, ref_node);\n  },\n\n  removeChild(node) {\n    return mutation.removeChild(this, node);\n  },\n\n  /**\n   * @this {Node}\n   */\n  replaceChild(node, ref_node) {\n    mutation.insertBefore(this, node, ref_node);\n    mutation.removeChild(this, ref_node);\n    return node;\n  },\n\n  /**\n   * @this {Node}\n   */\n  cloneNode(deep) {\n    return mutation.cloneNode(this, deep);\n  },\n\n  /**\n   * @this {Node}\n   */\n  getRootNode(options) {\n    return mutation.getRootNode(this, options);\n  },\n\n  contains(node) {\n    return utils.contains(this, node);\n  },\n\n  /**\n   * @this {Node}\n   */\n  get isConnected() {\n    // Fast path for distributed nodes.\n    const ownerDocument = this.ownerDocument;\n    if (utils.hasDocumentContains && nativeContains.call(ownerDocument, this)) {\n      return true;\n    }\n    if (ownerDocument.documentElement &&\n      nativeContains.call(ownerDocument.documentElement, this)) {\n      return true;\n    }\n    let node = this;\n    while (node && !(node instanceof Document)) {\n      node = node.parentNode || (node instanceof ShadyRoot ? /** @type {ShadowRoot} */(node).host : undefined);\n    }\n    return !!(node && node instanceof Document);\n  },\n\n  /**\n   * @this {Node}\n   */\n  dispatchEvent(event) {\n    flush();\n    return dispatchEvent.call(this, event);\n  }\n\n};\n\n// NOTE: For some reason 'Text' redefines 'assignedSlot'\nlet textMixin = {\n  /**\n   * @this {Text}\n   */\n  get assignedSlot() {\n    return getAssignedSlot(this);\n  }\n};\n\nlet fragmentMixin = {\n\n  // TODO(sorvell): consider doing native QSA and filtering results.\n  /**\n   * @this {DocumentFragment}\n   */\n  querySelector(selector) {\n    // match selector and halt on first result.\n    let result = mutation.query(this, function(n) {\n      return utils.matchesSelector(n, selector);\n    }, function(n) {\n      return Boolean(n);\n    })[0];\n    return result || null;\n  },\n\n  /**\n   * @this {DocumentFragment}\n   */\n  querySelectorAll(selector) {\n    return mutation.query(this, function(n) {\n      return utils.matchesSelector(n, selector);\n    });\n  }\n\n};\n\nlet slotMixin = {\n\n  /**\n   * @this {HTMLSlotElement}\n   */\n  assignedNodes(options) {\n    if (this.localName === 'slot') {\n      mutation.renderRootNode(this);\n      return this.__shady ?\n        ((options && options.flatten ? this.__shady.flattenedNodes :\n        this.__shady.assignedNodes) || []) :\n        [];\n    }\n  }\n\n};\n\nlet elementMixin = utils.extendAll({\n\n  /**\n   * @this {HTMLElement}\n   */\n  setAttribute(name, value) {\n    mutation.setAttribute(this, name, value);\n  },\n\n  /**\n   * @this {HTMLElement}\n   */\n  removeAttribute(name) {\n    mutation.removeAttribute(this, name);\n  },\n\n  /**\n   * @this {HTMLElement}\n   */\n  attachShadow(options) {\n    return attachShadow(this, options);\n  },\n\n  /**\n   * @this {HTMLElement}\n   */\n  get slot() {\n    return this.getAttribute('slot');\n  },\n\n  /**\n   * @this {HTMLElement}\n   */\n  set slot(value) {\n    mutation.setAttribute(this, 'slot', value);\n  },\n\n  /**\n   * @this {HTMLElement}\n   */\n  get assignedSlot() {\n    return getAssignedSlot(this);\n  }\n\n}, fragmentMixin, slotMixin);\n\nObject.defineProperties(elementMixin, ShadowRootAccessor);\n\nlet documentMixin = utils.extendAll({\n  /**\n   * @this {Document}\n   */\n  importNode(node, deep) {\n    return mutation.importNode(node, deep);\n  },\n\n  /**\n   * @this {Document}\n   */\n  getElementById(id) {\n    let result = mutation.query(this, function(n) {\n      return n.id == id;\n    }, function(n) {\n      return Boolean(n);\n    })[0];\n    return result || null;\n  }\n\n}, fragmentMixin);\n\nObject.defineProperties(documentMixin, {\n  '_activeElement': ActiveElementAccessor.activeElement\n});\n\nlet nativeBlur = HTMLElement.prototype.blur;\n\nlet htmlElementMixin = utils.extendAll({\n  /**\n   * @this {HTMLElement}\n   */\n  blur() {\n    let root = this.__shady && this.__shady.root;\n    let shadowActive = root && root.activeElement;\n    if (shadowActive) {\n      shadowActive.blur();\n    } else {\n      nativeBlur.call(this);\n    }\n  }\n})\n\nfunction patchBuiltin(proto, obj) {\n  let n$ = Object.getOwnPropertyNames(obj);\n  for (let i=0; i < n$.length; i++) {\n    let n = n$[i];\n    let d = Object.getOwnPropertyDescriptor(obj, n);\n    // NOTE: we prefer writing directly here because some browsers\n    // have descriptors that are writable but not configurable (e.g.\n    // `appendChild` on older browsers)\n    if (d.value) {\n      proto[n] = d.value;\n    } else {\n      Object.defineProperty(proto, n, d);\n    }\n  }\n}\n\n\n// Apply patches to builtins (e.g. Element.prototype). Some of these patches\n// can be done unconditionally (mostly methods like\n// `Element.prototype.appendChild`) and some can only be done when the browser\n// has proper descriptors on the builtin prototype\n// (e.g. `Element.prototype.firstChild`)`. When descriptors are not available,\n// elements are individually patched when needed (see e.g.\n// `patchInside/OutsideElementAccessors` in `patch-accessors.js`).\nexport function patchBuiltins() {\n  let nativeHTMLElement =\n    (window['customElements'] && window['customElements']['nativeHTMLElement']) ||\n    HTMLElement;\n  // These patches can always be done, for all supported browsers.\n  patchBuiltin(window.Node.prototype, nodeMixin);\n  patchBuiltin(window.Window.prototype, windowMixin);\n  patchBuiltin(window.Text.prototype, textMixin);\n  patchBuiltin(window.DocumentFragment.prototype, fragmentMixin);\n  patchBuiltin(window.Element.prototype, elementMixin);\n  patchBuiltin(window.Document.prototype, documentMixin);\n  if (window.HTMLSlotElement) {\n    patchBuiltin(window.HTMLSlotElement.prototype, slotMixin);\n  }\n  patchBuiltin(nativeHTMLElement.prototype, htmlElementMixin);\n  // These patches can *only* be done\n  // on browsers that have proper property descriptors on builtin prototypes.\n  // This includes: IE11, Edge, Chrome >= 4?; Safari >= 10, Firefox\n  // On older browsers (Chrome <= 4?, Safari 9), a per element patching\n  // strategy is used for patching accessors.\n  if (utils.settings.hasDescriptors) {\n    patchAccessors(window.Node.prototype);\n    patchAccessors(window.Text.prototype);\n    patchAccessors(window.DocumentFragment.prototype);\n    patchAccessors(window.Element.prototype);\n    patchAccessors(nativeHTMLElement.prototype);\n    patchAccessors(window.Document.prototype);\n    if (window.HTMLSlotElement) {\n      patchAccessors(window.HTMLSlotElement.prototype);\n    }\n  }\n}\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Patches elements that interacts with ShadyDOM\n * such that tree traversal and mutation apis act like they would under\n * ShadowDOM.\n *\n * This import enables seemless interaction with ShadyDOM powered\n * custom elements, enabling better interoperation with 3rd party code,\n * libraries, and frameworks that use DOM tree manipulation apis.\n */\n\nimport * as utils from './utils.js';\nimport {flush, enqueue} from './flush.js';\nimport {observeChildren, unobserveChildren, filterMutations} from './observe-changes.js';\nimport * as nativeMethods from './native-methods.js';\nimport * as nativeTree from './native-tree.js';\nimport {patchBuiltins} from './patch-builtins.js';\nimport {patchEvents} from './patch-events.js';\nimport {ShadyRoot} from './attach-shadow.js';\n\nif (utils.settings.inUse) {\n  let ShadyDOM = {\n    // TODO(sorvell): remove when Polymer does not depend on this.\n    'inUse': utils.settings.inUse,\n    // TODO(sorvell): remove when Polymer does not depend on this\n    'patch': (node) => node,\n    'isShadyRoot': utils.isShadyRoot,\n    'enqueue': enqueue,\n    'flush': flush,\n    'settings': utils.settings,\n    'filterMutations': filterMutations,\n    'observeChildren': observeChildren,\n    'unobserveChildren': unobserveChildren,\n    'nativeMethods': nativeMethods,\n    'nativeTree': nativeTree\n  };\n\n  window['ShadyDOM'] = ShadyDOM;\n\n  // Apply patches to events...\n  patchEvents();\n  // Apply patches to builtins (e.g. Element.prototype) where applicable.\n  patchBuiltins();\n\n  window.ShadowRoot = ShadyRoot;\n}\n"]},"metadata":{},"sourceType":"script"}